import os
import unittest

from kim_and_lee_vulnerability_detection import (detect_41_31_vuln_in_bp_no_uxss,
                                                 detect_41_31_vuln_in_bp_uxss,
                                                 detect_31_vuln_in_bp,
                                                 detect_42_32_vuln_in_bp,
                                                 detect_42_32_vuln_in_cs,
                                                 detect_43_31_vuln_in_bp,
                                                 detect_43_32_vuln_in_bp,
                                                 get_extension_storage_accesses
                                                 )
from src.pdg_js.node import Node

os.environ['PARSER'] = "espree"
os.environ['SOURCE_TYPE'] = "module"
os.environ['RETURN_MULTIPLE_FLOW_VARIANTS'] = "yes"
os.environ['DEBUG'] = "yes"
# os.environ['PRINT_PDGS'] = "yes"
os.environ['TIMEOUT'] = "600"


def get_and_extend_pdg(code: str) -> Node:
    res_dict = dict()
    benchmarks = res_dict['benchmarks'] = dict()

    return Node.pdg_from_string(js_code=code,
                                benchmarks=benchmarks)


def analyze_bp_41_31(code: str, uxss: bool) -> list:
    """
    tests detect_41_31_vuln_in_bp_no_uxss() or detect_41_31_vuln_in_bp_uxss()
    """
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    if uxss:
        detect_41_31_vuln_in_bp_uxss(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    else:
        detect_41_31_vuln_in_bp_no_uxss(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


def analyze_bp_31(code: str) -> list:  # tests detect_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={})
    print(f"len(results) = {len(results)}")
    return results


def analyze_bp_42_32(code: str) -> list:
    pdg_bp = get_and_extend_pdg(code)
    results = []
    detect_42_32_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


def analyze_cs_42_32(code: str) -> list:
    pdg_cs = get_and_extend_pdg(code)
    results = []
    detect_42_32_vuln_in_cs(pdg_cs=pdg_cs, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


def analyze_bp_43_31(code: str) -> list:
    pdg_bp = get_and_extend_pdg(code)
    results = []
    detect_43_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


def analyze_bp_43_32(code: str) -> list:
    pdg_bp = get_and_extend_pdg(code)
    results = []
    detect_43_32_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


class KimAndLeeVulnDetectionIntegrationTests(unittest.TestCase):
    # ToDo: chrome.cookies gets aliased test cases
    # ToDo: handle foo(this.functionReference) and not just foo(functionReference) !!!
    #       => may refer to a global or a class function !!!
    #       => cf. mlomiejdfkolichcflejclcbmpeaniij
    # ToDo: handle chrome.runtime.onMessage = (msg, sender, sendResponse) => {}; !!!!! !!!!! !!!!!
    #       => of course, test whether this actually works beforehand !!!!!

    def test_detect_41_31_vuln_in_bp_no_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (browser.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        browser.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            browser.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        # => Notes on this:
        #    Some real-world extensions using "browser.runtime.onMessage.addListener":
        #    * "Adblock Plus - free ad blocker", v3.12 (ID: cfhdojbkjhnklbpkdaibdccddilifddb), background.js, line 703:
        #      browser.runtime.onMessage.addListener((message, rawSender, sendResponse) => { ... }
        #    Some real-world extensions using "browser.cookies":
        #    * "Windscribe - Free Proxy and Ad Blocker", v3.4.0 (ID: hnmpcagpplmpfojmgmnngilcnanddlhb), background.js, line 13229:
        #      return browser.cookies.getAll({domain: Object(L.a)(e)})
        #    This is the way the APIs are called in Firefox, browser extensions can be made to work in both major
        #    browsers by using a Polyfill, cf.:
        #    https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Build_a_cross_browser_extension

        # Some extensions might hide the chrome/browser object in even more complex ways:

        # Example taken from / inspired by "Ghostery", v.8.6.3 (ID: mlomiejdfkolichcflejclcbmpeaniij):
        #     this.browser.runtime.onMessage.addListener(this.onRuntimeMessage)
        code = """
        this.browser.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            browser.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # + see also the "Terra Station Wallet" example a bit down below...

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call (inside an if),
        #   no sender check whatsoever, cookie data flow continues *beyond* the sink call as well):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (foo()) {
                        sendResponse(cookies);
                    }
                    let cookies2 = cookies;
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (sink call) (A):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (sink call) (B):
        code = """
        chrome.runtime.onMessage.addListener(function foo (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (no sink call):
        code = """
        chrome.runtime.onMessage.addListener(function foo(msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ArrowFunctionExpressions with parameter default values:
        code = """
        chrome.runtime.onMessage.addListener((msg=null, sender=null, sendResponse=null) => {
            chrome.cookies.getAll({},
                (cookies=null) => {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions with parameter default values:
        code = """
        chrome.runtime.onMessage.addListener(function (msg=null, sender=null, sendResponse=null) {
            chrome.cookies.getAll({},
                function(cookies=null) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions with names *and* parameter default values:
        code = """
        chrome.runtime.onMessage.addListener(function foo(msg=null, sender=null, sendResponse=null) {
            chrome.cookies.getAll({},
                function bar(cookies=null) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### With data flow through intermediary variables: #####

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    sendResponse(cookies5);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (foo()) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls (1 unreachable), no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (1==1) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5); // unreachable sink call
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = cookies[0]; // or: JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow continues beyond variable used in sink):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    let cookies4 = cookies3;
                    sendResponse(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [first_cookie, second_cookie] = [cookies[0], cookies[1]]; // Destructuring Assignment
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [cookies2, forty_two] = [cookies, 42]; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {a:cookies, b:42}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {b:42, a:cookies}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          sink(!) flows through intermediary variable):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            var sendResponseAlias = sendResponse;
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    sendResponseAlias(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # With data flow through a class method (1):
        code = """
        class Cookies {
            constructor() {}
            sendTo(recipient) {
                chrome.cookies.getAll({},
                    function(cookies) {
                        recipient(cookies);
                    }
                );
            }
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let c = new Cookies();
            c.sendTo(sendResponse);
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # With data flow through a class method (2):
        code = """
        class Cookies {
            constructor() {}
            sendTo(recipient) {
                chrome.cookies.getAll({},
                    function(cookies) {
                        recipient(cookies);
                    }
                );
            }
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            new Cookies().sendTo(sendResponse);
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
        # ##### ##### ##### Examples with sender verification: ##### ##### #####
        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == 'https://admin.com') {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check in unusual order:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if ("https://admin.com" == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check using triple-equals ("==="):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url === "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into two intermediary variables first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through 2 intermediary
        #     variables:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into (just) one intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through just 1 intermediary
        #     variable:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == tab_url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && foobar()) {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" & foobar()) { // & instead of &&
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial conjunction (x && x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && url == "https://admin.com") {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || foobar()) {
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | foobar()) { // | instead of ||
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin2.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | url == "https://admin2.com") { // | instead of ||
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial disjunction (x || x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first;
        #     we consider all HTTP URLs to be unsafe as a renderer + network(!) attacker can still exploit the
        #     vulnerability:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "http://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # .startsWith() tests:

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com/")) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("http://admin.com/")) { // considered unsafe only because of the "http"
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        # Test whether the --consider-http-as-safe argument has the effect of this vuln. not being reported anymore:
        os.environ['CONSIDER_HTTP_AS_SAFE'] = "yes"
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)
        del os.environ['CONSIDER_HTTP_AS_SAFE']

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com")) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test data flows through ObjectPatterns:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle ObjectPatterns as lambda arguments:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin, url, tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin, url: url, tab: tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin1, url: url1, tab: tab1}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with chrome.cookies.get(): ##### ##### #####

        # Basic example (chrome.cookies.get, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, (cookie) => {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.get, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie && url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie || url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with fetch(): ##### ##### #####

        # Basic example (fetch, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => sendResponse(response))
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Basic example (fetch, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example.com/")
                .then(function (response) { sendResponse(response); })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Fetch example, sink in 2nd then() call:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => response.json())
                .then(response => sendResponse(response));
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Fetch example, sender safely authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url == "https://www.example.com/") {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example, sender not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url.startsWith("https://www.example.com")) {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Fetch example with await instead of .then(), correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com/")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example with await instead of .then(), not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Handle function references: ##### ##### #####

        code = """
        function msg_handler(msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        }
        
        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function msg_handler(msg, sender, sendResponse=null) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        }
        
        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test nested functions (!!!):
        code = """
        function msg_handler(msg, sender, sendResponse) {
            function cookies_handler(cookies) {
                sendResponse(cookies);
            }
        
            chrome.cookies.getAll({}, cookies_handler);
            return true;
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function msg_handler(msg, sender, sendResponse) {
            let url = sender.url;
            if (url == "https://admin.com") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        sendResponse(cookies);
                    }
                );
                return true;
            } else {
                sendResponse("authentication failed");
            }
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Data flow through separate function: ##### ##### #####

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }
        
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            getCookies(sendResponse);
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            if (url == "https://admin.com") {
                getCookies(sendResponse);
                return true;
            }
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Handle Promises instead of callbacks: ##### ##### #####

        # Direct call of chrome.cookies.getAll({}).then(...):
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          chrome.cookies.getAll({}).then( // => use Promise instead of callback
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          let promise = chrome.cookies.getAll({});
          promise.then(
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );
        
          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable,
        #   .then() call references function instead of being supplied an anonymous function directly:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          function cookies_handler(cookies) {
            sendResponse(cookies);
          }
          
          let promise = chrome.cookies.getAll({});
          promise.then(cookies_handler);

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is awaited inside an async code block:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          (async () => {
            let cookies = await chrome.cookies.getAll({});
            //console.log(cookies);
            sendResponse(cookies);
          })();
        
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### Handle chrome.runtime.onConnect.addListener() instead of chrome.runtime.onMessage.addListener(): #####

        # Non-vulnerable:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            port.postMessage("no sensitive data exfiltration here");
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Vulnerable (cookie exfiltration):
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.getAll({},
                function(cookies) {
                    port.postMessage(cookies);
                }
            );
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Vulnerable (cookie exfiltration) (test static eval of strings):
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.getAll({},
                function(cookies) {
                    port['post'+'Message'](cookies);
                }
            );
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # An example inspired by "Terra Station Wallet", v.2.7.0 (ID: aiifbnbfobpmeekipheeijimdpnlpgpp):
        #     extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a.runtime.onConnect.addListener(connectRemote)
        code = """
        extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a.runtime.onConnect.addListener((port => {
            chrome.cookies.getAll({},
                function(cookies) {
                    port.postMessage(cookies);
                }
            );
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Swap ArrowFunctionExpression and FunctionExpression:
        code = """
        chrome.runtime.onConnect.addListener(function (port) {
            chrome.cookies.getAll({},
                (cookies) => {
                    port.postMessage(cookies);
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # chrome.cookies.get() instead of chrome.cookies.getAll():
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function(cookie) {
                port.postMessage(cookie);
            });
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # With correct sender authentication: # todo: does this code work?!
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let port_sender = port.sender;
            let sender_url = port_sender.url;
            if (sender_url == "https://www.google.com/") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # With incorrect sender authentication:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let sender = port.sender;
            let sender_url = sender.url;
            if (sender_url == "https://www.google.com/" || foo()) {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test a type of false positive that often occurred for the Kim+Lee extensions:
        code = """
        !function(a) {}(
            function() {
                chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
                    sendResponse("completely harmless");
                });
                function somethingWithCookies() {
                    chrome.cookies.getAll({},
                        function(cookies) {
                            something(cookies);
                        }
                    );
                }
            }()
        );
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ToDo: sender.origin verification
        # ToDo: sender verification w/o flow through intermediary variable
        # ToDo: check sender UN-safety and execute sensitive code in else block
        # ToDo: check sender UN-safety and return

    def test_detect_41_31_vuln_in_bp_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)
        # Note that, because of RETURN_MULTIPLE_FLOW_VARIANTS == "yes", there are actually multiple flows found:
        #   (1) source: msg => uname => new_span
        #       sink:   document => body
        #   (2) source: msg => uname => new_span
        #       sink:   document => new_span

        # Same example but with a destructured message parameter:
        code = """
        chrome.runtime.onMessage.addListener(({some: msg}, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Basic example (long-lived instead of one-time connection as above):
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port.onMessage.addListener(function(msg) {
                chrome.tabs.query({},
                    (tabs) => {
                        tabs.forEach((tab) => {
                            chrome.scripting.executeScript({
                                target: { tabId: tab.id },
                                func: (uname) => {
                                    const body = document.getElementsByTagName('body')[0];
                                    const new_span = document.createElement('span');
                                    new_span.innerHTML = 'Hello ' + uname + '!';
                                    body.append(new_span);
                                },
                                args: [msg["user_name"]]
                            });
                        });
                    }
                );
                
                port.postMessage("ok");
            });   
        });
        """
        self.assertGreaterEqual(len(analyze_bp_41_31(code, uxss=True)), 1)
        # => cf. https://developer.chrome.com/docs/extensions/develop/concepts/messaging#connect

        # Same example but destructuring the message parameter:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port.onMessage.addListener(function({some: msg}) {
                chrome.tabs.query({},
                    (tabs) => {
                        tabs.forEach((tab) => {
                            chrome.scripting.executeScript({
                                target: { tabId: tab.id },
                                func: (uname) => {
                                    const body = document.getElementsByTagName('body')[0];
                                    const new_span = document.createElement('span');
                                    new_span.innerHTML = 'Hello ' + uname + '!';
                                    body.append(new_span);
                                },
                                args: [msg["user_name"]]
                            });
                        });
                    }
                );

                port.postMessage("ok");
            });   
        });
        """
        self.assertGreaterEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # Same example but with a small catch added, testing static evaluation of strings:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port['on'+'Message'].addListener(function(msg) {
                chrome.tabs.query({},
                    (tabs) => {
                        tabs.forEach((tab) => {
                            chrome.scripting.executeScript({
                                target: { tabId: tab.id },
                                func: (uname) => {
                                    const body = document.getElementsByTagName('body')[0];
                                    const new_span = document.createElement('span');
                                    new_span.innerHTML = 'Hello ' + uname + '!';
                                    body.append(new_span);
                                },
                                args: [msg["user_name"]]
                            });
                        });
                    }
                );

                port.postMessage("ok");
            });   
        });
        """
        self.assertGreaterEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # And another one:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port.onMessage['add'+'Listener'](function(msg) {
                chrome.tabs.query({},
                    (tabs) => {
                        tabs.forEach((tab) => {
                            chrome.scripting.executeScript({
                                target: { tabId: tab.id },
                                func: (uname) => {
                                    const body = document.getElementsByTagName('body')[0];
                                    const new_span = document.createElement('span');
                                    new_span.innerHTML = 'Hello ' + uname + '!';
                                    body.append(new_span);
                                },
                                args: [msg["user_name"]]
                            });
                        });
                    }
                );

                port.postMessage("ok");
            });   
        });
        """
        self.assertGreaterEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # And yet another one:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port['on'+'Message']['add'+'Listener'](function(msg) {
                chrome.tabs.query({},
                    (tabs) => {
                        tabs.forEach((tab) => {
                            chrome.scripting.executeScript({
                                target: { tabId: tab.id },
                                func: (uname) => {
                                    const body = document.getElementsByTagName('body')[0];
                                    const new_span = document.createElement('span');
                                    new_span.innerHTML = 'Hello ' + uname + '!';
                                    body.append(new_span);
                                },
                                args: [msg["user_name"]]
                            });
                        });
                    }
                );

                port.postMessage("ok");
            });   
        });
        """
        self.assertGreaterEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # Basic example (chrome.scripting.executeScript, FunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach(function (tab) {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Basic example (chrome.scripting.executeScript, named FunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener(function foo(msg, sender, sendResponse) {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach(function bar(tab) {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 2 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 1 arg):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 0 args):
        code = """
        chrome.runtime.onMessage.addListener(() => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: ["user_name"]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 0)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 4 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse, foobar) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # Data flows into the DOM not via body.append() but rather via document.write():
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse, foobar) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                document.write(uname);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # Data flow into existing instead of new DOM element; data flows end not in a CallExpression but rather in an
        #   AssignmentExpression; redundant argument "x" passed to "args":
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname, y, z) => {
                                const existing_span = document.getElementById('existing_span');
                                existing_span.innerHTML = 'Hello ' + uname + '!';
                            },
                            args: [msg["user_name"], x]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Test data flow through function return value:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            function get_user_name() {
                return msg["user_name"];
            }
        
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname, y, z) => {
                                const existing_span = document.getElementById('existing_span');
                                existing_span.innerHTML = 'Hello ' + uname + '!';
                            },
                            args: [get_user_name(), x]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Test data flow through static class method return value; works trivially because the
        #   `Utils.get_user_name(msg)` expression already contains `msg` anyways:
        code = """
        class Utils {
            constructor() {}
            static get_user_name(msg) {
                return msg["user_name"];
            }
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname, y, z) => {
                                const existing_span = document.getElementById('existing_span');
                                existing_span.innerHTML = 'Hello ' + uname + '!';
                            },
                            args: [Utils.get_user_name(msg), x]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # A simplified example using the (deprecated!) chrome.tabs.executeScript() API instead of the
        #   chrome.scripting.executeScript() API:
        code = """
        chrome.runtime.onMessage.addListener(function(t, n, e) {
            chrome.tabs.executeScript(n, {
                code: t
            });
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # An (almost) real-world example using the (deprecated!) chrome.tabs.executeScript() API instead of the
        #   chrome.scripting.executeScript() API; also tests multiple complex types of data flows:
        #   * from `t` to `r` in `t.data.data.forEach(function(r) { ... })`
        #   * IIFEs (Immediately Invoked Function Expressions)
        code = r"""
        chrome.runtime.onMessage.addListener((function(t, n, e) {
                var o, c, u, s = n.tab.windowId,
                    l = n.tab.id;
                "initiate-sso-tasks" == t.type ? function(t, n, e) {
                    f.apply(this, arguments)
                }(l, t.data, n.frameId) : "initiate-sso" == t.type ? (o = t.data, c = l, u = !1, chrome.tabs.onUpdated.addListener((function t2(n, e, r) {
                    n === c && (e.url && (u = !0), "complete" === e.status && u && (chrome.tabs.onUpdated.removeListener(t2), chrome.tabs.sendMessage(n, {
                        type: "handle-sso",
                        data: o
                    }, (function() {}))))
                }))) : "initiate-autolaunch" == t.type ? function(t, n, e) {
                    a && t.data.data && t.data.data.length > 0 && t.data.data.forEach((function(r) {
                        ! function(t, n, e, r) {
                            var i = e.data.IdConfigBaseUrl,
                                o = r.id,
                                c = r.type,
                                u = r.url ? r.url : [];
                            u && 0 == u.length && (u[0] = "");
                            var a = {
                                app_id: o,
                                windowId: t,
                                tabId: n,
                                gwstoken: e.data.gwstoken,
                                LaunchpadUri: i.replace(/^https?:\/\//, "")
                            };
                            switch (c) {
                                case 1:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 7:
                                case 8:
                                    d(n, o);
                                    break;
                                case 9:
                                    g(i + "/clsso/" + encodeURIComponent(o), a);
                                    break;
                                case 14:
                                    g(u[0], a);
                                    break;
                                case 15:
                                    g(i + "/browsersso/" + encodeURIComponent(o), a);
                                    break;
                                case 16:
                                case 36:
                                    g(i + "/ltisso/" + o, a);
                                    break;
                                case 17:
                                    g(i + "/focussso/" + o, a);
                                    break;
                                case 18:
                                    g(i + "/pearson/mathxl/" + o, a);
                                    break;
                                case 19:
                                    g(i + "/pearson/mymathlab/" + o, a);
                                    break;
                                case 20:
                                    g(i + "/custom/certification/" + o, a);
                                    break;
                                case 21:
                                    g(i + "/oneroster/" + o, a);
                                    break;
                                case 22:
                                    g(i + "/phonebook/" + o, a);
                                    break;
                                case 23:
                                    g(i + "/onerosterlti/" + o, a);
                                    break;
                                case 24:
                                    g(i + "/assignapplication/" + o, a);
                                    break;
                                case 25:
                                case 26:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 3:
                                case 27:
                                    var s = u[0],
                                        f = "var s = document.createElement('script');";
                                    f += " s.textContent = \"(function() { var interval = setInterval(function() { if(window.CloudApp && window.CloudApp.MyApps) { window.CloudApp.MyApps.Controller.launchLocalApp('" + s + "'); clearInterval(interval); } }, 700); })();\";", f += " document.head.appendChild(s);", chrome.tabs.executeScript(n, {
                                        code: f
                                    });
                                    break;
                                case 28:
                                    g(i + "/custom/genericoneroster/ltilaunch/" + o, a);
                                    break;
                                case 29:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 30:
                                case 31:
                                case 32:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 33:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 34:
                                    g(i + "/custom/naviancestudentsso/" + o, a);
                                    break;
                                case 35:
                                    g(i + "/oneroster/manage/class/" + o, a);
                                    break;
                                case 37:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a)
                            }
                        }(n, e, t, r)
                    }))
                }(t, s, l) : "initiate-apptimer" == t.type ? r = {
                    app_id: t.data.app_id,
                    windowId: s,
                    tabId: l,
                    gwstoken: t.data.gwstoken,
                    LaunchpadUri: t.data.LaunchpadUri
                } : "initiate-ssosignout" == t.type ? t.data && t.data.length > 0 && t.data.forEach((function(t) {
                    chrome.tabs.create({
                        url: t,
                        active: !1
                    })
                })) : "stopapptimers" == t.type && (Object.keys(i.CLAnalytics.clOpenTabs).forEach((function(t) {
                    clearInterval(i.CLAnalytics.clOpenTabs[t].interval), i.CLAnalytics.clOpenTabs[t].interval = null, delete i.CLAnalytics.clOpenTabs[t]
                })), a = !1)
            }))
        """
        # (code from "ClassLink OneClick Extension", version 10.6, extension ID jgfbgkjjlonelmpenhpfeeljjlcgnkpe,
        #  slightly changed)
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # The same example again, but this time unaltered, exactly as it occurred in the real "ClassLink" extension:
        code = r"""
        chrome.runtime.onMessage.addListener((function(t, n, e) {
                var o, c, u, s = n.tab.windowId,
                    l = n.tab.id;
                "initiate-sso-tasks" == t.type ? function(t, n, e) {
                    f.apply(this, arguments)
                }(l, t.data, n.frameId) : "initiate-sso" == t.type ? (o = t.data, c = l, u = !1, chrome.tabs.onUpdated.addListener((function t(n, e, r) {
                    n === c && (e.url && (u = !0), "complete" === e.status && u && (chrome.tabs.onUpdated.removeListener(t), chrome.tabs.sendMessage(n, {
                        type: "handle-sso",
                        data: o
                    }, (function() {}))))
                }))) : "initiate-autolaunch" == t.type ? function(t, n, e) {
                    a && t.data.data && t.data.data.length > 0 && t.data.data.forEach((function(r) {
                        ! function(t, n, e, r) {
                            var i = e.data.IdConfigBaseUrl,
                                o = r.id,
                                c = r.type,
                                u = r.url ? r.url : [];
                            u && 0 == u.length && (u[0] = "");
                            var a = {
                                app_id: o,
                                windowId: t,
                                tabId: n,
                                gwstoken: e.data.gwstoken,
                                LaunchpadUri: i.replace(/^https?:\/\//, "")
                            };
                            switch (c) {
                                case 1:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 7:
                                case 8:
                                    d(n, o);
                                    break;
                                case 9:
                                    g(i + "/clsso/" + encodeURIComponent(o), a);
                                    break;
                                case 14:
                                    g(u[0], a);
                                    break;
                                case 15:
                                    g(i + "/browsersso/" + encodeURIComponent(o), a);
                                    break;
                                case 16:
                                case 36:
                                    g(i + "/ltisso/" + o, a);
                                    break;
                                case 17:
                                    g(i + "/focussso/" + o, a);
                                    break;
                                case 18:
                                    g(i + "/pearson/mathxl/" + o, a);
                                    break;
                                case 19:
                                    g(i + "/pearson/mymathlab/" + o, a);
                                    break;
                                case 20:
                                    g(i + "/custom/certification/" + o, a);
                                    break;
                                case 21:
                                    g(i + "/oneroster/" + o, a);
                                    break;
                                case 22:
                                    g(i + "/phonebook/" + o, a);
                                    break;
                                case 23:
                                    g(i + "/onerosterlti/" + o, a);
                                    break;
                                case 24:
                                    g(i + "/assignapplication/" + o, a);
                                    break;
                                case 25:
                                case 26:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 3:
                                case 27:
                                    var s = u[0],
                                        f = "var s = document.createElement('script');";
                                    f += " s.textContent = \"(function() { var interval = setInterval(function() { if(window.CloudApp && window.CloudApp.MyApps) { window.CloudApp.MyApps.Controller.launchLocalApp('" + s + "'); clearInterval(interval); } }, 700); })();\";", f += " document.head.appendChild(s);", chrome.tabs.executeScript(n, {
                                        code: f
                                    });
                                    break;
                                case 28:
                                    g(i + "/custom/genericoneroster/ltilaunch/" + o, a);
                                    break;
                                case 29:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 30:
                                case 31:
                                case 32:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 33:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 34:
                                    g(i + "/custom/naviancestudentsso/" + o, a);
                                    break;
                                case 35:
                                    g(i + "/oneroster/manage/class/" + o, a);
                                    break;
                                case 37:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a)
                            }
                        }(n, e, t, r)
                    }))
                }(t, s, l) : "initiate-apptimer" == t.type ? r = {
                    app_id: t.data.app_id,
                    windowId: s,
                    tabId: l,
                    gwstoken: t.data.gwstoken,
                    LaunchpadUri: t.data.LaunchpadUri
                } : "initiate-ssosignout" == t.type ? t.data && t.data.length > 0 && t.data.forEach((function(t) {
                    chrome.tabs.create({
                        url: t,
                        active: !1
                    })
                })) : "stopapptimers" == t.type && (Object.keys(i.CLAnalytics.clOpenTabs).forEach((function(t) {
                    clearInterval(i.CLAnalytics.clOpenTabs[t].interval), i.CLAnalytics.clOpenTabs[t].interval = null, delete i.CLAnalytics.clOpenTabs[t]
                })), a = !1)
            }))
        """
        # (code from "ClassLink OneClick Extension", version 10.6, extension ID jgfbgkjjlonelmpenhpfeeljjlcgnkpe,
        #  unaltered)
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # ##### ##### ##### Examples testing performance under certain edge cases: ##### ##### #####

        # Extremely high number of possible total(!) data flows due to many splits:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let _1 = msg;
            let _2 = _1, _3 = _1;
            let _4 = _2 + _3;
            
            let _5 = _4, _6 = _4;
            let _7 = _5 + _6;
            
            let _8 = _7, _9 = _7;
            let _10 = _8 + _9;
            
            let _11 = _10, _12 = _10;
            let _13 = _11 + _12;
            
            let _14 = _13, _15 = _13;
            let _16 = _14 + _15;
            
            let _17 = _16, _18 = _16;
            let _19 = _17 + _18;
            
            let _20 = _19, _21 = _19;
            let _22 = _20 + _21;
            
            let _23 = _22, _24 = _22;
            let _25 = _23 + _24;
            
            let _26 = _25, _27 = _25;
            let _28 = _26 + _27;
            
            let _29 = _28, _30 = _28;
            let _31 = _29 + _30;
            
            let _32 = _31, _33 = _31;
            let _34 = _32 + _33;
            
            let _35 = _34, _36 = _34;
            let _37 = _35 + _36;
            
            let _38 = _37, _39 = _37;
            let msg1 = _38 + _39;
            
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg1["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)
        # Note that, because of RETURN_MULTIPLE_FLOW_VARIANTS == "yes", there are actually two flows found:
        #   (1) source: msg => uname => new_span
        #       sink:   document => body
        #   (2) source: msg => uname => new_span
        #       sink:   document => new_span

    def test_detect_31_vuln_in_bp(self):
        """
        Looking for violations of Security Violation 3.1 without any Execution of Privileged Browser APIs (4.1) however.
        Security Requirement 3.1 refers to the "Extension Message Authentication" (cf. Kim+Lee paper).
        """

        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                var o = {
                    category: "browser-extension",
                    event: "launch-meeting",
                    extVal: e
                };
                doi.send("Event", o, !0)
            }
        })
        """
        # (code from the Cisco WebEx Extension, version 1.17.0)
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)

        # The same but with correct authentication:
        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            const url = n.url;    
            if (url.startsWith("https://www.example.com/")) {
                if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                    var o = {
                        category: "browser-extension",
                        event: "launch-meeting",
                        extVal: e
                    };
                    doi.send("Event", o, !0)
                }
            }
        })
        """
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 0)

        # The same but with *in*correct authentication:
        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            const url = n.url;    
            if (url.startsWith("https://www.example.com")) {
                if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                    var o = {
                        category: "browser-extension",
                        event: "launch-meeting",
                        extVal: e
                    };
                    doi.send("Event", o, !0)
                }
            }
        })
        """
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)

        # The same but this time with a message listener listening on the port of a *long-lived* connection:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port.onMessage.addListener(function(e, n) {  // from the docs: (message: any, port: Port) => void
                if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                    var o = {
                        category: "browser-extension",
                        event: "launch-meeting",
                        extVal: e
                    };
                    doi.send("Event", o, !0)
                }
            });   
        });
        """
        # You may refer to:
        #     * https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=en#type-Port and
        #     * https://developer.chrome.com/docs/extensions/develop/concepts/messaging#connect
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)

        # The same but with correct authentication:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            port.onMessage.addListener(function(e, n) {  // from the docs: (message: any, port: Port) => void
                let port_sender = n.sender;
                let sender_url = port_sender.url;
                if (sender_url == "https://www.google.com/") {
                    if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                        var o = {
                            category: "browser-extension",
                            event: "launch-meeting",
                            extVal: e
                        };
                        doi.send("Event", o, !0)
                    }
                }
            });
        });
        """
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 0)
        # => WARNING: Authentication of the "sender" of the "port" given by "chrome.runtime.onConnect.addListener"
        #             will not be noticed, i.e., still be (incorrectly) returned as a 3.1 vulnerability!!!
        #             Only authentication of the "sender" of the "port" given by "port.onMessage.addListener"
        #             will be noticed!!!

        # The same but with *in*correct authentication:
        code = """
        chrome.runtime.onConnect.addListener(function(port) {
            let port_sender = port.sender;
            let sender_url = port_sender.url;
            if (sender_url != "https://www.google.com/") {
                port.onMessage.addListener(function(e, n) {  // from the docs: (message: any, port: Port) => void
                    if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                        var o = {
                            category: "browser-extension",
                            event: "launch-meeting",
                            extVal: e
                        };
                        doi.send("Event", o, !0)
                    }
                });
            }
        });
        """
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)

    def test_detect_42_32_vuln_in_bp(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 0)

        # Basic example (Promise.then):
        code = """
        chrome.storage.local.get(["user_name"]).then((result) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);

                            },
                            args: ["" + result["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 4)

        # document.write() instead:
        code = """
        chrome.storage.local.get(["user_name"]).then((result) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                document.write(uname);
                            },
                            args: ["" + result["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 1)

        # 'browser' instead of 'chrome':
        code = """
        browser.storage.local.get(["user_name"]).then((result) => {
            browser.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        browser.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);

                            },
                            args: ["" + result["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 4)

        # storage.sync instead of storage.local:
        code = """
        chrome.storage.sync.get(["user_name"]).then((result) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);

                            },
                            args: ["" + result["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 4)

        # Awaiting Promise instead:
        code = """
        let result = await chrome.storage.local.get(["user_name"])
        chrome.tabs.query({},
            (tabs) => {
                tabs.forEach((tab) => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        func: (uname) => {
                            const body = document.getElementsByTagName('body')[0];
                            const new_span = document.createElement('span');
                            new_span.innerHTML = 'Hello ' + uname + '!';
                            body.append(new_span);

                        },
                        args: ["" + result["user_name"]]
                    });
                });
            }
        );
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 4)

        # Old-school callback:
        code = """
        chrome.storage.local.get(["user_name"], function (result) {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);

                            },
                            args: ["" + result["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 4)

        # Old-school (i.e., MV2) "chrome.tabs.executeScript" API instead of "chrome.scripting.executeScript":
        code = """
        chrome.storage.local.get(["user_name"]).then((result) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.tabs.executeScript(tab, { code: "foo" + result + "bar" });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 1)

        # An adapted real-world example using a complex MemberExpression to call (chrome.)storage.local.get()
        # and also using Function.prototype.bind() on the passed callback function expression:
        #     this._namespace.storage.local.get(e, function(e) { ... }.bind(this))
        # (adapted from "Amazon Assistant for Chrome", v.10.2107.7.11654,
        #  ID: pbjikboenpfhbbejgkoklgkhjpfogcam):
        # ##### Version w/o .bind(): #####
        code = """
        this._namespace && this._namespace.storage && this._namespace.storage.local
        && this._namespace.storage.local.get(e, function(e) {
            if (this._checkLastError())
                t._logger.error("", ""), r(new Error(""), null);
            else {
                chrome.tabs.executeScript(tab, { code: "foo" + e + "bar" });
            }
        })
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 1)
        # ##### Version with .bind(): #####
        code = """
        this._namespace && this._namespace.storage && this._namespace.storage.local
        && this._namespace.storage.local.get(e, function(e) {
            if (this._checkLastError())
                t._logger.error("", ""), r(new Error(""), null);
            else {
                chrome.tabs.executeScript(tab, { code: "foo" + e + "bar" });
            }
        }.bind(this))
        """
        self.assertEqual(len(analyze_bp_42_32(code)), 1)

    def test_detect_42_32_vuln_in_cs(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 0)

        # Basic example (Promise.then):
        code = """
        chrome.storage.local.get(["user_name"]).then((result) => {
            const user_name = result["user_name"];
            const body = document.getElementsByTagName('body')[0];
            const new_span = document.createElement('span');
            new_span.innerHTML = 'Hello ' + user_name + '!';
            body.append(new_span);
        });
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 4)

        # document.write() instead:
        code = """
        chrome.storage.local.get(["user_name"]).then((result) => {
            const user_name = result["user_name"];
            document.write(user_name);
        });
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 1)

        # 'browser' instead of 'chrome':
        code = """
        browser.storage.local.get(["user_name"]).then((result) => {
            const user_name = result["user_name"];
            const body = document.getElementsByTagName('body')[0];
            const new_span = document.createElement('span');
            new_span.innerHTML = 'Hello ' + user_name + '!';
            body.append(new_span);
        });
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 4)

        # storage.sync instead of storage.local:
        code = """
        chrome.storage.sync.get(["user_name"]).then((result) => {
            const user_name = result["user_name"];
            const body = document.getElementsByTagName('body')[0];
            const new_span = document.createElement('span');
            new_span.innerHTML = 'Hello ' + user_name + '!';
            body.append(new_span);
        });
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 4)

        # Awaiting Promise instead:
        code = """
        let result = await chrome.storage.local.get(["user_name"]);
        const user_name = result["user_name"];
        const body = document.getElementsByTagName('body')[0];
        const new_span = document.createElement('span');
        new_span.innerHTML = 'Hello ' + user_name + '!';
        body.append(new_span);
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 4)

        # Old-school callback:
        code = """
        chrome.storage.local.get(["user_name"], function (result) {
            const user_name = result["user_name"];
            const body = document.getElementsByTagName('body')[0];
            const new_span = document.createElement('span');
            new_span.innerHTML = 'Hello ' + user_name + '!';
            body.append(new_span);
        });
        """
        self.assertEqual(len(analyze_cs_42_32(code)), 4)

    def test_detect_43_31_vuln_in_bp(self):
        # ToDo: test whether the code snippets below actually work !!!!! (esp. the addEventListener ones)

        # Assignment to onsuccess | ArrowFunctionExpressions | chrome.runtime.onMessage:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    sendResponse(event.target.result.pw);
                };
            };
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

        # addEventListener("success", ...) | ArrowFunctionExpressions | chrome.runtime.onMessage:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.addEventListener("success", (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").addEventListener("success", (event) => {
                    sendResponse(event.target.result.pw);
                });
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

        # Assignment to onsuccess | FunctionExpressions | chrome.runtime.onMessage:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = function (event) {
                    sendResponse(event.target.result.pw);
                };
            };
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

        # addEventListener("success", ...) | FunctionExpressions | chrome.runtime.onMessage:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            const openReq = indexedDB.open("account_db", 2);
            openReq.addEventListener("success", function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").addEventListener("success", function (event) {
                    sendResponse(event.target.result.pw);
                });
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

        # Assignment to onsuccess | FunctionExpressions | chrome.runtime.onConnect:
        code = """
        chrome.runtime.onConnect.addListener(function (port) {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = function (event) {
                    port.postMessage(event.target.result.pw);
                };
            };
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

        # addEventListener("success", ...) | FunctionExpressions | chrome.runtime.onConnect:
        code = """
        chrome.runtime.onConnect.addListener(function (port) {
            const openReq = indexedDB.open("account_db", 2);
            openReq.addEventListener("success", function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").addEventListener("success", function (event) {
                    port.postMessage(event.target.result.pw);
                });
            });
        });
        """
        self.assertEqual(len(analyze_bp_43_31(code)), 1)

    def test_detect_43_32_vuln_in_bp(self):
        # ToDo: test whether the code snippets below actually work !!!!! (esp. the addEventListener ones)

        # Assignment to onsuccess | ArrowFunctionExpressions | storage.local:
        code = """
        chrome.action.onClicked.addListener(() => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    chrome.storage.local.set({ "pw": event.target.result.pw })
                        .then(() => {});
                };
            };
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_32(code)), 1)

        # addEventListener("success", ...) | ArrowFunctionExpressions | storage.local:
        code = """
        chrome.action.onClicked.addListener(() => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.addEventListener("success", (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").addEventListener("success", (event) => {
                    chrome.storage.local.set({ "pw": event.target.result.pw })
                        .then(() => {});
                });
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_32(code)), 1)

        # Assignment to onsuccess | FunctionExpressions | storage.sync:
        code = """
        chrome.action.onClicked.addListener(function () {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = function (event) {
                    chrome.storage.sync.set({ "pw": event.target.result.pw })
                        .then(() => {});
                };
            };
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_32(code)), 1)

        # addEventListener("success", ...) | FunctionExpressions | storage.sync:
        code = """
        chrome.action.onClicked.addListener(function () {
            const openReq = indexedDB.open("account_db", 2);
            openReq.addEventListener("success", function (event) {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").addEventListener("success", function (event) {
                    chrome.storage.sync.set({ "pw": event.target.result.pw })
                        .then(() => {});
                });
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_43_32(code)), 1)

    def test_get_extension_storage_accesses(self):
        # string[]:
        code = """
        chrome.storage.local.get(["password"]).then((result) => {
            // ... 
        });
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            ["get"],
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,  # irrelevant for testing, only used for more informative benchmark information
                benchmarks=dict(),
                storage_areas="local",
                access_methods="get"
            )["local"]["password"]["access_methods"]
        )
        self.assertEqual(
            ["get"],
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local|sync",
                access_methods="get|set"
            )["local"]["password"]["access_methods"]
        )
        self.assertEqual(
            {},
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="sync",
                access_methods="get"
            )
        )
        self.assertEqual(
            {},
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local",
                access_methods="set"
            )
        )

        # string:
        code = """
        chrome.storage.local.get("password").then((result) => {
            // ... 
        });
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            ["get"],
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local",
                access_methods="get"
            )["local"]["password"]["access_methods"]
        )

        # object:
        code = """
        chrome.storage.local.get({password: "123456"}).then((result) => {
            // ... 
        });
        """
        pdg = get_and_extend_pdg(code)
        result = get_extension_storage_accesses(
            pdg=pdg,
            is_cs=False,
            benchmarks=dict(),
            storage_areas="local",
            access_methods="get"
        )
        self.assertEqual(
            ["get"],
            result["local"]["password"]["access_methods"]
        )
        self.assertEqual(
            ["123456"],
            result["local"]["password"]["values"]
        )

        # set():
        code = """
        chrome.storage.local.set({ "pw": "correct-battery-horse-staple" }).then(() => {});
        """
        pdg = get_and_extend_pdg(code)
        result = get_extension_storage_accesses(
            pdg=pdg,
            is_cs=False,
            benchmarks=dict(),
            storage_areas="local",
            access_methods="set"
        )
        self.assertEqual(
            ["set"],
            result["local"]["pw"]["access_methods"]
        )
        self.assertEqual(
            ["correct-battery-horse-staple"],
            result["local"]["pw"]["values"]
        )

        # Self-written example 4.3/3.2 vulnerability (BP code):
        code = """
        chrome.action.onClicked.addListener(() => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    chrome.storage.local.set({ "pw": event.target.result.pw })
                        .then(() => {});
                };
            };
            return true;
        });
        // Note that this is a pretty technical example (sensitive data first being stored safely and then copied
        // to an unsafe location, the extension storage). In practice, an extension would probably simply use the
        // extension storage as the main storage for its sensitive data, something wed have to check manually.
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            ["set"],
            get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local",
                access_methods="set"
            )["local"]["pw"]["access_methods"]
        )

        # ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** *****
        # ***** ***** ***** ***** ***** More complex examples: ***** ***** ***** ***** *****
        # ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** *****

        # Array containing reference to a constant;
        #   inspired by "Avira Password Manager", v2.18.5.3877 (ID: caljgklbbfbcjjanaijlacgncafpegll), background.js:
        code = """
        const b = "secret";
        e.chrome.storage.local.get([b], function(e) {
            var r = e[b];
            t(r || 0)
        })
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            {"secret"},
            set(get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local|sync|managed",  # we ignore "session" in BPs as it's inaccessible to CS by default
                access_methods="get|set|getBytesInUse|remove"
            )["local"].keys())
        )

        # set() using a reference to a dictionary:
        code = """
        const d = { "pw": "correct-battery-horse-staple" };
        chrome.storage.local.set(d).then(() => {});
        """
        pdg = get_and_extend_pdg(code)
        result = get_extension_storage_accesses(
            pdg=pdg,
            is_cs=False,
            benchmarks=dict(),
            storage_areas="local",
            access_methods="set"
        )
        self.assertEqual(
            ["set"],
            result["local"]["pw"]["access_methods"]
        )
        self.assertEqual(
            ["correct-battery-horse-staple"],
            result["local"]["pw"]["values"]
        )

        # ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** *****
        # ***** ***** ***** ***** ***** Real-world-examples: ***** ***** ***** ***** *****
        # ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** ***** *****

        # "Ghostery  Privacy Ad Blocker", v8.6.3 (ID: mlomiejdfkolichcflejclcbmpeaniij), background.js:

        # #1 (shortened block statement, replaced original "login_info" with "login_info1" through "login_info2"):
        code = """
        new Promise(e => {
            d.a.addAccountEvent("migrate", "migrate start");
            chrome.storage.local.get("login_info1", t => {
                void chrome.storage.local.remove("login_info2", () => e());
                void chrome.storage.local.remove("login_info3", () => e());
                chrome.storage.local.remove("login_info4", () => e())
            })
        })
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            {"login_info1", "login_info2", "login_info3", "login_info4"},
            set(get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local|sync|managed",  # we ignore "session" in BPs as it's inaccessible to CS by default
                access_methods="get|set|getBytesInUse|remove"
            )["local"].keys())
        )

        # #2 (list of strings shortened):
        code = """
        g.a.JUST_UPGRADED && await
        function() {
            const e = ["storedOffers", "hpn:localTemporalUniq", "ghostery_facebook_data", "allow_unblock_data"];
            return Ve("Purging obsolete keys"), new Promise((t, n) => {
                chrome.storage.local.remove(e, () => {
                    chrome.runtime.lastError ? n(chrome.runtime.lastError) : t()
                })
            }).catch(e => {
                Je("Unable to clean up old keys.", e)
            })
        }()
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            {"storedOffers", "hpn:localTemporalUniq", "ghostery_facebook_data", "allow_unblock_data"},
            set(get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local|sync|managed",  # we ignore "session" in BPs as it's inaccessible to CS by default
                access_methods="get|set|getBytesInUse|remove"
            )["local"].keys())
        )

        # "Sollet", v.0.3.1 (ID: fhmfendgdocmcbmfikdcogofphimnkno), background.js:
        code = """
        function handleConnect(message, sender, sendResponse) {
            chrome.storage.local.get('connectedWallets', (result) => {
                const connectedWallet = (result.connectedWallets || {})[sender.origin];
                if (!connectedWallet) {
                    launchPopup(message, sender, sendResponse);
                } else {
                    sendResponse({
                        method: 'connected',
                        params: {
                            publicKey: connectedWallet.publicKey,
                            autoApprove: connectedWallet.autoApprove,
                        },
                        id: message.data.id,
                    });
                }
            });
        }
        
        function handleDisconnect(message, sender, sendResponse) {
            chrome.storage.local.get('connectedWallets', (result) => {
                delete result.connectedWallets[sender.origin];
                chrome.storage.local.set({
                        connectedWallets: result.connectedWallets
                    },
                    () => sendResponse({
                        method: 'disconnected',
                        id: message.data.id
                    }),
                );
            });
        }
        """
        pdg = get_and_extend_pdg(code)
        self.assertEqual(
            {"connectedWallets"},
            set(get_extension_storage_accesses(
                pdg=pdg,
                is_cs=False,
                benchmarks=dict(),
                storage_areas="local|sync|managed",  # we ignore "session" in BPs as it's inaccessible to CS by default
                access_methods="get|set|getBytesInUse|remove"
            )["local"].keys())
        )


if __name__ == '__main__':
    unittest.main()
