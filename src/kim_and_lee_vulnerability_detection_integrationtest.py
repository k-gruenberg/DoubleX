import os
import tempfile
import unittest

from src import get_pdg
from src.kim_and_lee_vulnerability_detection import (detect_41_31_vuln_in_bp, detect_31_vuln_in_bp,
                                                     add_missing_data_flow_edges)

os.environ['PARSER'] = "espree"
os.environ['SOURCE_TYPE'] = "module"
os.environ['RETURN_MULTIPLE_FLOW_VARIANTS'] = "yes"
#os.environ['PRINT_PDGS'] = "yes"


def get_and_extend_pdg(code):
    tmp_file = tempfile.NamedTemporaryFile()
    with open(tmp_file.name, 'w') as f:
        f.write(code)

    # WARNING: Do NOT put the below code into the "with" block, it won't work!!!
    res_dict = dict()
    benchmarks = res_dict['benchmarks'] = dict()
    pdg = get_pdg.get_pdg(file_path=tmp_file.name, res_dict=benchmarks)
    no_added_df_edges_cs = add_missing_data_flow_edges(pdg)
    print(f"{no_added_df_edges_cs} missing data flows edges added to PDG")
    return pdg


def analyze_bp_41_31(code, uxss):  # tests detect_41_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_41_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={}, uxss=uxss)
    print(f"len(results) = {len(results)}")
    return results


def analyze_bp_31(code):  # tests detect_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={})
    print(f"len(results) = {len(results)}")
    return results


class KimAndLeeVulnDetectionIntegrationTests(unittest.TestCase):
    # ToDo: chrome.cookies.get() test cases
    # ToDo: chrome.cookies gets aliased test cases
    # ToDo: .onConnect test cases!!!

    def test_detect_41_31_vuln_in_bp_no_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### With data flow through intermediary variables: #####

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    sendResponse(cookies5);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (foo()) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls (1 unreachable), no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (1==1) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5); // unreachable sink call
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = cookies[0]; // or: JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow continues beyond variable used in sink):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    let cookies4 = cookies3;
                    sendResponse(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [first_cookie, second_cookie] = [cookies[0], cookies[1]]; // Destructuring Assignment
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [cookies2, forty_two] = [cookies, 42]; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {a:cookies, b:42}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {b:42, a:cookies}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          sink(!) flows through intermediary variable):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            var sendResponseAlias = sendResponse;
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    sendResponseAlias(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
        # ##### ##### ##### Examples with sender verification: ##### ##### #####
        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == 'https://admin.com') {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check in unusual order:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if ("https://admin.com" == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check using triple-equals ("==="):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url === "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into two intermediary variables first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through 2 intermediary
        #     variables:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into (just) one intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through just 1 intermediary
        #     variable:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == tab_url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && foobar()) {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" & foobar()) { // & instead of &&
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial conjunction (x && x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && url == "https://admin.com") {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || foobar()) {
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | foobar()) { // | instead of ||
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin2.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | url == "https://admin2.com") { // | instead of ||
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial disjunction (x || x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first;
        #     we consider all HTTP URLs to be unsafe as a renderer + network(!) attacker can still exploit the
        #     vulnerability:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "http://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # .startsWith() tests:

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com/")) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("http://admin.com/")) { // considered unsafe only because of the "http"
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        # Test whether the --consider-http-as-safe argument has the effect of this vuln. not being reported anymore:
        os.environ['CONSIDER_HTTP_AS_SAFE'] = "yes"
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)
        del os.environ['CONSIDER_HTTP_AS_SAFE']

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com")) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test data flows through ObjectPatterns:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle ObjectPatterns as lambda arguments:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin, url, tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin, url: url, tab: tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin1, url: url1, tab: tab1}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ToDo: sender.tab.url verification w/o 2 separate variables, i.e., handle x.y.z member accesses!
        # ToDo: sender.origin verification
        # ToDo: sender verification w/o flow through intermediary variable
        # ToDo: check sender UN-safety and execute sensitive code in else block
        # ToDo: check sender UN-safety and return
        # ToDo: data flow through call to a separate function (!!!)

    def test_detect_31_vuln_in_bp(self):
        """
        Looking for violations of Security Violation 3.1 without any Execution of Privileged Browser APIs (4.1) however.
        """

        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                var o = {
                    category: "browser-extension",
                    event: "launch-meeting",
                    extVal: e
                };
                doi.send("Event", o, !0)
            }
        })
        """
        # (code from the Cisco WebEx Extension, version 1.17.0)
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)


if __name__ == '__main__':
    unittest.main()
