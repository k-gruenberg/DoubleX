import os
import tempfile
import unittest

from src import get_pdg
from src.kim_and_lee_vulnerability_detection import detect_41_31_vuln_in_bp, detect_31_vuln_in_bp
from add_missing_data_flow_edges import add_missing_data_flow_edges

os.environ['PARSER'] = "espree"
os.environ['SOURCE_TYPE'] = "module"
os.environ['RETURN_MULTIPLE_FLOW_VARIANTS'] = "yes"
os.environ['DEBUG'] = "yes"
#os.environ['PRINT_PDGS'] = "yes"


def get_and_extend_pdg(code):
    tmp_file = tempfile.NamedTemporaryFile()
    with open(tmp_file.name, 'w') as f:
        f.write(code)

    # WARNING: Do NOT put the below code into the "with" block, it won't work!!!
    res_dict = dict()
    benchmarks = res_dict['benchmarks'] = dict()
    pdg = get_pdg.get_pdg(file_path=tmp_file.name, res_dict=benchmarks)
    no_added_df_edges_cs = add_missing_data_flow_edges(pdg)
    print(f"{no_added_df_edges_cs} missing data flows edges added to PDG")
    return pdg


def analyze_bp_41_31(code, uxss):  # tests detect_41_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_41_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={}, uxss=uxss, debug_prints=True)
    print(f"len(results) = {len(results)}")
    return results


def analyze_bp_31(code):  # tests detect_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={})
    print(f"len(results) = {len(results)}")
    return results


class KimAndLeeVulnDetectionIntegrationTests(unittest.TestCase):
    # ToDo: chrome.cookies gets aliased test cases

    def test_detect_41_31_vuln_in_bp_no_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### With data flow through intermediary variables: #####

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    sendResponse(cookies5);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (foo()) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls (1 unreachable), no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (1==1) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5); // unreachable sink call
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = cookies[0]; // or: JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow continues beyond variable used in sink):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    let cookies4 = cookies3;
                    sendResponse(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [first_cookie, second_cookie] = [cookies[0], cookies[1]]; // Destructuring Assignment
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [cookies2, forty_two] = [cookies, 42]; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {a:cookies, b:42}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {b:42, a:cookies}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          sink(!) flows through intermediary variable):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            var sendResponseAlias = sendResponse;
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    sendResponseAlias(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
        # ##### ##### ##### Examples with sender verification: ##### ##### #####
        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == 'https://admin.com') {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check in unusual order:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if ("https://admin.com" == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check using triple-equals ("==="):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url === "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into two intermediary variables first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through 2 intermediary
        #     variables:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into (just) one intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through just 1 intermediary
        #     variable:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == tab_url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && foobar()) {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" & foobar()) { // & instead of &&
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial conjunction (x && x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && url == "https://admin.com") {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || foobar()) {
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | foobar()) { // | instead of ||
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin2.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | url == "https://admin2.com") { // | instead of ||
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial disjunction (x || x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first;
        #     we consider all HTTP URLs to be unsafe as a renderer + network(!) attacker can still exploit the
        #     vulnerability:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "http://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # .startsWith() tests:

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com/")) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("http://admin.com/")) { // considered unsafe only because of the "http"
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        # Test whether the --consider-http-as-safe argument has the effect of this vuln. not being reported anymore:
        os.environ['CONSIDER_HTTP_AS_SAFE'] = "yes"
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)
        del os.environ['CONSIDER_HTTP_AS_SAFE']

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com")) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test data flows through ObjectPatterns:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle ObjectPatterns as lambda arguments:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin, url, tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin, url: url, tab: tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin1, url: url1, tab: tab1}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with chrome.cookies.get(): ##### ##### #####

        # Basic example (chrome.cookies.get, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, (cookie) => {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.get, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie && url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie || url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with fetch(): ##### ##### #####

        # Basic example (fetch, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => sendResponse(response))
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (fetch, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example.com/")
                .then(function (response) { sendResponse(response); })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example, sink in 2nd then() call:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => response.json())
                .then(response => sendResponse(response));
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example, sender safely authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url == "https://www.example.com/") {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example, sender not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url.startsWith("https://www.example.com")) {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example with await instead of .then(), correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com/")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example with await instead of .then(), not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Handle function references: ##### ##### #####

        code = """
        function msg_handler(msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        }
        
        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ToDo: the test below will only work once I've added missing data flow edges from function parameters with
        #       default values...
        # code = """
        # function msg_handler(msg, sender, sendResponse=null) {
        #     chrome.cookies.getAll({},
        #         function(cookies) {
        #             sendResponse(cookies);
        #         }
        #     );
        #     return true;
        # }
        #
        # chrome.runtime.onMessage.addListener(msg_handler);
        # """
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test nested functions (!!!):
        code = """
        function msg_handler(msg, sender, sendResponse) {
            function cookies_handler(cookies) {
                sendResponse(cookies);
            }
        
            chrome.cookies.getAll({}, cookies_handler);
            return true;
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function msg_handler(msg, sender, sendResponse) {
            let url = sender.url;
            if (url == "https://admin.com") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        sendResponse(cookies);
                    }
                );
                return true;
            } else {
                sendResponse("authentication failed");
            }
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Data flow through separate function: ##### ##### #####

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }
        
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            getCookies(sendResponse);
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            if (url == "https://admin.com") {
                getCookies(sendResponse);
                return true;
            }
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Handle Promises instead of callbacks: ##### ##### #####

        # Direct call of chrome.cookies.getAll({}).then(...):
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          chrome.cookies.getAll({}).then( // => use Promise instead of callback
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          let promise = chrome.cookies.getAll({});
          promise.then(
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );
        
          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable,
        #   .then() call references function instead of being supplied an anonymous function directly:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          function cookies_handler(cookies) {
            sendResponse(cookies);
          }
          
          let promise = chrome.cookies.getAll({});
          promise.then(cookies_handler);

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is awaited inside an async code block:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          (async () => {
            let cookies = await chrome.cookies.getAll({});
            //console.log(cookies);
            sendResponse(cookies);
          })();
        
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### Handle chrome.runtime.onConnect.addListener() instead of chrome.runtime.onMessage.addListener(): #####

        # Non-vulnerable:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            port.postMessage("no sensitive data exfiltration here");
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Vulnerable (cookie exfiltration):
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.getAll({},
                function(cookies) {
                    port.postMessage(cookies);
                }
            );
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Swap ArrowFunctionExpression and FunctionExpression:
        code = """
        chrome.runtime.onConnect.addListener(function (port) {
            chrome.cookies.getAll({},
                (cookies) => {
                    port.postMessage(cookies);
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # chrome.cookies.get() instead of chrome.cookies.getAll():
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function(cookie) {
                port.postMessage(cookie);
            });
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # With correct sender authentication:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let port_sender = port.sender;
            let sender_url = port_sender.url;
            if (sender_url == "https://www.google.com/") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # With incorrect sender authentication:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let sender = port.sender;
            let sender_url = sender.url;
            if (sender_url == "https://www.google.com/" || foo()) {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ToDo: sender.origin verification
        # ToDo: sender verification w/o flow through intermediary variable
        # ToDo: check sender UN-safety and execute sensitive code in else block
        # ToDo: check sender UN-safety and return

    def test_detect_31_vuln_in_bp(self):
        """
        Looking for violations of Security Violation 3.1 without any Execution of Privileged Browser APIs (4.1) however.
        """

        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                var o = {
                    category: "browser-extension",
                    event: "launch-meeting",
                    extVal: e
                };
                doi.send("Event", o, !0)
            }
        })
        """
        # (code from the Cisco WebEx Extension, version 1.17.0)
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)


if __name__ == '__main__':
    unittest.main()
