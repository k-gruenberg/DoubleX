import os
import tempfile
import unittest

import get_pdg
from kim_and_lee_vulnerability_detection import (detect_41_31_vuln_in_bp_no_uxss,
                                                     detect_41_31_vuln_in_bp_uxss,
                                                     detect_31_vuln_in_bp)
from add_missing_data_flow_edges import add_missing_data_flow_edges
from remove_incorrect_data_flow_edges import remove_incorrect_data_flow_edges

os.environ['PARSER'] = "espree"
os.environ['SOURCE_TYPE'] = "module"
os.environ['RETURN_MULTIPLE_FLOW_VARIANTS'] = "yes"
os.environ['DEBUG'] = "yes"
#os.environ['PRINT_PDGS'] = "yes"


def get_and_extend_pdg(code: str):
    tmp_file = tempfile.NamedTemporaryFile()
    with open(tmp_file.name, 'w') as f:
        f.write(code)

    # WARNING: Do NOT put the below code into the "with" block, it won't work!!!
    res_dict = dict()
    benchmarks = res_dict['benchmarks'] = dict()
    pdg = get_pdg.get_pdg(file_path=tmp_file.name, res_dict=benchmarks)
    no_removed_df_edges = remove_incorrect_data_flow_edges(pdg)
    print(f"{no_removed_df_edges} incorrect data flows edges removed from PDG")
    no_added_df_edges = add_missing_data_flow_edges(pdg)
    print(f"{no_added_df_edges} missing data flows edges added to PDG")
    return pdg


def analyze_bp_41_31(code: str, uxss: bool) -> list:
    """
    tests detect_41_31_vuln_in_bp_no_uxss() or detect_41_31_vuln_in_bp_uxss()
    """
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    if uxss:
        detect_41_31_vuln_in_bp_uxss(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    else:
        detect_41_31_vuln_in_bp_no_uxss(pdg_bp=pdg_bp, results=results, benchmarks={}, debug_prints=True)
    print(f"len(results) = {len(results)}")
    for i in range(len(results)):
        print(f"results[{i}] = {results[i]}")
    return results


def analyze_bp_31(code: str) -> list:  # tests detect_31_vuln_in_bp()
    pdg_bp = get_and_extend_pdg(code)
    results = []  # bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    detect_31_vuln_in_bp(pdg_bp=pdg_bp, results=results, benchmarks={})
    print(f"len(results) = {len(results)}")
    return results


class KimAndLeeVulnDetectionIntegrationTests(unittest.TestCase):
    # ToDo: chrome.cookies gets aliased test cases

    def test_detect_41_31_vuln_in_bp_no_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call (inside an if),
        #   no sender check whatsoever, cookie data flow continues *beyond* the sink call as well):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (foo()) {
                        sendResponse(cookies);
                    }
                    let cookies2 = cookies;
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (sink call) (A):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (sink call) (B):
        code = """
        chrome.runtime.onMessage.addListener(function foo (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # FunctionExpressions can, perhaps a bit un-intuitively, be named as well (no sink call):
        code = """
        chrome.runtime.onMessage.addListener(function foo(msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function bar(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ToDo: the test below will only work once I've added missing data flow edges from function parameters with
        #       default values...
        # # ArrowFunctionExpressions with parameter default values:
        # code = """
        # chrome.runtime.onMessage.addListener((msg=null, sender=null, sendResponse=null) => {
        #     chrome.cookies.getAll({},
        #         (cookies=null) => {
        #             sendResponse(cookies);
        #         }
        #     );
        #     return true;
        # });
        # """
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        #
        # # FunctionExpressions with parameter default values:
        # code = """
        # chrome.runtime.onMessage.addListener(function (msg=null, sender=null, sendResponse=null) {
        #     chrome.cookies.getAll({},
        #         function(cookies=null) {
        #             sendResponse(cookies);
        #         }
        #     );
        #     return true;
        # });
        # """
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        #
        # # FunctionExpressions with names *and* parameter default values:
        # code = """
        # chrome.runtime.onMessage.addListener(function foo(msg=null, sender=null, sendResponse=null) {
        #     chrome.cookies.getAll({},
        #         function bar(cookies=null) {
        #             sendResponse(cookies);
        #         }
        #     );
        #     return true;
        # });
        # """
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 3 args, no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 2 args => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, ArrowFunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Basic example (chrome.cookies.getAll, FunctionExpression with 1 arg => no sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg) {
            chrome.cookies.getAll({},
                function(cookies) {
                    
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### With data flow through intermediary variables: #####

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    sendResponse(cookies5);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (foo()) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 2)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, 2 sink calls (1 unreachable), no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    var cookies3 = cookies2;
                    const cookies4 = cookies3;
                    cookies5 = cookies4;
                    if (1==1) {
                        sendResponse(cookies4);
                    } else {
                        sendResponse(cookies5); // unreachable sink call
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = cookies[0]; // or: JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let first_cookie = JSON.stringify(cookies[0]);
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow continues beyond variable used in sink):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    let cookies4 = cookies3;
                    sendResponse(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [first_cookie, second_cookie] = [cookies[0], cookies[1]]; // Destructuring Assignment
                    sendResponse(first_cookie);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    let [cookies2, forty_two] = [cookies, 42]; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {a:cookies, b:42}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          data flow through Destructuring Assignment):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    const { a: cookies2, b: forty_two } = {b:42, a:cookies}; // Destructuring Assignment
                    sendResponse(cookies2);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Example (chrome.cookies.getAll, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever,
        #          sink(!) flows through intermediary variable):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            var sendResponseAlias = sendResponse;
            chrome.cookies.getAll({},
                function(cookies) {
                    let cookies2 = cookies;
                    let cookies3 = cookies2;
                    sendResponseAlias(cookies3);
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####
        # ##### ##### ##### Examples with sender verification: ##### ##### #####
        # ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### ##### #####

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == 'https://admin.com') {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check in unusual order:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if ("https://admin.com" == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #     equality check using triple-equals ("==="):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url === "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into two intermediary variables first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through 2 intermediary
        #     variables:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab = sender.tab;
            let url = tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.tab.url which flows into (just) one intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # No/incorrect sender verification through "url == url" (which is always true), flow through just 1 intermediary
        #     variable:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let tab_url = sender.tab.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (tab_url == tab_url) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && foobar()) {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     conjunction ("&"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" & foobar()) { // & instead of &&
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial conjunction (x && x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" && url == "https://admin.com") {
                        sendResponse(cookies); // still guaranteed to execute only when URL is safe
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || foobar()) {
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | foobar()) { // | instead of ||
                        sendResponse(cookies); // may also execute when foobar() returns True, whenever that is... 
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("||"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin2.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     disjunction ("|"):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" | url == "https://admin2.com") { // | instead of ||
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first, use of
        #     trivial disjunction (x || x):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "https://admin.com" || url == "https://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first;
        #     we consider all HTTP URLs to be unsafe as a renderer + network(!) attacker can still exploit the
        #     vulnerability:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url == "http://admin.com") {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # .startsWith() tests:

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com/")) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Correct sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("http://admin.com/")) { // considered unsafe only because of the "http"
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)
        # Test whether the --consider-http-as-safe argument has the effect of this vuln. not being reported anymore:
        os.environ['CONSIDER_HTTP_AS_SAFE'] = "yes"
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)
        del os.environ['CONSIDER_HTTP_AS_SAFE']

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith("https://admin.com")) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first,
        #    prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test data flows through ObjectPatterns:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let {url} = sender; // equivalent to: let url = sender.url;
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle ObjectPatterns as lambda arguments:

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {url}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin, url, tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin, url, tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin, url: url, tab: tab}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin, url: url, tab: tab}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Handle a more complex ObjectPattern as lambda argument: {origin: origin1, url: url1, tab: tab1}

        # Correct sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com/')) {
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first (via an
        #    ObjectPattern), prefix check using .startsWith() instead of full equality check,
        #    use of ' instead of " quotation marks:
        code = """
        chrome.runtime.onMessage.addListener((msg, {origin: origin1, url: url1, tab: tab1}, sendResponse) => {
            chrome.cookies.getAll({},
                function(cookies) {
                    if (url1.startsWith('https://admin.com')) { // note how a single missing slash creates a vulnerability!
                        sendResponse(cookies);
                    }
                }
            );
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with chrome.cookies.get(): ##### ##### #####

        # Basic example (chrome.cookies.get, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, (cookie) => {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (chrome.cookies.get, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie) {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Correct sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie && url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Incorrect sender verification through sender.url which flows into an intermediary variable first:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function (cookie) {
                if (cookie || url == "https://admin.com") {
                    sendResponse(cookie);
                } else {
                    console.log("Cookie not found.");
                }
            });
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Examples with fetch(): ##### ##### #####

        # Basic example (fetch, ArrowFunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => sendResponse(response))
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Basic example (fetch, FunctionExpression with 3 args, sink call, no sender check whatsoever):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example.com/")
                .then(function (response) { sendResponse(response); })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example, sink in 2nd then() call:
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            fetch("https://www.example.com/")
                .then(response => response.json())
                .then(response => sendResponse(response));
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example, sender safely authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url == "https://www.example.com/") {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example, sender not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            fetch("https://www.example2.com/")
                .then(function (response) {
                    let url = sender.url;
                    if (url.startsWith("https://www.example.com")) {
                        sendResponse(response);
                    } else {
                        sendResponse("auth failed");
                    }
                })
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Fetch example with await instead of .then(), correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com/")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Fetch example with await instead of .then(), not correctly authenticated:
        code = """
        chrome.runtime.onMessage.addListener(async function (msg, sender, sendResponse) {
            const url = sender.url;
            const response = await fetch("https://www.example2.com/");
            if (response.status < 400 && url.startsWith("https://www.example.com")) {
                sendResponse(response);
            }
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### ##### ##### Handle function references: ##### ##### #####

        code = """
        function msg_handler(msg, sender, sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
            return true;
        }
        
        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ToDo: the test below will only work once I've added missing data flow edges from function parameters with
        #       default values...
        # code = """
        # function msg_handler(msg, sender, sendResponse=null) {
        #     chrome.cookies.getAll({},
        #         function(cookies) {
        #             sendResponse(cookies);
        #         }
        #     );
        #     return true;
        # }
        #
        # chrome.runtime.onMessage.addListener(msg_handler);
        # """
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Test nested functions (!!!):
        code = """
        function msg_handler(msg, sender, sendResponse) {
            function cookies_handler(cookies) {
                sendResponse(cookies);
            }
        
            chrome.cookies.getAll({}, cookies_handler);
            return true;
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function msg_handler(msg, sender, sendResponse) {
            let url = sender.url;
            if (url == "https://admin.com") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        sendResponse(cookies);
                    }
                );
                return true;
            } else {
                sendResponse("authentication failed");
            }
        }

        chrome.runtime.onMessage.addListener(msg_handler);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Data flow through separate function: ##### ##### #####

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }
        
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            getCookies(sendResponse);
            return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        code = """
        function getCookies(sendResponse) {
            chrome.cookies.getAll({},
                function(cookies) {
                    sendResponse(cookies);
                }
            );
        }

        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            let url = sender.url;
            if (url == "https://admin.com") {
                getCookies(sendResponse);
                return true;
            }
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # ##### ##### ##### Handle Promises instead of callbacks: ##### ##### #####

        # Direct call of chrome.cookies.getAll({}).then(...):
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          chrome.cookies.getAll({}).then( // => use Promise instead of callback
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          let promise = chrome.cookies.getAll({});
          promise.then(
            (cookies) => {
              //console.log(cookies);
              sendResponse(cookies);
            }
          );
        
          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is put into variable, then call of .then() on that variable,
        #   .then() call references function instead of being supplied an anonymous function directly:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          function cookies_handler(cookies) {
            sendResponse(cookies);
          }
          
          let promise = chrome.cookies.getAll({});
          promise.then(cookies_handler);

          // Return true to indicate that we will respond asynchronously!
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Promise returned by chrome.cookies.getAll({}) is awaited inside an async code block:
        code = """
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
          (async () => {
            let cookies = await chrome.cookies.getAll({});
            //console.log(cookies);
            sendResponse(cookies);
          })();
        
          return true;
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ##### Handle chrome.runtime.onConnect.addListener() instead of chrome.runtime.onMessage.addListener(): #####

        # Non-vulnerable:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            port.postMessage("no sensitive data exfiltration here");
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # Vulnerable (cookie exfiltration):
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.getAll({},
                function(cookies) {
                    port.postMessage(cookies);
                }
            );
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # Swap ArrowFunctionExpression and FunctionExpression:
        code = """
        chrome.runtime.onConnect.addListener(function (port) {
            chrome.cookies.getAll({},
                (cookies) => {
                    port.postMessage(cookies);
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # chrome.cookies.get() instead of chrome.cookies.getAll():
        code = """
        chrome.runtime.onConnect.addListener((port => {
            chrome.cookies.get({
                url: "https://www.google.com/",
                name: "AEC",
            }, function(cookie) {
                port.postMessage(cookie);
            });
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # With correct sender authentication:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let port_sender = port.sender;
            let sender_url = port_sender.url;
            if (sender_url == "https://www.google.com/") {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 0)

        # With incorrect sender authentication:
        code = """
        chrome.runtime.onConnect.addListener((port => {
            let sender = port.sender;
            let sender_url = sender.url;
            if (sender_url == "https://www.google.com/" || foo()) {
                chrome.cookies.getAll({},
                    function(cookies) {
                        port.postMessage(cookies);
                    }
                );
            }
        }));
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=False)), 1)

        # ToDo: sender.origin verification
        # ToDo: sender verification w/o flow through intermediary variable
        # ToDo: check sender UN-safety and execute sensitive code in else block
        # ToDo: check sender UN-safety and return

    def test_detect_41_31_vuln_in_bp_uxss(self):
        code = """
        some(harmless, code);
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 0)

        # ##### ##### ##### Examples without sender verification: ##### ##### #####

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)
        # Note that, because of RETURN_MULTIPLE_FLOW_VARIANTS == "yes", there are actually two flows found:
        #   (1) source: msg => uname => new_span
        #       sink:   document => body
        #   (2) source: msg => uname => new_span
        #       sink:   document => new_span

        # Basic example (chrome.scripting.executeScript, FunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener(function (msg, sender, sendResponse) {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach(function (tab) {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Basic example (chrome.scripting.executeScript, named FunctionExpression with 3 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener(function foo(msg, sender, sendResponse) {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach(function bar(tab) {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 2 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 1 arg):
        code = """
        chrome.runtime.onMessage.addListener((msg) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 0 args):
        code = """
        chrome.runtime.onMessage.addListener(() => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: ["user_name"]
                        });
                    });
                }
            );
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 0)

        # Basic example (chrome.scripting.executeScript, ArrowFunctionExpression with 4 args, no sender check at all):
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse, foobar) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                const body = document.getElementsByTagName('body')[0];
                                const new_span = document.createElement('span');
                                new_span.innerHTML = 'Hello ' + uname + '!';
                                body.append(new_span);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 2)

        # Data flows into the DOM not via body.append() but rather via document.write():
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse, foobar) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname) => {
                                document.write(uname);
                            },
                            args: [msg["user_name"]]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # Data flow into existing instead of new DOM element; data flows end not in a CallExpression but rather in an
        #   AssignmentExpression; redundant argument "x" passed to "args":
        code = """
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            chrome.tabs.query({},
                (tabs) => {
                    tabs.forEach((tab) => {
                        chrome.scripting.executeScript({
                            target: { tabId: tab.id },
                            func: (uname, y, z) => {
                                const existing_span = document.getElementById('existing_span');
                                existing_span.innerHTML = 'Hello ' + uname + '!';
                            },
                            args: [msg["user_name"], x]
                        });
                    });
                }
            );
            sendResponse("ok");
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # A simplified example using the (deprecated!) chrome.tabs.executeScript() API instead of the
        #   chrome.scripting.executeScript() API:
        code = """
        chrome.runtime.onMessage.addListener(function(t, n, e) {
            chrome.tabs.executeScript(n, {
                code: t
            });
        });
        """
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

        # An (almost) real-world example using the (deprecated!) chrome.tabs.executeScript() API instead of the
        #   chrome.scripting.executeScript() API; also tests multiple complex types of data flows:
        #   * from `t` to `r` in `t.data.data.forEach(function(r) { ... })`
        #   * IIFEs (Immediately Invoked Function Expressions)
        code = r"""
        chrome.runtime.onMessage.addListener((function(t, n, e) {
                var o, c, u, s = n.tab.windowId,
                    l = n.tab.id;
                "initiate-sso-tasks" == t.type ? function(t, n, e) {
                    f.apply(this, arguments)
                }(l, t.data, n.frameId) : "initiate-sso" == t.type ? (o = t.data, c = l, u = !1, chrome.tabs.onUpdated.addListener((function t2(n, e, r) {
                    n === c && (e.url && (u = !0), "complete" === e.status && u && (chrome.tabs.onUpdated.removeListener(t2), chrome.tabs.sendMessage(n, {
                        type: "handle-sso",
                        data: o
                    }, (function() {}))))
                }))) : "initiate-autolaunch" == t.type ? function(t, n, e) {
                    a && t.data.data && t.data.data.length > 0 && t.data.data.forEach((function(r) {
                        ! function(t, n, e, r) {
                            var i = e.data.IdConfigBaseUrl,
                                o = r.id,
                                c = r.type,
                                u = r.url ? r.url : [];
                            u && 0 == u.length && (u[0] = "");
                            var a = {
                                app_id: o,
                                windowId: t,
                                tabId: n,
                                gwstoken: e.data.gwstoken,
                                LaunchpadUri: i.replace(/^https?:\/\//, "")
                            };
                            switch (c) {
                                case 1:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 7:
                                case 8:
                                    d(n, o);
                                    break;
                                case 9:
                                    g(i + "/clsso/" + encodeURIComponent(o), a);
                                    break;
                                case 14:
                                    g(u[0], a);
                                    break;
                                case 15:
                                    g(i + "/browsersso/" + encodeURIComponent(o), a);
                                    break;
                                case 16:
                                case 36:
                                    g(i + "/ltisso/" + o, a);
                                    break;
                                case 17:
                                    g(i + "/focussso/" + o, a);
                                    break;
                                case 18:
                                    g(i + "/pearson/mathxl/" + o, a);
                                    break;
                                case 19:
                                    g(i + "/pearson/mymathlab/" + o, a);
                                    break;
                                case 20:
                                    g(i + "/custom/certification/" + o, a);
                                    break;
                                case 21:
                                    g(i + "/oneroster/" + o, a);
                                    break;
                                case 22:
                                    g(i + "/phonebook/" + o, a);
                                    break;
                                case 23:
                                    g(i + "/onerosterlti/" + o, a);
                                    break;
                                case 24:
                                    g(i + "/assignapplication/" + o, a);
                                    break;
                                case 25:
                                case 26:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 3:
                                case 27:
                                    var s = u[0],
                                        f = "var s = document.createElement('script');";
                                    f += " s.textContent = \"(function() { var interval = setInterval(function() { if(window.CloudApp && window.CloudApp.MyApps) { window.CloudApp.MyApps.Controller.launchLocalApp('" + s + "'); clearInterval(interval); } }, 700); })();\";", f += " document.head.appendChild(s);", chrome.tabs.executeScript(n, {
                                        code: f
                                    });
                                    break;
                                case 28:
                                    g(i + "/custom/genericoneroster/ltilaunch/" + o, a);
                                    break;
                                case 29:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 30:
                                case 31:
                                case 32:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 33:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 34:
                                    g(i + "/custom/naviancestudentsso/" + o, a);
                                    break;
                                case 35:
                                    g(i + "/oneroster/manage/class/" + o, a);
                                    break;
                                case 37:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a)
                            }
                        }(n, e, t, r)
                    }))
                }(t, s, l) : "initiate-apptimer" == t.type ? r = {
                    app_id: t.data.app_id,
                    windowId: s,
                    tabId: l,
                    gwstoken: t.data.gwstoken,
                    LaunchpadUri: t.data.LaunchpadUri
                } : "initiate-ssosignout" == t.type ? t.data && t.data.length > 0 && t.data.forEach((function(t) {
                    chrome.tabs.create({
                        url: t,
                        active: !1
                    })
                })) : "stopapptimers" == t.type && (Object.keys(i.CLAnalytics.clOpenTabs).forEach((function(t) {
                    clearInterval(i.CLAnalytics.clOpenTabs[t].interval), i.CLAnalytics.clOpenTabs[t].interval = null, delete i.CLAnalytics.clOpenTabs[t]
                })), a = !1)
            }))
        """
        # (code from "ClassLink OneClick Extension", version 10.6, extension ID jgfbgkjjlonelmpenhpfeeljjlcgnkpe,
        #  slightly changed)
        self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 4)

        # The same example again, but this time unaltered, exactly as it occurred in the real "ClassLink" extension:
        code = r"""
        chrome.runtime.onMessage.addListener((function(t, n, e) {
                var o, c, u, s = n.tab.windowId,
                    l = n.tab.id;
                "initiate-sso-tasks" == t.type ? function(t, n, e) {
                    f.apply(this, arguments)
                }(l, t.data, n.frameId) : "initiate-sso" == t.type ? (o = t.data, c = l, u = !1, chrome.tabs.onUpdated.addListener((function t(n, e, r) {
                    n === c && (e.url && (u = !0), "complete" === e.status && u && (chrome.tabs.onUpdated.removeListener(t), chrome.tabs.sendMessage(n, {
                        type: "handle-sso",
                        data: o
                    }, (function() {}))))
                }))) : "initiate-autolaunch" == t.type ? function(t, n, e) {
                    a && t.data.data && t.data.data.length > 0 && t.data.data.forEach((function(r) {
                        ! function(t, n, e, r) {
                            var i = e.data.IdConfigBaseUrl,
                                o = r.id,
                                c = r.type,
                                u = r.url ? r.url : [];
                            u && 0 == u.length && (u[0] = "");
                            var a = {
                                app_id: o,
                                windowId: t,
                                tabId: n,
                                gwstoken: e.data.gwstoken,
                                LaunchpadUri: i.replace(/^https?:\/\//, "")
                            };
                            switch (c) {
                                case 1:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 7:
                                case 8:
                                    d(n, o);
                                    break;
                                case 9:
                                    g(i + "/clsso/" + encodeURIComponent(o), a);
                                    break;
                                case 14:
                                    g(u[0], a);
                                    break;
                                case 15:
                                    g(i + "/browsersso/" + encodeURIComponent(o), a);
                                    break;
                                case 16:
                                case 36:
                                    g(i + "/ltisso/" + o, a);
                                    break;
                                case 17:
                                    g(i + "/focussso/" + o, a);
                                    break;
                                case 18:
                                    g(i + "/pearson/mathxl/" + o, a);
                                    break;
                                case 19:
                                    g(i + "/pearson/mymathlab/" + o, a);
                                    break;
                                case 20:
                                    g(i + "/custom/certification/" + o, a);
                                    break;
                                case 21:
                                    g(i + "/oneroster/" + o, a);
                                    break;
                                case 22:
                                    g(i + "/phonebook/" + o, a);
                                    break;
                                case 23:
                                    g(i + "/onerosterlti/" + o, a);
                                    break;
                                case 24:
                                    g(i + "/assignapplication/" + o, a);
                                    break;
                                case 25:
                                case 26:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 3:
                                case 27:
                                    var s = u[0],
                                        f = "var s = document.createElement('script');";
                                    f += " s.textContent = \"(function() { var interval = setInterval(function() { if(window.CloudApp && window.CloudApp.MyApps) { window.CloudApp.MyApps.Controller.launchLocalApp('" + s + "'); clearInterval(interval); } }, 700); })();\";", f += " document.head.appendChild(s);", chrome.tabs.executeScript(n, {
                                        code: f
                                    });
                                    break;
                                case 28:
                                    g(i + "/custom/genericoneroster/ltilaunch/" + o, a);
                                    break;
                                case 29:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 30:
                                case 31:
                                case 32:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a);
                                    break;
                                case 33:
                                    g(i + "/custom/pearsonapapp/" + o, a);
                                    break;
                                case 34:
                                    g(i + "/custom/naviancestudentsso/" + o, a);
                                    break;
                                case 35:
                                    g(i + "/oneroster/manage/class/" + o, a);
                                    break;
                                case 37:
                                    g(new RegExp(/^(http|https):\/\//).test(u[0]) ? u[0] : "http://" + u[0], a)
                            }
                        }(n, e, t, r)
                    }))
                }(t, s, l) : "initiate-apptimer" == t.type ? r = {
                    app_id: t.data.app_id,
                    windowId: s,
                    tabId: l,
                    gwstoken: t.data.gwstoken,
                    LaunchpadUri: t.data.LaunchpadUri
                } : "initiate-ssosignout" == t.type ? t.data && t.data.length > 0 && t.data.forEach((function(t) {
                    chrome.tabs.create({
                        url: t,
                        active: !1
                    })
                })) : "stopapptimers" == t.type && (Object.keys(i.CLAnalytics.clOpenTabs).forEach((function(t) {
                    clearInterval(i.CLAnalytics.clOpenTabs[t].interval), i.CLAnalytics.clOpenTabs[t].interval = null, delete i.CLAnalytics.clOpenTabs[t]
                })), a = !1)
            }))
        """
        # (code from "ClassLink OneClick Extension", version 10.6, extension ID jgfbgkjjlonelmpenhpfeeljjlcgnkpe,
        #  unaltered)
        # ToDo: the test below will only work once I've added missing data flow edges from function parameters......
        # self.assertEqual(len(analyze_bp_41_31(code, uxss=True)), 1)

    def test_detect_31_vuln_in_bp(self):
        """
        Looking for violations of Security Violation 3.1 without any Execution of Privileged Browser APIs (4.1) however.
        """

        code = """
        chrome.runtime.onMessage.addListener(function(e, n) {
            if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
                var o = {
                    category: "browser-extension",
                    event: "launch-meeting",
                    extVal: e
                };
                doi.send("Event", o, !0)
            }
        })
        """
        # (code from the Cisco WebEx Extension, version 1.17.0)
        analysis_result = analyze_bp_31(code)
        print(f"test_detect_31_vuln_in_bp(): analysis_result: {analysis_result}")
        self.assertEqual(len(analysis_result), 1)


if __name__ == '__main__':
    unittest.main()
