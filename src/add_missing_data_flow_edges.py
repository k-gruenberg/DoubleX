import os

import utility
from pdg_js.node import Node

PRINT_DEBUG = utility.PRINT_DEBUG

JAVASCRIPT_BUILT_IN_FUNCTIONS = [
    "eval", "isFinite", "isNaN", "parseFloat", "parseInt",
    "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent",
    "escape", "unescape",  # both deprecated!
    "Object", "Function", "Boolean", "Symbol",
    "Error", "AggregateError", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError",
    # Firefox-only: "InternalError",
    "Number", "BigInt", "Date",  # Math is not a function
    "String", "RegExp",
    "Array",  # "Int8Array", "Uint8Array", etc. may only occur in a NewExpression, not in a CallExpression!
    # calling Map(), Set(), WeakMap(), WeakSet() without "new" is forbidden, too!
    # same for ArrayBuffer(), DataView(),
    # same for WeakRef(), FinalizationRegistry(),
    # same for Iterator(), Promise(),
    # same for Proxy()
]
# => Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects


def add_missing_data_flow_edges(pdg: Node) -> int:
    """
    Sadly, in the PDGs generated by DoubleX, some data flow edges that we need are missing.
    This function adds those missing data flow edges to the given PDG, e.g. those from y to x in a "x=y" assignment
    expression (including those cases where the "y" on the RHS is part of a more complex expression: "x=foo(y)").

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    # ToDo: add dataflow edge from "x" to "x.y" ?
    # ToDo: handle flows like: "url = url.replace(...)"
    # ToDo: handle data flow of "x" inside "function foo(x=42) { console.log(x) }"
    #       or "fetch(url).then(([x,y]) => foo(x,y))", DoubleX seems to miss that!

    total_data_flow_edges_added = 0

    edges_added_declarations_and_assignments = add_missing_data_flow_edges_declarations_and_assignments(pdg)
    print(f"[Adding data flows] {edges_added_declarations_and_assignments} data flow edges added to declarations and "
          f"assignments.")
    total_data_flow_edges_added += edges_added_declarations_and_assignments

    edges_added_standard_library_functions = add_missing_data_flow_edges_standard_library_functions(pdg)
    print(f"[Adding data flows] {edges_added_standard_library_functions} edges added to standard library functions.")
    total_data_flow_edges_added += edges_added_standard_library_functions

    edges_added_call_expressions = add_missing_data_flow_edges_call_expressions(pdg)
    print(f"[Adding data flows] {edges_added_call_expressions} edges added to call expressions.")
    total_data_flow_edges_added += edges_added_call_expressions

    return total_data_flow_edges_added


def add_missing_data_flow_edges_declarations_and_assignments(pdg: Node) -> int:
    """
    Adds missing data flows from `y` to `x` in statements/expressions/declarations like:

    * let x=y;
    * var x=y;
    * const x=y;
    * x=y;
    * x.foo = y;
    * x[foo] = y;
    * x.foo.bar = y;
    * x[foo][bar] = y;
    * let [x, a] = [y, b];
    * const { a: x, b: foo } = {a: y, b: bar};
    * const { b: foo, a: x } = {a: y, b: bar};
    * ({x} = y);
    * ({x:x} = y);

    Note that the `y` on the right-hand side may also be enclosed within an arbitrarily complex expression!
    Data flows are always added for *all* identifiers found on the right-hand side!

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    # VariableDeclarator: let x=y, var x=y, const x=y

    # interface VariableDeclaration {
    #     declarations: VariableDeclarator[];
    #     kind: 'var' | 'const' | 'let';
    # }

    # interface VariableDeclarator {
    #     id: Identifier | BindingPattern;
    #     init: Expression | null;
    # }

    # type BindingPattern = ArrayPattern | ObjectPattern;

    # => Ignore VariableDeclarators like "let foo;" that have no right-hand-side!

    # AssignmentExpression: x=y

    # interface AssignmentExpression {
    #     operator: '=' | '*=' | '**=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';
    #     left: Expression;
    #     right: Expression;
    # }

    # ==> Handle "Destructuring Assignments" like:
    #     "let [a, b] = [x, y];"             -> should create a flow from "x" to "a" and another one from "y" to "b"
    #     "const { a: a1, b: b1 } = obj;"    -> should create a flow from "obj" to "a1" and from "obj" to "b1"
    #       -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

    # ==> Handle declarations/assignments to arbitrary expressions like:
    #     "let first_cookie = cookies[0];"     -> should create a flow from "cookies" to "first_cookie"
    #     "let first_cookie = cookies[1+2+3];" -> should create a flow from "cookies" to "first_cookie"
    #     "let x = y.z;"                       -> should create a flow from "y" to "x"
    #       -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors
    #     "let first_cookie = JSON.stringify(cookies[0]);"    -> should create a flow from "cookies" to "first_cookie"

    # Example PDG subtrees:

    # ***** "let cookies2 = cookies;" or "var cookies2 = cookies;" or "const cookies2 = cookies;": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [Identifier:"cookies2"] (0 children)
    #         [4] [Identifier:"cookies"] (0 children)

    # ***** "let cookies;": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (1 child)
    #         [3] [Identifier:"cookies"] (0 children)

    # ***** "cookies2 = cookies;": *****
    # [1] [ExpressionStatement] (1 child)
    #     [2] [AssignmentExpression] (2 children)
    #         [3] [Identifier:"cookies2"] (0 children)
    #         [4] [Identifier:"cookies"] (0 children)

    # ***** "let [cookies2, forty_two] = [cookies, 42];": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [ArrayPattern] (2 children)
    #             [4] [Identifier:"cookies2"] (0 children)
    #             [5] [Identifier:"forty_two"] (0 children)
    #         [6] [ArrayExpression] (2 children)
    #             [7] [Identifier:"cookies"] (0 children)
    #             [8] [Literal:"42"] (0 children)

    # Note that "let [four, five] = [4,5,6];" works as well.
    # "let [six, seven, eight] = [6,7];" works too, creating a variable "eight" that is undefined.
    # "[six, seven, eight] = [6,7];" sets the variable "eight" to undefined (or creating it).

    # ***** "const { a: cookies2, b: forty_two } = {a:cookies, b:42};": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [ObjectPattern] (2 children)
    #             [4] [Property] (2 children)
    #                 [5] [Identifier:"a"] (0 children)
    #                 [6] [Identifier:"cookies2"] (0 children)
    #             [7] [Property] (2 children)
    #                 [8] [Identifier:"b"] (0 children)
    #                 [9] [Identifier:"forty_two"] (0 children)
    #         [10] [ObjectExpression] (2 children)
    #             [11] [Property] (2 children)
    #                 [12] [Identifier:"a"] (0 children)
    #                 [13] [Identifier:"cookies"] (0 children)
    #             [14] [Property] (2 children)
    #                 [15] [Identifier:"b"] (0 children)
    #                 [16] [Literal:"42"] (0 children)

    data_flow_edges_added = 0

    if (pdg.name == "VariableDeclarator" or pdg.name == "AssignmentExpression") and len(pdg.children) > 1:
        lhs = pdg.lhs()
        rhs = pdg.rhs()

        if lhs.name == "Identifier":  # "let cookies2 = cookies;" or "var cookies2 = cookies;" or "const cookies2 = cookies;" or "cookies2 = cookies;"
            for identifier in rhs.get_all_identifiers():  # For each identifier in the right-hand side...:
                # ...add a data flow edge *from* that identifier *to* the left-hand side:
                data_flow_edges_added += identifier.set_data_dependency(lhs)  # includes call: identifier.data_dep_children.append(extremity=lhs)

        elif lhs.name == "MemberExpression":
            # "x.y = z;", or, equivalently(!), "x[y] = z;" (both of these generate the same tree!):
            #     [1] [AssignmentExpression:"="] (2 children)
            # 			[2] [MemberExpression] (2 children)
            # 				[3] [Identifier:"x"] (0 children)
            # 				[4] [Identifier:"y"] (0 children)
            # 			[5] [Identifier:"z"] (0 children)
            #
            # Note that "x.y.z = w;", "x[y].z = w;", "x.y[z] = w;" and "x[y][z] = w;" also all generate the same nested tree structure:
            #     [1] [AssignmentExpression:"="] (2 children)
            # 			[2] [MemberExpression] (2 children)
            # 				[3] [MemberExpression] (2 children)
            # 					[4] [Identifier:"x"] (0 children)
            # 					[5] [Identifier:"y"] (0 children)
            # 				[6] [Identifier:"z"] (0 children)
            # 			[7] [Identifier:"w"] (0 children)
            leftmost_identifier = lhs.children[0]
            while leftmost_identifier.name == "MemberExpression":
                leftmost_identifier = leftmost_identifier.children[0]

            if leftmost_identifier.name == "Identifier":  # could also be a "ThisExpression" but we're not handling that for now!
                # cf. if-case above:
                for identifier in rhs.get_all_identifiers():  # For each identifier in the right-hand side...:
                    # ...add a data flow edge *from* that identifier *to* the leftmost identifier of the left-hand side:
                    data_flow_edges_added += identifier.set_data_dependency(leftmost_identifier)  # includes call: identifier.data_dep_children.append(extremity=lhs)

        elif lhs.name == "ArrayPattern" and rhs.name == "ArrayExpression":  # "let [cookies2, forty_two] = [cookies, 42];" (the "let" being optional)
            for i in range(min(len(lhs.children), len(rhs.children))):
                for identifier in rhs.children[i].get_all_identifiers():
                    data_flow_edges_added += identifier.set_data_dependency(lhs.children[i])

        elif lhs.name == "ObjectPattern" and rhs.name == "ObjectExpression":  # "const { a: cookies2, b: forty_two } = {a:cookies, b:42};" (the "const" is optional, note however that parentheses around the assignment will be required instead then!)
            # Note that, unlike in the example, the keys of the LHS and RHS might be in a different order!
            lhs_keys = [property_.children[0].attributes['name'] for property_ in lhs.children if
                        property_.name == "Property" and property_.children[0].name == "Identifier"]
            rhs_keys = [property_.children[0].attributes['name'] for property_ in rhs.children if
                        property_.name == "Property" and property_.children[0].name == "Identifier"]
            data_flow_keys = set.intersection(set(lhs_keys), set(rhs_keys))  # in the example: set("a", "b")
            for key in data_flow_keys:
                lhs_value = [property_.children[1] for property_ in lhs.children if
                             property_.name == "Property" and len(property_.children) > 1 and property_.children[
                                 0].name == "Identifier" and property_.children[0].attributes['name'] == key][0]
                rhs_value = [property_.children[1] for property_ in rhs.children if
                             property_.name == "Property" and len(property_.children) > 1 and property_.children[
                                 0].name == "Identifier" and property_.children[0].attributes['name'] == key][0]
                for identifier in rhs_value.get_all_identifiers():
                    data_flow_edges_added += identifier.set_data_dependency(lhs_value)

        elif lhs.name == "ObjectPattern" and rhs.name == "Identifier":  # "({url} = sender);" or "({url:url} = sender);"
            # Note that both "({url} = sender);" and "({url:url} = sender);" result in the same PDG being generated:
            # [1] [AssignmentExpression:"="] (2 children)
            #     [2] [ObjectPattern] (1 child)
            #         [3] [Property] (2 children)
            #             [4] [Identifier:"url"] (0 children)
            #             [5] [Identifier:"url"] (0 children)
            #     [6] [Identifier:"sender"] (0 children)
            for lhs_identifier in lhs.get_all_identifiers():
                data_flow_edges_added += rhs.set_data_dependency(lhs_identifier)  # Note how both ends of the new data flow edge are Identifiers!

        else:
            print(f"[Warning] Unknown type of {pdg.name} (LHS: {lhs.__class__}/{lhs.name}; "
                  f"RHS: {rhs.__class__})/{rhs.name} found in {pdg.get_file()}, line {pdg.get_line()}"
                  f" - possible missed data flow(s)")

    return data_flow_edges_added +\
        sum(add_missing_data_flow_edges_declarations_and_assignments(child) for child in pdg.children)


def add_missing_data_flow_edges_call_expressions(pdg: Node) -> int:
    """
    Adds missing data flows from `y` to `x` in CallExpressions like:

    * function foo(x) { ... }
      foo(y);

    * function foo(x) { ... }
      foo(42*y);

    * function foo(x=42) { ... }
      foo(y);

    * function foo(x, a) { ... }
      foo(y, b)

    * y.then((x) => { /* ... */ })

    * y.forEach((x) => console.log(x));

    Note how this function heavily relies upon (the correct functioning of) the
    Node.function_Identifier_get_FunctionDeclaration() method for resolving identifiers referencing functions to
    FunctionDeclarations!

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    data_flow_edges_added = 0

    if pdg.name == "CallExpression" and len(pdg.children) > 1 and pdg.children[0].name == "Identifier":
        # For each `foo(y)` CallExpression, add a data flow edge from `y` to the `x` in `function foo(x) { ... }`
        #   when a function declaration for `foo` is found.
        # Likewise, for each `foo(y1, y2)` CallExpression, add a data flow edge from `y1` to `x1` and from `y2` to `x2`
        #   in `function foo(x1, x2) { ... }`, etc.
        # Note that in JavaScript it is possible to both supply too many *and* too few parameters to a function!
        #   => extra parameters will be ignored and missing parameters will become "undefined"
        #   => as a data flow needs two ends, we will add min(#params_call, #params_definition) data flows
        function_reference = pdg.children[0]  # "foo"
        function_declaration = function_reference.function_Identifier_get_FunctionDeclaration(False)  # `function foo(x) { ... }`
        if function_declaration is not None:  # some functions might be built-ins (e.g., parseInt()), imported from somewhere or created dynamically, and we can't find a declaration
            assert function_declaration.name == "FunctionDeclaration"
            no_of_params_in_call = len(pdg.children) - 1  # a CallExpression = 1 callee + N arguments (cf. Esprima docs)
            no_of_params_in_declaration = len(function_declaration.function_declaration_get_params())  # a FunctionDeclaration = M hoisted FunctionDeclarations + 1 id + N params + 1 body
            for param_index in range(min(no_of_params_in_call, no_of_params_in_declaration)):
                n_th_call_param = pdg.children[1 + param_index]
                n_th_declaration_param = function_declaration.function_declaration_get_nth_param(param_index)
                n_th_declaration_identifier = n_th_declaration_param.function_param_get_identifier()  # handles `function foo(x=42) { ... }` case (default parameter)
                if n_th_declaration_identifier is not None:
                    # Add a data flow edge for each identifier in the expression used as the parameter:
                    for identifier in n_th_call_param.get_all_identifiers():
                        # Add data flow edge:
                        data_flow_edges_added += identifier.set_data_dependency(n_th_declaration_identifier)  # y --data--> x
                    # => handles all of the following:
                    #    * `foo(y)` (i.e., n_th_call_param.name == "Identifier"),
                    #    * `foo(y=z)` (i.e., n_th_call_param.name == "AssignmentExpression"),
                    #    * `foo(42*y)` (i.e. n_th_call_param.name == "BinaryExpression").

        elif function_reference.attributes['name'] not in JAVASCRIPT_BUILT_IN_FUNCTIONS:
            print(f"[Warning] declaration of function '{function_reference.attributes['name']}' not found (line "
                  f"{function_reference.get_line()}, file {function_reference.get_file()}), "
                  f"possible missing data flow edge(s)...")

    elif (pdg.name == "CallExpression" and len(pdg.children) > 1 and pdg.children[0].name == "MemberExpression"
            and pdg.children[0].attributes['computed'] == False
            and len(pdg.children[0].children) == 2
            and pdg.children[0].lhs().name == "Identifier"
            and pdg.children[0].rhs().name == "Identifier"):
        # interface CallExpression {
        #     callee: Expression | Import;
        #     arguments: ArgumentListElement[];
        # }
        callee_member_expression = pdg.children[0]
        callee_lhs_identifier = callee_member_expression.lhs()
        callee_rhs_identifier = callee_member_expression.rhs()
        arguments = pdg.children[1:]
        assert len(arguments) > 0  # because of len(pdg.children) > 1 check above

        # For CallExpressions like `foo.bar(y)`, ...
        #   1st: try to find the class that "foo" belongs to,
        #   2nd: try to find the class declaration,
        #   3rd: try to find the declaration of a method called "bar" inside that class declaration
        #   4th: add a data flow from `y` to the `x` parameter of the "bar(x)" method declaration from step 3
        pass  # ToDo

        # For CallExpressions like `foo.bar((y) => { /* ... */ })`,
        #   add a data flow from `foo` to `y`.
        # Common examples for this would be Promises and Arrays:
        # * `promise1.then((y) => { /* ... */ })`
        # * `array1.forEach((element) => console.log(element));`
        #
        # However, there are many more functions of this form
        #     (a lambda accessing all/some of an array's elements):
        # * `array1.map((element) => console.log(element));`
        # * `array1.filter((element) => {console.log(element); return true;});`
        # * `array1.reduce(...);`
        # * `array1.some(...);`
        # * `array1.every(...);`
        # * `array1.find(...);`
        # * `array1.sort(...);`
        #
        # Note, however, that there might be many other function calls that look like this but where the arguments are
        #   not references to functions, take the following example:
        # * `Object.assign(target, source)` where both `target` and `source` are non-function objects!
        # => Therefore, resolving identifiers to function declarations might easily "fail" here w/o the need to worry:)
        for argument in arguments:  # for each "([a,b], [c,d]) => console.log(a,b,c,d)":
            if argument.name in ["FunctionExpression", "ArrowFunctionExpression"]:
                for arrow_function_param in argument.arrow_function_expression_get_params():  # for each "[a,b]":
                    for identifier in arrow_function_param.function_param_get_identifiers():   # for each "a":
                        data_flow_edges_added += callee_lhs_identifier.set_data_dependency(identifier)  # foo --data--> y
            elif argument.name == "Identifier":
                function_declaration = argument.function_Identifier_get_FunctionDeclaration(False)
                if function_declaration is not None:
                    assert function_declaration.name == "FunctionDeclaration"
                    for arrow_function_param in function_declaration.function_declaration_get_params():  # for each "[a,b]":
                        for identifier in arrow_function_param.function_param_get_identifiers():  # for each "a":
                            data_flow_edges_added += callee_lhs_identifier.set_data_dependency(identifier)  # foo --data--> y

    return data_flow_edges_added +\
        sum(add_missing_data_flow_edges_call_expressions(child) for child in pdg.children)#


def add_missing_data_flow_edges_standard_library_functions(pdg: Node) -> int:  # ToDo: create test cases
    """
    Some dataflows are non-obvious without knowing the semantics of certain functions from JavaScript's standard
    library.
    Adds missing data flows from `y` to `x` in CallExpressions like:

    * Object.assign(x, y)

    * Object.assign(x, y, a)

    * Object.assign(x, a, y)

    * Object.assign(x, y.foo());

    * Object.defineProperty(x, 'property1', {
          value: y,
          writable: false
      });

    * Object.defineProperties(x, {
          property1: {
            value: y,
            writable: true
          },
          property2: {
            value: z,
            writable:false
          }
      });

    Note that the following case is already handled by add_missing_data_flow_edges_declarations_and_assignments():

    * x = Object.assign({}, y)
    """

    data_flow_edges_added = 0

    # ##### ##### ##### ##### ##### Object.assign(): ##### ##### ##### ##### #####

    # Input: "Object.assign(x, y)"
    #
    # Output PDG:
    # [1] [Program] (1 child)
    # 	[2] [ExpressionStatement] (1 child)
    # 		[3] [CallExpression] (3 children)
    # 			[4] [MemberExpression:"False"] (2 children)
    # 				[5] [Identifier:"Object"] (0 children)
    # 				[6] [Identifier:"assign"] (0 children)
    # 			[7] [Identifier:"x"] (0 children)
    # 			[8] [Identifier:"y"] (0 children)
    object_assign_pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node.identifier("Object")
                    )
                    .child(
                        Node.identifier("assign")
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Object.assign() Pattern:\n{object_assign_pattern}")

    for pattern_match in pdg.find_pattern(object_assign_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):
        # Syntax
        #   (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign):
        #
        # Object.assign(target)
        # Object.assign(target, source1)
        # Object.assign(target, source1, source2)
        # Object.assign(target, source1, source2, /* ..., */ sourceN)

        assert pattern_match.name == "CallExpression"

        # pattern_match.children[0] is the "Object.assign" MemberExpression
        target = pattern_match.children[1]    # corresponds to the LHS of a regular assignment expression
        sources = pattern_match.children[2:]  # corresponds to the RHS of a regular assignment expression

        if target.name == "Identifier":
            for source in sources:
                for src_identifier in source.get_all_identifiers():
                    # Add a data flow edge: source --data--> target
                    data_flow_edges_added += src_identifier.set_data_dependency(target)
                    # => includes call: src_identifier.data_dep_children.append(extremity=target)

    # ##### ##### ##### ##### ##### Object.defineProperty(): ##### ##### ##### ##### #####

    # Input: "Object.defineProperty(x, 'property1', {value: y, writable: false});"
    #
    # Output PDG:
    # [1] [Program] (1 child)
    # 	[2] [ExpressionStatement] (1 child)
    # 		[3] [CallExpression] (4 children)
    # 			[4] [MemberExpression:"False"] (2 children)
    # 				[5] [Identifier:"Object"] (0 children)
    # 				[6] [Identifier:"defineProperty"] (0 children)
    # 			[7] [Identifier:"x"] (0 children)
    # 			[8] [Literal::{'raw': "'property1'", 'value': 'property1'}] (0 children)
    # 			[9] [ObjectExpression] (2 children)
    # 				[10] [Property] (2 children)
    # 					[11] [Identifier:"value"] (0 children)
    # 					[12] [Identifier:"y"] (0 children)
    # 				[13] [Property] (2 children)
    # 					[14] [Identifier:"writable"] (0 children)
    # 					[15] [Literal::{'raw': 'false', 'value': False}] (0 children)
    object_define_property_pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node.identifier("Object")
                    )
                    .child(
                        Node.identifier("defineProperty")
                    )
            )
            # .child(
            #     Node("ObjectExpression")
            #         .child(
            #             Node("Property")
            #                 .child(
            #                     Node.identifier("value")
            #                 )
            #         )
            # )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Object.defineProperty() Pattern:\n{object_define_property_pattern}")

    for pattern_match in pdg.find_pattern(object_define_property_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,  # IMPORTANT!
                                          allow_different_child_order=False):
        # Syntax (see
        #   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty):
        #
        # Object.defineProperty(obj, prop, descriptor)
        #
        # obj:        The object on which to define the property.
        # prop:       A string or Symbol specifying the key of the property to be defined or modified.
        # descriptor: The descriptor for the property being defined or modified.
        #             -> come in 2 main flavors: data descriptors and accessor descriptors:
        #                -> A data descriptor is a property with a value that may or may not be writable.
        #                -> An accessor descriptor is a property described by a getter-setter pair of functions.
        #                => A descriptor must be one of these two flavors; it cannot be both.
        #             -> Both data and accessor descriptors are objects. They share the following optional keys:
        #                -> "configurable" (Defaults to false.)
        #                -> "enumerable"   (Defaults to false.)
        #             -> A data descriptor also has the following optional keys:
        #                -> "value"    (Defaults to undefined.)
        #                -> "writable" (Defaults to false.)
        #             -> An accessor descriptor also has the following optional keys:
        #                -> "get" (Defaults to undefined.)
        #                -> "set" (Defaults to undefined.)
        #             -> If a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a
        #                data descriptor.
        #             -> If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.
        #
        # Return value: The object that was passed to the function, with the specified property added or modified.
        #
        # => Note that we only care about the data flow:
        #    value --data--> obj
        #    (or rather for each identifier occurring within `value`)

        assert pattern_match.name == "CallExpression"

        if len(pattern_match.children) < 4:
            # 0th child of CallExpression = "Object.defineProperty" MemberExpression
            # 1st child of CallExpression = obj parameter
            # 2nd child of CallExpression = prop parameter
            # 3rd child of CallExpression = descriptor parameter
            # + as for any JavaScript function, additional redundant parameters may be supplied w/o having any effect!
            print(f"[Warning] incorrect usage of Object.defineProperty(obj, prop, descriptor) found "
                  f"in line {pattern_match.get_line()} (file {pattern_match.get_file()}): "
                  f"supplied too few arguments: {len(pattern_match.children) - 1} instead of 3; no data flow added.")
            continue

        obj: Node = pattern_match.children[1]
        if obj.name == "Identifier":
            descriptor: Node = pattern_match.children[3]
            if descriptor.name == "ObjectExpression":  # Object.defineProperty(x, 'prop1', {value: y, writable: false});
                for property_ in descriptor.children:
                    if (property_.name == "Property" and len(property_.children) == 2
                            and property_.lhs().name == "Identifier" and property_.lhs().attributes['name'] == "value"):
                        value = property_.rhs()  # "y" in the example above
                        for value_identifier in value.get_all_identifiers():
                            # Add a data flow edge: y --data--> x
                            data_flow_edges_added += value_identifier.set_data_dependency(obj)
                            # => includes call: value_identifier.data_dep_children.append(extremity=obj)

            elif descriptor.name == "Identifier":   # Object.defineProperty(x, 'property1', descriptor);
                # Add a data flow edge: descriptor --data--> x
                data_flow_edges_added += descriptor.set_data_dependency(obj)
                # => includes call: descriptor.data_dep_children.append(extremity=obj)

            else:
                print(f"[Warning] descriptor parameter found in Object.defineProperty(obj, prop, descriptor) call "
                      f"(in line {pattern_match.get_line()}, file {pattern_match.get_file()}) is neither an "
                      f"ObjectExpression nor an Identifier; no data flow added.")

        else:
            print(f"[Warning] obj parameter found in Object.defineProperty(obj, prop, descriptor) call "
                  f"(in line {pattern_match.get_line()}, file {pattern_match.get_file()}) is not an "
                  f"Identifier; no data flow added.")

    # ToDo: implement handling of Object.defineProperties()

    return data_flow_edges_added
