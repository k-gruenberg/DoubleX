import os
import statistics
import timeit
from typing import List, Dict, Set, Tuple, Optional

from .node import Node
from .utility_df import cross_product

JAVASCRIPT_BUILT_IN_FUNCTIONS = [  # ToDo: refactor the place where I use this?!!!
    # Note that this list also includes constructors, anything that might end up in a CallExpression!
    "eval", "isFinite", "isNaN", "parseFloat", "parseInt",
    "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent",
    "escape", "unescape",  # both deprecated!
    "Object", "Function", "Boolean", "Symbol",
    "Error", "AggregateError", "EvalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError",
    # Firefox-only: "InternalError",
    "Number", "BigInt", "Date",  # Math is not a function
    "String", "RegExp",
    "Array",  # "Int8Array", "Uint8Array", etc. may only occur in a NewExpression, not in a CallExpression!
    # calling Map(), Set(), WeakMap(), WeakSet() without "new" is forbidden, too!
    # same for ArrayBuffer(), DataView(),
    # same for WeakRef(), FinalizationRegistry(),
    # same for Iterator(), Promise(),
    # same for Proxy()
    # => Source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects
    "clearInterval", "setInterval", "setTimeout",
    # => https://developer.mozilla.org/en-US/docs/Web/API/clearInterval
]


def add_missing_data_flow_edges(pdg: Node, add_basic_df_edges: bool = False, benchmarks: Optional[dict] = None) -> int:
    """
    Sadly, in the PDGs generated by DoubleX, some data flow edges that we need are missing.
    This function adds those missing data flow edges to the given PDG, e.g. those from y to x in a "x=y" assignment
    expression (including those cases where the "y" on the RHS is part of a more complex expression: "x=foo(y)").

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to
        add_basic_df_edges: whether to add the basic data flow edges;
                            supply False if you intend to generate those lazily
                            (default; much better performance for larger, obfuscated extensions)
        benchmarks: the dictionary in which to store benchmarks of the individual steps of DF generation (optional)

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    # ToDo: add dataflow edge from "x" to "x.y" ?
    # ToDo: handle flows like: "url = url.replace(...)"
    # ToDo: handle data flow of "x" inside "function foo(x=42) { console.log(x) }"
    #       or "fetch(url).then(([x,y]) => foo(x,y))", DoubleX seems to miss that!

    if benchmarks is None:
        benchmarks = dict()

    total_data_flow_edges_added = 0

    # The following is essentially an attempt at re-implementing DoubleX's data flow creation:
    if add_basic_df_edges:
        start = timeit.default_timer()
        edges_added_basic = add_basic_data_flow_edges(pdg,
                                                      identifier_of_interest=None,
                                                      debug=(os.environ.get('DEBUG') == "yes"))
        benchmarks["add_basic_data_flow_edges"] = timeit.default_timer() - start
        print(f"[Adding data flows] {edges_added_basic} basic data flow edges added between identifiers with the same name.")
        total_data_flow_edges_added += edges_added_basic

    # # add_missing_data_flow_edges_function_parameters() generates a subset of the data flow edges generated by
    # #    add_basic_data_flow_edges(); it's only needed when using DoubleX-generated data flow edges instead of
    # #    add_basic_data_flow_edges():
    # edges_added_func_params = add_missing_data_flow_edges_function_parameters(pdg)
    # print(f"[Adding data flows] {edges_added_func_params} data flow edges added to function parameters.")
    # total_data_flow_edges_added += edges_added_func_params

    start = timeit.default_timer()
    edges_added_declarations_and_assignments = add_missing_data_flow_edges_declarations_and_assignments(pdg)
    benchmarks["add_missing_data_flow_edges_declarations_and_assignments"] = timeit.default_timer() - start
    print(f"[Adding data flows] {edges_added_declarations_and_assignments} data flow edges added to declarations and "
          f"assignments.")
    total_data_flow_edges_added += edges_added_declarations_and_assignments

    start = timeit.default_timer()
    edges_added_standard_library_functions = add_missing_data_flow_edges_standard_library_functions(pdg)
    benchmarks["add_missing_data_flow_edges_standard_library_functions"] = timeit.default_timer() - start
    print(f"[Adding data flows] {edges_added_standard_library_functions} edges added to standard library functions.")
    total_data_flow_edges_added += edges_added_standard_library_functions

    start = timeit.default_timer()
    edges_added_chrome_apis = add_missing_data_flow_edges_chrome_apis(pdg)
    benchmarks["add_missing_data_flow_edges_chrome_apis"] = timeit.default_timer() - start
    print(f"[Adding data flows] {edges_added_chrome_apis} edges added to Chrome API calls.")
    total_data_flow_edges_added += edges_added_chrome_apis

    start = timeit.default_timer()
    edges_added_call_expressions = add_missing_data_flow_edges_call_expressions(pdg)
    benchmarks["add_missing_data_flow_edges_call_expressions"] = timeit.default_timer() - start
    print(f"[Adding data flows] {edges_added_call_expressions} edges added to call expressions.")
    total_data_flow_edges_added += edges_added_call_expressions

    # ToDo: handle "this" flows somehow (problem: "this" becomes a ThisExpression and not an Identifier...):
    #       Example #1: let x=42; (function(){ console.log("This is: " + this); }.bind(x))();  // prints: "This is: 42"
    #       Example #2: x = this;  // should add a data flow from right to left!
    #       Example #3: this.forEach((x) => { ... })  // should add a data flow from 'this' to 'x'
    #       => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind
    #

    return total_data_flow_edges_added


def add_basic_data_flow_edges(pdg: Node, identifier_of_interest: Optional[Node] = None, debug=False) -> int:
    """
    Adds the basic data flow edges from each usage of an identifier to each usage that follows:

    [id1] --data--> [id2]

    where [id2] directly refers to [id1], i.e.:

        * both [id1] and [id2] are Identifier Nodes
        * both [id1] and [id2] Identifiers have the same *name*
          (note that changes in name will be handled later by add_missing_data_flow_edges_declarations_and_assignments)

        * [id1] must stem from an (im- or explicit) declaration or an assignment, i.e., it must be
          - the (or, *within* the) "id" (0th child) of a VariableDeclarator (let, var, const)
          - the "id" (0th child, optional) of a ClassDeclaration
          - the "id" (0th child, optional) or one of (or, *within* one of) the "params" of a FunctionDeclaration
          => type Declaration = ClassDeclaration | FunctionDeclaration | VariableDeclaration;
          - the "id" (0th child, optional) or one of (or, *within* one of) the "params" of a (Arrow)FunctionExpression
          - the (or, *within* the) "left" part (0th child) of an AssignmentExpression

        * [id1] or [id2] may occur in the Property of an ObjectPattern, but it must be on the RHS of the Property
          (the LHS identifier of a Property is simply the name of the field being assigned)
          => note: [id1] may occur in the Property of an ObjectPattern when a function argument is destructured!
        * [id2] may appear in a MemberExpression, but it must be on the very left of it
          (unless [id1] was defined using "var" within the global scope or via an implicit global variable creation
           through a simple assignment, then it may also be referred to with a "this." in front of it because "this"
           refers to the global object in non-strict mode) # todo
           => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Assignment
           => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this

        * [id2] occurs in code *after* [id1], or *might* occur after [id1]
          because at least one of [id1] or [id2] is inside a function in which the other one is *not*
          (the latter refers to these cases: "function foo() { [id1] = y } foo(); x = [id2];" vs.
                                             "function foo() { [id1] = y } x = [id2]; foo();" and
                                             "function foo() { x = [id2]; } [id1] = y; foo();" vs.
                                             "function foo() { x = [id2]; } foo(); [id1] = y;")
        * wherever [id2] is, [id1] is in scope and has *not* been overwritten by another Identifier with the same name
          in a "closer"/"more inner" scope; it also hasn't been reassigned since(!)
          (note that the scope will differ depending on how the Identifier [id1] was originally declared:
           the scope = - the surrounding function for 'var' as well as function declarations
                       - the surrounding block for 'let'/'const'
                       - only the function itself for (arrow) function expressions
                       - the global scope for any global variable implicitly created through a simple assignment)

    Note that [id1] might be where the identifier is declared/defined:
        let x = foo();  // [id1]
        bar(x);         // [id2]

    However, [id1] doesn't *have* to be where the identifier is declared:
        let x = 42;
        x = foo();   // [id1]
        bar(x);      // [id2]

    Examples:

        * x = 1
          y = x
          => a flow from the first "x" to the second "x" is created

        * function foo({x:a}) {
              console.log(a);
          }
          => a flow from the first "a" to the second "a" is created

        * function foo(x=1) {
              console.log(x);
          }
          => a flow from the first "x" to the second "x" is created

        * (function(t) {
               !function t() {}
               console.log(t);
          })(42);
          => a flow from the first "t" to the third "t" is created

    *** Notes on time complexity: ***
    In the worst case scenario, this function will run in O(n^2) where n = the total number of identifier nodes.
    In reality however, this function will run much more efficiently under the following realistic assumptions:
        * not all identifiers will have the same name; with k distinct identifier names, complexity will be reduced to
          O(k * (n/k)^2) = O(n^2 / k) (under the assumption that all k identifier names occur equally often)
        * a lot of identifiers can be thrown out because they...
          - ...are inside the inner part of a MemberExpression,
          - ...are on the LHS of a Property.
          - ...do not stem from a declaration (or assignment).
    Take the "Norton Password Manager" extension (ID admmjipmmciaobhojoghlmleefbicajg, v7.5.1.48) for example,
    its background.js is 7.3MB large (making it the 4th largest background page out of the 44 Kim+Lee extensions),
    has 298,000 lines of JavaScript code and its AST contains:
      n = 424,695 identifier nodes, and
      k =  25,809 distinct identifier names.

    Parameters:
        pdg: Node; the entire (soon to be) PDG
        identifier_of_interest: an Identifier Node in `pdg` (optional, default: None);
                                if not None, only [id1] --data--> [id2] flows will be created
                                where either [id1]==node_of_interest or [id2]==node_of_interest;
                                makes this function much faster (O(n) instead of O(n^2))!!!;
                                useful for lazy data flow generation!!!
        debug: boolean; whether to print debug prints to console
    """
    if identifier_of_interest is not None:
        assert identifier_of_interest.name == "Identifier"

    data_flow_edges_added: int = 0

    # Collect *all* Identifier Nodes and group them by their name
    #   (we'll only create DF edged between Identifiers with the same name in this function)
    #   => to avoid continuous re-computation in lazy mode, the result will be cached within the PDG root node:
    root: Node = pdg.root()
    if root.identifiers_by_name is None:
        identifiers_by_name: Dict[str, List[Node]] = dict()
        for identifier in pdg.get_all_as_iter("Identifier"):
            # When identifier_of_interest=None, non-lazy basic data flow creation is used.
            # To avoid *additional* redundant "lazy" re-computation in data_dep_parents()/data_dep_children(),
            # we set the `basic_data_dep_computed` of all Identifiers to True.
            if identifier_of_interest is None:
                identifier.basic_data_dep_computed = True  # => technically not yet, but we are going to below :)

            identifier_name: str = identifier.attributes['name']
            if identifier_name not in identifiers_by_name:
                identifiers_by_name[identifier_name] = list()
            identifiers_by_name[identifier_name].append(identifier)
        # => O(n) where: n = the total number of identifier nodes

        if debug:
            print(f"Identifiers found: {sum(len(v) for v in identifiers_by_name.values())}")
            print(f"Distinct identifier names found: {len(identifiers_by_name)}")
            if len(identifiers_by_name.values()) > 0:
                print(f"Min. no. of occurrences per identifier name: {min(len(v) for v in identifiers_by_name.values())}")
                print(f"Avg. no. of occurrences per identifier name: {statistics.mean([len(v) for v in identifiers_by_name.values()])}")
                print(f"Max. no. of occurrences per identifier name: {max(len(v) for v in identifiers_by_name.values())}")
            print(f"Actual no. of loop iterations (upper limit): {sum(len(v) * len(v) for v in identifiers_by_name.values())}")

        # Cache result for next time:
        root.identifiers_by_name = identifiers_by_name
    else:  # Retrieve cached result:
        identifiers_by_name: Dict[str, List[Node]] = root.identifiers_by_name

    for identifier_name, identifiers in identifiers_by_name.items():
        # => O(k) iterations where: k = the total number of distinct identifier names
        # => however, just one iteration will do anything at all if identifier_of_interest is not None:
        if identifier_of_interest is not None and identifier_name != identifier_of_interest.attributes['name']:
            continue

        # All [id1] candidates with name `identifier_name`:
        identifiers1: List[Node] = [id1 for id1 in identifiers
                                    if
                                       # * [id1] must stem from an (im- or explicit) declaration or an assignment:
                                       (id1.is_within_the_nth_child_of_a(0, ["VariableDeclarator"]) or  # todo: more efficient function: add forbidden_ancestor_names param?
                                        id1.is_nth_child_of_a(0, ["ClassDeclaration"]) or
                                        id1.is_nth_child_of_a(0, ["FunctionDeclaration"]) or
                                        id1.is_or_is_inside_any_function_declaration_param() or
                                        id1.is_id_of_arrow_function_expression() or
                                        id1.is_or_is_inside_any_arrow_function_expression_param() or
                                        id1.is_within_the_nth_child_of_a(0, ["AssignmentExpression"]))  # todo: more efficient function]
                                       # * [id1] or [id2] may occur in the Property of an ObjectPattern, but it must be on the RHS of the Property:
                                       and not id1.is_nth_child_of_a(0, ["Property"])
                                    ]
        if debug:
            print(f"No. of [id1] candidates named '{identifier_name}': {len(identifiers1)}")

        # All [id2] candidates with name `identifier_name`:
        identifiers2: List[Node] = [id2 for id2 in identifiers
                                    if
                                       # * [id2] may appear in a MemberExpression, but it must be on the very left of it:
                                       # ToDo: allow "this." in front for variables of global scope (but only if declared using "var" or "="!!!):
                                       not id2.is_nth_child_of_a(1, ["MemberExpression"]) and
                                       # * [id1] or [id2] may occur in the Property of an ObjectPattern, but it must be on the RHS of the Property:
                                       not id2.is_nth_child_of_a(0, ["Property"])
                                    ]

        if debug:
            print(f"No. of [id2] candidates named '{identifier_name}': {len(identifiers2)}")
            print(f"#[id1] x #[id2] = {len(identifiers1) * len(identifiers2)}")

        # A note on Properties:
        # Even though the grammar in the Esprima docs says that the LHS of a Property may be any kind of expression...:
        #     interface Property {
        #         key: Expression;
        #         value: Expression | null;
        #     }
        # ...according to the Mozilla docs...:
        #     "Each property name before colons is an identifier (either a name, a number, or a string literal),
        #      and each valueN is an expression whose value is assigned to the property name."
        # (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_objects)
        # ...meaning that, in reality, `key` will always be either an Identifier or a Literal!
        # The Mozilla docs give the following example:
        #     const obj = {
        #         property1: value1, // property name may be an identifier
        #         2: value2, // or a number
        #         "property n": value3, // or a string
        #     };

        for identifier1, identifier2 in cross_product(identifiers1,
                                                      identifiers2,
                                                      where_either_equals=identifier_of_interest):
            # * identifier1 = [id1] (name is identifier_name).
            # * identifier2 = [id2] (name is identifier_name).
            # * `where_either_equals` argument has no effect when None is supplied.

            if identifier1 != identifier2:  # do not add loops: [id1] --data--> [id1]
                # Now, shall we create an edge [id1] --data--> [id2]?!:

                # * [id2] occurs in code *after* [id1], or *might* occur after [id1]:
                if not (
                    identifier2.occurs_in_code_after(identifier1) or
                    identifier2.might_occur_after(identifier1) or
                    identifier1.is_id_of_function_declaration()  # (scope is checked later)
                ):
                    if debug:
                        print(f"[id2] (line {identifier2.get_line()}) "
                              f"doesn't and may not occur after [id1] (line {identifier1.get_line()})")
                    continue

                # * wherever [id2] is, [id1] is in scope and has *not* been overwritten/overshadowed
                #   by another Identifier with the same name in a "closer"/"more inner" scope; it also hasn't
                #   been reassigned since(!):
                if (
                    not identifier1.identifier_is_in_scope_at(identifier2,
                                                              allow_overshadowing=False,
                                                              allow_reassignment_after_decl=True,
                                                              allow_reassignment_after_self=False)
                    # *** Notes: ***
                    # * [id1] may have been reassigned beforehand (i.e., between declaration and [id1])
                    #   but *not* between [id1] and [id2] !!!
                    # * allow_reassignment_after_self=False also forbids that `identifier2` *itself* is part of a
                    #   reassignment to `identifier1` !!! (i.e., no flow in "function foo(x) { x = 1 }")
                ):
                    if debug:
                        print(f"[id1] (line {identifier1.get_line()}) "
                              f"isn't in scope (or re-assigned) @ [id2] (line {identifier2.get_line()})")
                    continue

                data_flow_edges_added += identifier1.set_data_dependency(identifier2)
                # includes call: identifier1._data_dep_children.append(extremity=identifier2)
                if debug:
                    print(f"added DF edge from [id1] (line {identifier1.get_line()}) "
                          f"to [id2] (line {identifier2.get_line()})")
    # => worst case: O(n^2) where: n = the total number of identifier nodes

    # => worst case: O(n^2) when k=1
    # => O(k * (n/k)^2) = O(n^2 / k) where: k = the total number of distinct identifier names
    #                                under the assumption that all identifier names appear equally often

    return data_flow_edges_added


def add_missing_data_flow_edges_function_parameters(pdg: Node) -> int:
    """
    Examples:

        * function foo(z) {
              console.log(z);
          }
          => a flow from the first "z" to the second "z" is created

        * function foo({x:a}) {
              console.log(a);
          }
          => a flow from the first "a" to the second "a" is created

        * function foo(x=1) {
              console.log(x);
          }
          => a flow from the first "x" to the second "x" is created

        * (function(t) {
               !function t() {}
               console.log(t);
          })(42);
          => a flow from the first "t" to the third "t" is created

        * function foo(w) { // ...and not this one!
              function bar(w) { // ...refers to this x...
                  console.log(w); // This x...
              }
          }
          => a flow from the second "w" to the third "w" is created
    """
    data_flow_edges_added: int = 0

    # Collect function parameters and function bodies for both FunctionDeclaration and (Arrow)FunctionExpressions:
    func_params_and_bodies: List[Tuple[List[Node], Node]] = []
    for func_decl in pdg.get_all_as_iter("FunctionDeclaration"):
        func_params_and_bodies.append((
            func_decl.function_declaration_get_params(),
            func_decl.function_declaration_get_body()
        ))
    for func_expr in pdg.get_all_as_iter2(["ArrowFunctionExpression", "FunctionExpression"]):
        func_params_and_bodies.append((
            func_expr.arrow_function_expression_get_params(),
            func_expr.arrow_function_expression_get_body()
        ))

    # Handle each (function parameters, function body) pair:
    for func_params, func_body in func_params_and_bodies:
        # For each parameter:
        for func_param in func_params:
            # For each identifier in the parameter:
            for id1 in func_param.get_all_as_iter("Identifier"):
                # If the identifier doesn't occur in the LHS of an ObjectPattern's Property (the LHS identifier of a
                #   Property is simply the name of the field being assigned, it doesn't become an identifier in the
                #   function that could be referenced!):
                if not id1.is_nth_child_of_a(0, ["Property"]):
                    # For each identifier [id2] within the Function body with the same name,
                    #   add an edge [id1] --data--> [id2] if
                    #   (a) [id1] is in scope where [id2] is, and
                    #   (b) [id1] is *accessible* (i.e., not overwritten by another identifier) where [id2] is
                    #       (the identifier [id1] might be in scope, theoretically, but it might also have already been
                    #        overwritten because [id2] is within a function within the function and that function *also*
                    #        has a parameter with the same name, or re-declares a variable with the same name)
                    #   (c) [id1] hasn't been reassigned to before reaching [id2]
                    #       (meaning that it hasn't been the LHS of any AssignmentExpression before reaching [id2])
                    #   => the Node.identifier_is_in_scope_at() method takes care of (a), (b) and (c) !!!
                    #      (when setting both the `allow_overshadowing` and `allow_reassignment` flags to False that is)
                    for id2 in func_body.get_all_as_iter("Identifier"):
                        if id1.attributes['name'] == id2.attributes['name']:
                            if id1.identifier_is_in_scope_at(id2,
                                                             allow_overshadowing=False,
                                                             allow_reassignment_after_decl=False,
                                                             allow_reassignment_after_self=False):
                                data_flow_edges_added += id1.set_data_dependency(id2)
                                # includes call: id._data_dep_children.append(extremity=id2)
                                # *** Note: ***
                                # * Since [id1] here is always where the identifier is defined, the
                                #   `allow_reassignment_after_decl` and `allow_reassignment_after_self` parameters
                                #   are equivalent!
                                # * allow_reassignment=False also forbids that `id2` *itself* is part of a reassignment
                                #   to `id1` !!! (i.e., no flow in "function foo(x) { x = 1 }")
                            else: # todo: remove
                                print(f"[id1]=[{id1.id}] is not in scope at [id2]=[{id2.id}]")

    return data_flow_edges_added


def add_missing_data_flow_edges_declarations_and_assignments(pdg: Node) -> int:
    """
    Adds missing data flows from `y` to `x` in statements/expressions/declarations like:

    * let x=y;
    * var x=y;
    * const x=y;
    * x=y;
    * x.foo = y;
    * x[foo] = y;
    * x.foo.bar = y;
    * x[foo][bar] = y;
    * let [x, a] = [y, b];
    * const { a: x, b: foo } = {a: y, b: bar};
    * const { b: foo, a: x } = {a: y, b: bar};
    * ({x} = y);
    * ({x:x} = y);

    Note that the `y` on the right-hand side may also be enclosed within an arbitrarily complex expression!
    Data flows are always added for all identifiers found on the right-hand side; with a few notable exceptions:
    1. all RHS identifiers occurring within (Arrow)FunctionExpressions (both within the parameters and within the body)
       => this is in order to reduce the amount of false positives, even if it may miss a few very obscure flows.

    Also adds data flows in the other direction, from `x` to `y` in non-declaring member assignments where the RHS
    is an (Arrow)FunctionExpression; e.g.:

    * x.onsuccess = (y) => { /* ... */ };
    * x.onerror = (y) => { /* ... */ };

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    # VariableDeclarator: let x=y, var x=y, const x=y

    # interface VariableDeclaration {
    #     declarations: VariableDeclarator[];
    #     kind: 'var' | 'const' | 'let';
    # }

    # interface VariableDeclarator {
    #     id: Identifier | BindingPattern;
    #     init: Expression | null;
    # }

    # type BindingPattern = ArrayPattern | ObjectPattern;

    # => Ignore VariableDeclarators like "let foo;" that have no right-hand-side!

    # AssignmentExpression: x=y

    # interface AssignmentExpression {
    #     operator: '=' | '*=' | '**=' | '/=' | '%=' | '+=' | '-=' | '<<=' | '>>=' | '>>>=' | '&=' | '^=' | '|=';
    #     left: Expression;
    #     right: Expression;
    # }

    # ==> Handle "Destructuring Assignments" like:
    #     "let [a, b] = [x, y];"             -> should create a flow from "x" to "a" and another one from "y" to "b"
    #     "const { a: a1, b: b1 } = obj;"    -> should create a flow from "obj" to "a1" and from "obj" to "b1"
    #       -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

    # ==> Handle declarations/assignments to arbitrary expressions like:
    #     "let first_cookie = cookies[0];"     -> should create a flow from "cookies" to "first_cookie"
    #     "let first_cookie = cookies[1+2+3];" -> should create a flow from "cookies" to "first_cookie"
    #     "let x = y.z;"                       -> should create a flow from "y" to "x"
    #       -> https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_accessors
    #     "let first_cookie = JSON.stringify(cookies[0]);"    -> should create a flow from "cookies" to "first_cookie"

    # Example PDG subtrees:

    # ***** "let cookies2 = cookies;" or "var cookies2 = cookies;" or "const cookies2 = cookies;": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [Identifier:"cookies2"] (0 children)
    #         [4] [Identifier:"cookies"] (0 children)

    # ***** "let cookies;": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (1 child)
    #         [3] [Identifier:"cookies"] (0 children)

    # ***** "cookies2 = cookies;": *****
    # [1] [ExpressionStatement] (1 child)
    #     [2] [AssignmentExpression] (2 children)
    #         [3] [Identifier:"cookies2"] (0 children)
    #         [4] [Identifier:"cookies"] (0 children)

    # ***** "let [cookies2, forty_two] = [cookies, 42];": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [ArrayPattern] (2 children)
    #             [4] [Identifier:"cookies2"] (0 children)
    #             [5] [Identifier:"forty_two"] (0 children)
    #         [6] [ArrayExpression] (2 children)
    #             [7] [Identifier:"cookies"] (0 children)
    #             [8] [Literal:"42"] (0 children)

    # Note that "let [four, five] = [4,5,6];" works as well.
    # "let [six, seven, eight] = [6,7];" works too, creating a variable "eight" that is undefined.
    # "[six, seven, eight] = [6,7];" sets the variable "eight" to undefined (or creating it).

    # ***** "const { a: cookies2, b: forty_two } = {a:cookies, b:42};": *****
    # [1] [VariableDeclaration] (1 child)
    #     [2] [VariableDeclarator] (2 children)
    #         [3] [ObjectPattern] (2 children)
    #             [4] [Property] (2 children)
    #                 [5] [Identifier:"a"] (0 children)
    #                 [6] [Identifier:"cookies2"] (0 children)
    #             [7] [Property] (2 children)
    #                 [8] [Identifier:"b"] (0 children)
    #                 [9] [Identifier:"forty_two"] (0 children)
    #         [10] [ObjectExpression] (2 children)
    #             [11] [Property] (2 children)
    #                 [12] [Identifier:"a"] (0 children)
    #                 [13] [Identifier:"cookies"] (0 children)
    #             [14] [Property] (2 children)
    #                 [15] [Identifier:"b"] (0 children)
    #                 [16] [Literal:"42"] (0 children)

    IGNORE_LHS_IDENTIFIERS_IN: List[str] = ["BlockStatement", "FunctionExpression", "ArrowFunctionExpression"]
    IGNORE_RHS_IDENTIFIERS_IN: List[str] = ["BlockStatement", "FunctionExpression", "ArrowFunctionExpression"]

    data_flow_edges_added = 0

    if (pdg.name == "VariableDeclarator" or pdg.name == "AssignmentExpression") and len(pdg.children) > 1:
        lhs = pdg.lhs()
        rhs = pdg.rhs()

        if lhs.name == "Identifier":  # "let cookies2 = cookies;" or "var cookies2 = cookies;" or "const cookies2 = cookies;" or "cookies2 = cookies;"
            # For each identifier in the right-hand side...:
            for identifier in rhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):  # (exception #1)
                # ...add a data flow edge *from* that identifier *to* the left-hand side:
                data_flow_edges_added += identifier.set_data_dependency(lhs)  # includes call: identifier._data_dep_children.append(extremity=lhs)

        elif lhs.name == "MemberExpression":
            # "x.y = z;", or, equivalently(!), "x[y] = z;" (both of these generate the same tree!):
            #     [1] [AssignmentExpression:"="] (2 children)
            # 			[2] [MemberExpression] (2 children)
            # 				[3] [Identifier:"x"] (0 children)
            # 				[4] [Identifier:"y"] (0 children)
            # 			[5] [Identifier:"z"] (0 children)
            #
            # Note that "x.y.z = w;", "x[y].z = w;", "x.y[z] = w;" and "x[y][z] = w;" also all generate the same nested tree structure:
            #     [1] [AssignmentExpression:"="] (2 children)
            # 			[2] [MemberExpression] (2 children)
            # 				[3] [MemberExpression] (2 children)
            # 					[4] [Identifier:"x"] (0 children)
            # 					[5] [Identifier:"y"] (0 children)
            # 				[6] [Identifier:"z"] (0 children)
            # 			[7] [Identifier:"w"] (0 children)
            leftmost_identifier = lhs.member_expression_get_leftmost_identifier()

            if leftmost_identifier.name == "Identifier":  # could also be a "ThisExpression" but we're not handling that for now!
                # cf. if-case above:
                for identifier in rhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):  # For each identifier in the right-hand side...:
                    # ...add a data flow edge *from* that identifier *to* the leftmost identifier of the left-hand side:
                    data_flow_edges_added += identifier.set_data_dependency(leftmost_identifier)  # includes call: identifier._data_dep_children.append(extremity=lhs)

                # Also adds data flows in the other direction, from `x` to `y` in non-declaring member assignments where
                #     the RHS is an (Arrow)FunctionExpression; e.g.:
                # x.onsuccess = (y) => { /* ... */ };
                if pdg.name == "AssignmentExpression":
                    # (1) Determine all function params:
                    func_params: List[Node] = []
                    if rhs.name in ["ArrowFunctionExpression", "FunctionExpression"]:
                        func_params = rhs.arrow_function_expression_get_params()
                    elif rhs.name == "Identifier":
                        func_decl: Optional[Node] = rhs.function_Identifier_get_FunctionDeclaration(False)
                        # => print_warning_if_not_found=False because Identifier may very well not refer to a function!
                        if func_decl is not None:
                            func_params = func_decl.function_declaration_get_params()
                    # (2) For each identifier `y` in each function param, add a data flow edge x --data--> y:
                    for func_param in func_params:
                        for func_param_identifier in func_param.function_param_get_identifiers():
                            data_flow_edges_added += leftmost_identifier.set_data_dependency(func_param_identifier)

        elif lhs.name == "ArrayPattern" and rhs.name == "ArrayExpression":  # "let [cookies2, forty_two] = [cookies, 42];" (the "let" being optional)
            # BEWARE: The children of the ArrayPattern on the LHS need not be Identifiers !!!
            #         They can be AssignmentPatterns, too, e.g.: "let [x=1, y] = [a,b];"
            #         They can be None, too, e.g.:               "let [x, , y] = [a,b,c];"
            #         They can be RestElements, too, e.g.:       "let [x, y, ...rest] = [a,b,c,d];"
            #                                                    "let [x, y, ...[z, w]] = [a,b,c,d];"
            #                                                    "let [x, y, ...[z, w]] = [a,b,c,d,e];"
            #                                                    "let [x, y, ...[z, w]] = [a,b,c];"
            #                                                    "let [x, y, ...{ length }] = [a,b,c,d];" => length==2
            # => https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
            for i in range(min(len(lhs.children), len(rhs.children))):
                # NOTE: We take the min of the two lengths as both of the following two cases are possible:
                #       1.) let [x,y]   = [a,b,c];  // discards the value of c
                #       2.) let [x,y,z] = [a,b];    // z becomes undefined
                #       In both cases, there are only 2 data flows: a --data--> x and b --data--> y.
                match lhs.children[i].name:
                    case "Identifier":  # "let [x, y] = [a,b];"
                        for rhs_identifier in rhs.children[i].get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                            data_flow_edges_added += rhs_identifier.set_data_dependency(lhs.children[i])

                    case "AssignmentPattern":  # e.g.: "let [x=1, y] = [a,b];"
                        # interface AssignmentPattern {
                        #     left: Identifier | BindingPattern;
                        #     right: Expression;
                        # }
                        # where: type BindingPattern = ArrayPattern | ObjectPattern;
                        assignment_pattern: Node = lhs.children[i]
                        match assignment_pattern.lhs().name:
                            case "Identifier":  # "let [x=1, y] = [a,b];" => add DF: a --data--> x
                                lhs_identifier: Node = assignment_pattern.lhs()
                                for rhs_identifier in rhs.children[i].get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                                    data_flow_edges_added += rhs_identifier.set_data_dependency(lhs_identifier)
                            case "ArrayPattern":  # "let [[x1,x2]=[1,2], y] = [a,b];" => add DFs: a --data--> x1 & a --data--> x2
                                lhs_array_pattern: Node = assignment_pattern.lhs()
                                rhs_item: Node = rhs.children[i]
                                for identifier1 in rhs_item.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                                    for identifier2 in lhs_array_pattern.get_all_identifiers_not_inside_a_as_iter(IGNORE_LHS_IDENTIFIERS_IN):
                                        data_flow_edges_added += identifier1.set_data_dependency(identifier2)
                            case "ObjectPattern":  # "let [{x1,x2}={x1:1,x2:2}, y] = [a,b];" => add DFs: a --data--> x1 & a --data--> x2
                                lhs_object_pattern: Node = assignment_pattern.lhs()
                                rhs_item: Node = rhs.children[i]
                                for identifier1 in rhs_item.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                                    for identifier2 in lhs_object_pattern.get_all_identifiers_not_inside_a_as_iter(IGNORE_LHS_IDENTIFIERS_IN):
                                        data_flow_edges_added += identifier1.set_data_dependency(identifier2)

                    case "None":  # "let [x, , y] = [a,b,c];"
                        continue  # There's no data flow to create as there's nothing on the LHS!

                    case "RestElement":  # e.g.: "let [x, y, ...rest] = [a,b,c,d];"
                        rest_element: Node = lhs.children[i]
                        # interface RestElement {
                        #     argument: Identifier | BindingPattern;
                        # }
                        # where: type BindingPattern = ArrayPattern | ObjectPattern;
                        match rest_element.children[0].name:
                            case "Identifier":  # "let [x, y, ...rest] = [a,b,c,d];" => add DFs: c --data--> rest & d --data--> rest
                                rest_identifier: Node = rest_element.children[0]
                                for j in range(i, len(rhs.children)):
                                    for rhs_identifier in rhs.children[j].get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                                        data_flow_edges_added += rhs_identifier.set_data_dependency(rest_identifier)
                            case "ArrayPattern":  # "let [x, y, ...[z, w]] = [a,b,c,d];"  => add DFs: c --data--> z, ...
                                # NOTE: Again, both of the following two cases are possible:
                                #       1.) let [x, y, ...[z, w]] = [a,b,c,d,e];  // discards the value of e
                                #       2.) let [x, y, ...[z, w]] = [a,b,c];      // w becomes undefined
                                array_pattern: Node = rest_element.children[0]
                                for j in range(min(len(array_pattern.children), len(rhs.children)-i)):
                                    for identifier1 in rhs.children[i+j].get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                                        for identifier2 in array_pattern.children[j].get_all_identifiers_not_inside_a_as_iter(IGNORE_LHS_IDENTIFIERS_IN):
                                            data_flow_edges_added += identifier1.set_data_dependency(identifier2)
                            case "ObjectPattern":  # "let [x, y, ...{ length }] = [a,b,c,d];"
                                pass  # Not adding any data flows here; too obscure!

        elif lhs.name == "ArrayPattern":  # "let [x, y] = array;" => treat DF like "let x = array;" and "let y = array;"
            # For each identifier in the right-hand side...:
            for identifier1 in rhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                # ...add a data flow edge *from* that identifier *to* each identifier in the left-hand side:
                for identifier2 in lhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_LHS_IDENTIFIERS_IN):
                    data_flow_edges_added += identifier1.set_data_dependency(identifier2)
                    # => includes call: identifier1._data_dep_children.append(extremity=identifier2)

        elif lhs.name == "ObjectPattern" and rhs.name == "ObjectExpression":  # "const { a: cookies2, b: forty_two } = {a:cookies, b:42};" (the "const" is optional, note however that parentheses around the assignment will be required instead then!)
            # Note that, unlike in the example, the keys of the LHS and RHS might be in a different order!
            lhs_keys = [property_.children[0].attributes['name']
                        for property_ in lhs.children
                        if property_.name == "Property" and property_.children[0].name == "Identifier"]
            rhs_keys = [property_.children[0].attributes['name']
                        for property_ in rhs.children
                        if property_.name == "Property" and property_.children[0].name == "Identifier"]
            data_flow_keys = set.intersection(set(lhs_keys), set(rhs_keys))  # in the example: set("a", "b")
            for key in data_flow_keys:
                lhs_value = [property_.children[1]
                             for property_ in lhs.children
                             if property_.name == "Property" and len(property_.children) > 1
                                                             and property_.children[0].name == "Identifier"
                                                             and property_.children[0].attributes['name'] == key][0]
                rhs_value = [property_.children[1]
                             for property_ in rhs.children
                             if property_.name == "Property" and len(property_.children) > 1
                                                             and property_.children[0].name == "Identifier"
                                                             and property_.children[0].attributes['name'] == key][0]
                for identifier in rhs_value.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                    data_flow_edges_added += identifier.set_data_dependency(lhs_value)

        elif lhs.name == "ObjectPattern":  # "({url} = sender);" or "({url:url} = sender);"
            # Note that both "({url} = sender);" and "({url:url} = sender);" result in the same PDG being generated:
            # [1] [AssignmentExpression:"="] (2 children)
            #     [2] [ObjectPattern] (1 child)
            #         [3] [Property] (2 children)
            #             [4] [Identifier:"url"] (0 children)
            #             [5] [Identifier:"url"] (0 children)
            #     [6] [Identifier:"sender"] (0 children)
            #
            # Note that the RHS does not have to be an Identifier; even just within the Kim+Lee extension set, wee see
            # the RHS also being:
            #   * an AwaitExpression
            #   * a MemberExpression
            #   * a Literal
            #   * a CallExpression
            for rhs_identifier in rhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_RHS_IDENTIFIERS_IN):
                for lhs_identifier in lhs.get_all_identifiers_not_inside_a_as_iter(IGNORE_LHS_IDENTIFIERS_IN):
                    data_flow_edges_added += rhs_identifier.set_data_dependency(lhs_identifier)

        else:
            print(f"[Warning] Unknown type of {pdg.name} (LHS: {lhs.__class__}/{lhs.name}; "
                  f"RHS: {rhs.__class__})/{rhs.name} found in {pdg.get_file()}, line {pdg.get_line()}"
                  f" - possible missed data flow(s)")

    return data_flow_edges_added +\
        sum(add_missing_data_flow_edges_declarations_and_assignments(child) for child in pdg.children)


def add_missing_data_flow_edges_call_expressions(pdg: Node) -> int:
    """
    Adds missing data flows from `y` to `x` in CallExpressions like:

    * function foo(x) { ... }
      foo(y);

    * function foo(x) { ... }
      foo(42*y);

    * function foo(x=42) { ... }
      foo(y);

    * function foo(x, a) { ... }
      foo(y, b)

    * y.then((x) => { /* ... */ })

    * y.forEach((x) => console.log(x));

    * y.transaction("accounts").objectStore("accounts").get("Alice").addEventListener("success", (x) => {});

    Also handles data flows in IIFEs (Immediately Invoked Function Expressions) like from `a` to `x` in this one:

    * !function(x,y){}(a,b)

    Note how this function heavily relies upon (the correct functioning of) the
    Node.function_Identifier_get_FunctionDeclaration() method for resolving identifiers referencing functions to
    FunctionDeclarations!

    Parameters:
        pdg: the PDG (Program Dependence Graph), generated by DoubleX, to add the missing data flow edges to

    Returns:
        the number of data flow edges added to the given PDG, as an integer;
        edges that already existed before calling this function are *not* counted!
    """

    data_flow_edges_added = 0

    if pdg.name == "CallExpression" and len(pdg.children) > 1 and pdg.children[0].name == "Identifier":
        # For each `foo(y)` CallExpression, add a data flow edge from `y` to the `x` in `function foo(x) { ... }`
        #   when a function declaration for `foo` is found.
        # Likewise, for each `foo(y1, y2)` CallExpression, add a data flow edge from `y1` to `x1` and from `y2` to `x2`
        #   in `function foo(x1, x2) { ... }`, etc.
        # Note that in JavaScript it is possible to both supply too many *and* too few parameters to a function!
        #   => extra parameters will be ignored and missing parameters will become "undefined"
        #   => as a data flow needs two ends, we will add min(#params_call, #params_definition) data flows
        function_reference = pdg.children[0]  # "foo"
        function_declaration = function_reference.function_Identifier_get_FunctionDeclaration(False)  # `function foo(x) { ... }`
        if function_declaration is not None:  # some functions might be built-ins (e.g., parseInt()), imported from somewhere or created dynamically, and we can't find a declaration
            assert function_declaration.name == "FunctionDeclaration"
            no_of_params_in_call = len(pdg.children) - 1  # a CallExpression = 1 callee + N arguments (cf. Esprima docs)
            no_of_params_in_declaration = len(function_declaration.function_declaration_get_params())  # a FunctionDeclaration = M hoisted FunctionDeclarations + 1 id + N params + 1 body
            for param_index in range(min(no_of_params_in_call, no_of_params_in_declaration)):
                n_th_call_param = pdg.children[1 + param_index]
                n_th_declaration_param = function_declaration.function_declaration_get_nth_param(param_index)
                n_th_declaration_identifier = n_th_declaration_param.function_param_get_identifier()  # handles `function foo(x=42) { ... }` case (default parameter)
                if n_th_declaration_identifier is not None:
                    # Add a data flow edge for each identifier in the expression used as the parameter:
                    for identifier in n_th_call_param.get_all_identifiers():
                        # Add data flow edge:
                        data_flow_edges_added += identifier.set_data_dependency(n_th_declaration_identifier)  # y --data--> x
                    # => handles all of the following:
                    #    * `foo(y)` (i.e., n_th_call_param.name == "Identifier"),
                    #    * `foo(y=z)` (i.e., n_th_call_param.name == "AssignmentExpression"),
                    #    * `foo(42*y)` (i.e. n_th_call_param.name == "BinaryExpression").

        elif function_reference.attributes['name'] not in JAVASCRIPT_BUILT_IN_FUNCTIONS:  # ToDo: put logic into Node.function_Identifier_get_FunctionDeclaration() ?!
            if os.environ.get('WARN_FUNC_DEF_NOT_FOUND') == "yes":
                print(f"[Warning] declaration of function '{function_reference.attributes['name']}' not found (line "
                      f"{function_reference.get_line()}, file {function_reference.get_file()}), "
                      f"possible missing data flow edge(s)...")
                # todo: stop warning for functions that aren't declared but that we can still resolve, e.g., "sendResponse" !!!!!

    elif pdg.name == "CallExpression" and len(pdg.children) > 1 and pdg.children[0].name == "FunctionExpression":
        # For each IIFE, e.g.: "!function(x,y){}(a,b)", add data flows from `a` to `x` and from `b` to `y`:
        # [1] [Program] (1 child)
        # 	[2] [ExpressionStatement] (1 child)
        # 		[3] [UnaryExpression:"!"] (1 child)
        # 			[4] [CallExpression] (3 children)
        # 				[5] [FunctionExpression::{'generator': False, 'async': False, 'expression': False}] (3 children)
        # 					[6] [Identifier:"x"] (0 children)
        # 					[7] [Identifier:"y"] (0 children)
        # 					[8] [BlockStatement] (0 children)
        # 				[9] [Identifier:"a"] (0 children)
        # 				[10] [Identifier:"b"] (0 children)
        #
        # This will also handle more complex cases, e.g.:
        #   "!function(x=null,y,z){}(a+1,b)"

        function_expression: Node = pdg.children[0]
        assert function_expression.name == "FunctionExpression"  # because of check above

        no_of_params_in_call_expr: int = len(pdg.children) - 1  # a CallExpression = 1 callee + N arguments (cf. Esprima docs)
        no_of_params_in_func_expr: int = len(function_expression.arrow_function_expression_get_params())
        for param_index in range(min(no_of_params_in_call_expr, no_of_params_in_func_expr)):
            n_th_call_expr_param = pdg.children[1 + param_index]
            n_th_func_expr_param = function_expression.arrow_function_expression_get_nth_param(param_index)
            n_th_func_expr_identifier = n_th_func_expr_param.function_param_get_identifier()  # handles `function foo(x=42) { ... }` case (default parameter)
            if n_th_func_expr_identifier is not None:
                # Add a data flow edge for each identifier in the expression used as the parameter:
                for identifier in n_th_call_expr_param.get_all_identifiers():
                    # Add data flow edge:
                    data_flow_edges_added += identifier.set_data_dependency(n_th_func_expr_identifier)  # a --data--> x
                # => handles all of the following:
                #    * `foo(y)` (i.e., n_th_call_expr_param.name == "Identifier"),
                #    * `foo(y=z)` (i.e., n_th_call_expr_param.name == "AssignmentExpression"),
                #    * `foo(42*y)` (i.e. n_th_call_expr_param.name == "BinaryExpression").

    elif pdg.name == "CallExpression" and len(pdg.children) > 1 and pdg.children[0].name == "MemberExpression":
        # CallExpressions where the LHS is of callee is a MemberExpression, like `foo.bar(...)`:
        # interface CallExpression {
        #     callee: Expression | Import;
        #     arguments: ArgumentListElement[];
        # }
        # [CallExpression]
        #     [MemberExpression:"False"]
        #         [Identifier/MemberExpression]
        #         [Identifier]
        #     [...]
        #     ...
        callee_member_expression: Node = pdg.children[0]
        assert callee_member_expression.name == "MemberExpression"  # because of check above
        callee_lhs: Node = callee_member_expression.lhs()  # an Identifier or another MemberExpression
        callee_leftmost_identifier: Node = callee_member_expression.member_expression_get_leftmost_identifier()
        callee_rhs_identifier: Node = callee_member_expression.rhs()
        if callee_leftmost_identifier.name == "Identifier":
            arguments: List[Node] = pdg.children[1:]
            assert len(arguments) > 0  # because of len(pdg.children) > 1 check above

            # For CallExpressions like `foo.bar(y)`, ...
            #   1st: try to find the class that "foo" belongs to,
            #   2nd: try to find the class declaration,
            #   3rd: try to find the declaration of a method called "bar" inside that class declaration
            #   4th: add a data flow from `y` to the `x` parameter of the "bar(x)" method declaration from step 3
            if callee_lhs == callee_leftmost_identifier:
                pass  # ToDo

            # For CallExpressions like `foo.bar((y) => { /* ... */ })`,
            #   add a data flow from `foo` to `y`.
            # Common examples for this would be Promises and Arrays:
            # * `promise1.then((y) => { /* ... */ })`
            # * `array1.forEach((element) => console.log(element));`
            #
            # However, there are many more functions of this form
            #     (a lambda accessing all/some of an array's elements):
            # * `array1.map((element) => console.log(element));`
            # * `array1.filter((element) => {console.log(element); return true;});`
            # * `array1.reduce(...);`
            # * `array1.some(...);`
            # * `array1.every(...);`
            # * `array1.find(...);`
            # * `array1.sort(...);`
            #
            # Note that instead of `foo.bar`, the MemberExpressions might be longer, too, e.g. `t.data.data.forEach`:
            #   t.data.data.forEach(function(r) { /* ... */ })
            #
            # Note, however, that there might be many other function calls that look like this but where the
            #   arguments are not references to functions, take the following example:
            # * `Object.assign(target, source)` where both `target` and `source` are non-function objects!
            # => Therefore, resolving identifiers to function declarations might easily "fail" here
            #    w/o the need to worry:)
            for argument in arguments:  # for each "([a,b], [c,d]) => console.log(a,b,c,d)":
                if argument.name in ["FunctionExpression", "ArrowFunctionExpression"]:
                    for arrow_function_param in argument.arrow_function_expression_get_params():  # for each "[a,b]":
                        for identifier in arrow_function_param.function_param_get_identifiers():   # for each "a":
                            data_flow_edges_added += callee_leftmost_identifier.set_data_dependency(identifier)  # foo --data--> y
                elif argument.name == "Identifier":
                    function_declaration = argument.function_Identifier_get_FunctionDeclaration(False)
                    if function_declaration is not None:
                        assert function_declaration.name == "FunctionDeclaration"
                        for arrow_function_param in function_declaration.function_declaration_get_params():  # for each "[a,b]":
                            for identifier in arrow_function_param.function_param_get_identifiers():  # for each "a":
                                data_flow_edges_added += callee_leftmost_identifier.set_data_dependency(identifier)  # foo --data--> y

    return data_flow_edges_added +\
        sum(add_missing_data_flow_edges_call_expressions(child) for child in pdg.children)


def add_missing_data_flow_edges_standard_library_functions(pdg: Node) -> int:  # ToDo: create test cases
    """
    Some dataflows are non-obvious without knowing the semantics of certain functions from JavaScript's standard
    library.
    Adds missing data flows from `y` to `x` in CallExpressions like:

    * Object.assign(x, y)

    * Object.assign(x, y, a)

    * Object.assign(x, a, y)

    * Object.assign(x, y.foo());

    * Object.defineProperty(x, 'property1', {
          value: y,
          writable: false
      });

    * Object.defineProperties(x, {
          property1: {
            value: y,
            writable: true
          },
          property2: {
            value: z,
            writable:false
          }
      });

    Note that the following case is already handled by add_missing_data_flow_edges_declarations_and_assignments():

    * x = Object.assign({}, y)
    """

    data_flow_edges_added = 0

    # ##### ##### ##### ##### ##### Object.assign(): ##### ##### ##### ##### #####

    # Input: "Object.assign(x, y)"
    #
    # Output PDG:
    # [1] [Program] (1 child)
    # 	[2] [ExpressionStatement] (1 child)
    # 		[3] [CallExpression] (3 children)
    # 			[4] [MemberExpression:"False"] (2 children)
    # 				[5] [Identifier:"Object"] (0 children)
    # 				[6] [Identifier:"assign"] (0 children)
    # 			[7] [Identifier:"x"] (0 children)
    # 			[8] [Identifier:"y"] (0 children)
    object_assign_pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node.identifier("Object")
                    )
                    .child(
                        Node.identifier("assign")
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Object.assign() Pattern:\n{object_assign_pattern}")

    for pattern_match in pdg.find_pattern(object_assign_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):
        # Syntax
        #   (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign):
        #
        # Object.assign(target)
        # Object.assign(target, source1)
        # Object.assign(target, source1, source2)
        # Object.assign(target, source1, source2, /* ..., */ sourceN)

        assert pattern_match.name == "CallExpression"

        # pattern_match.children[0] is the "Object.assign" MemberExpression
        target = pattern_match.children[1]    # corresponds to the LHS of a regular assignment expression
        sources = pattern_match.children[2:]  # corresponds to the RHS of a regular assignment expression

        if target.name == "Identifier":
            for source in sources:
                for src_identifier in source.get_all_identifiers():
                    # Add a data flow edge: source --data--> target
                    data_flow_edges_added += src_identifier.set_data_dependency(target)
                    # => includes call: src_identifier._data_dep_children.append(extremity=target)

    # ##### ##### ##### ##### ##### Object.defineProperty(): ##### ##### ##### ##### #####

    # Input: "Object.defineProperty(x, 'property1', {value: y, writable: false});"
    #
    # Output PDG:
    # [1] [Program] (1 child)
    # 	[2] [ExpressionStatement] (1 child)
    # 		[3] [CallExpression] (4 children)
    # 			[4] [MemberExpression:"False"] (2 children)
    # 				[5] [Identifier:"Object"] (0 children)
    # 				[6] [Identifier:"defineProperty"] (0 children)
    # 			[7] [Identifier:"x"] (0 children)
    # 			[8] [Literal::{'raw': "'property1'", 'value': 'property1'}] (0 children)
    # 			[9] [ObjectExpression] (2 children)
    # 				[10] [Property] (2 children)
    # 					[11] [Identifier:"value"] (0 children)
    # 					[12] [Identifier:"y"] (0 children)
    # 				[13] [Property] (2 children)
    # 					[14] [Identifier:"writable"] (0 children)
    # 					[15] [Literal::{'raw': 'false', 'value': False}] (0 children)
    object_define_property_pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node.identifier("Object")
                    )
                    .child(
                        Node.identifier("defineProperty")
                    )
            )
            # .child(
            #     Node("ObjectExpression")
            #         .child(
            #             Node("Property")
            #                 .child(
            #                     Node.identifier("value")
            #                 )
            #         )
            # )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Object.defineProperty() Pattern:\n{object_define_property_pattern}")

    for pattern_match in pdg.find_pattern(object_define_property_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,  # IMPORTANT!
                                          allow_different_child_order=False):
        # Syntax (see
        #   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty):
        #
        # Object.defineProperty(obj, prop, descriptor)
        #
        # obj:        The object on which to define the property.
        # prop:       A string or Symbol specifying the key of the property to be defined or modified.
        # descriptor: The descriptor for the property being defined or modified.
        #             -> come in 2 main flavors: data descriptors and accessor descriptors:
        #                -> A data descriptor is a property with a value that may or may not be writable.
        #                -> An accessor descriptor is a property described by a getter-setter pair of functions.
        #                => A descriptor must be one of these two flavors; it cannot be both.
        #             -> Both data and accessor descriptors are objects. They share the following optional keys:
        #                -> "configurable" (Defaults to false.)
        #                -> "enumerable"   (Defaults to false.)
        #             -> A data descriptor also has the following optional keys:
        #                -> "value"    (Defaults to undefined.)
        #                -> "writable" (Defaults to false.)
        #             -> An accessor descriptor also has the following optional keys:
        #                -> "get" (Defaults to undefined.)
        #                -> "set" (Defaults to undefined.)
        #             -> If a descriptor doesn't have any of the value, writable, get, and set keys, it is treated as a
        #                data descriptor.
        #             -> If a descriptor has both [value or writable] and [get or set] keys, an exception is thrown.
        #
        # Return value: The object that was passed to the function, with the specified property added or modified.
        #
        # => Note that we only care about the data flow:
        #    value --data--> obj
        #    (or rather for each identifier occurring within `value`)

        assert pattern_match.name == "CallExpression"

        if len(pattern_match.children) < 4:
            # 0th child of CallExpression = "Object.defineProperty" MemberExpression
            # 1st child of CallExpression = obj parameter
            # 2nd child of CallExpression = prop parameter
            # 3rd child of CallExpression = descriptor parameter
            # + as for any JavaScript function, additional redundant parameters may be supplied w/o having any effect!
            print(f"[Warning] incorrect usage of Object.defineProperty(obj, prop, descriptor) found "
                  f"in line {pattern_match.get_line()} (file {pattern_match.get_file()}): "
                  f"supplied too few arguments: {len(pattern_match.children) - 1} instead of 3; no data flow added.")
            continue

        obj: Node = pattern_match.children[1]
        if obj.name == "MemberExpression":
            obj = obj.member_expression_get_leftmost_identifier()  # This method does not necessarily return an Identifier!!!
        if obj.name == "Identifier":
            descriptor: Node = pattern_match.children[3]
            if descriptor.name == "ObjectExpression":  # Object.defineProperty(x, 'prop1', {value: y, writable: false});
                for property_ in descriptor.children:
                    if (property_.name == "Property" and len(property_.children) == 2
                            and property_.lhs().name == "Identifier" and property_.lhs().attributes['name'] == "value"):
                        value = property_.rhs()  # "y" in the example above
                        for value_identifier in value.get_all_identifiers():
                            # Add a data flow edge: y --data--> x
                            data_flow_edges_added += value_identifier.set_data_dependency(obj)
                            # => includes call: value_identifier._data_dep_children.append(extremity=obj)

            elif descriptor.name == "Identifier":   # Object.defineProperty(x, 'property1', descriptor);
                # Add a data flow edge: descriptor --data--> x
                data_flow_edges_added += descriptor.set_data_dependency(obj)
                # => includes call: descriptor._data_dep_children.append(extremity=obj)

            else:
                print(f"[Warning] descriptor parameter found in Object.defineProperty(obj, prop, descriptor) call "
                      f"(in line {pattern_match.get_line()}, file {pattern_match.get_file()}) is neither an "
                      f"ObjectExpression nor an Identifier (rather it's a {descriptor.name}); no data flow added.")

        else:
            print(f"[Warning] obj parameter found in Object.defineProperty(obj, prop, descriptor) call "
                  f"(in line {pattern_match.get_line()}, file {pattern_match.get_file()}) is not an "
                  f"Identifier (rather it's a {obj.name}) (note that MemberExpressions are resolved to their leftmost "
                  f"Node); no data flow added.")

    # ##### ##### ##### ##### ##### Object.defineProperties(): ##### ##### ##### ##### #####

    # Input:
    #   "Object.defineProperties(x, {property1: {value: y, writable: true}, property2: {value: z, writable:false}});"
    #
    # Output PDG:
    # [1] [Program] (1 child)
    # 	[2] [ExpressionStatement] (1 child)
    # 		[3] [CallExpression] (3 children)
    # 			[4] [MemberExpression:"False"] (2 children)
    # 				[5] [Identifier:"Object"] (0 children)
    # 				[6] [Identifier:"defineProperties"] (0 children)
    # 			[7] [Identifier:"x"] (0 children)
    # 			[8] [ObjectExpression] (2 children)
    # 				[9] [Property] (2 children)
    # 					[10] [Identifier:"property1"] (0 children)
    # 					[11] [ObjectExpression] (2 children)
    # 						[12] [Property] (2 children)
    # 							[13] [Identifier:"value"] (0 children)
    # 							[14] [Identifier:"y"] (0 children)
    # 						[15] [Property] (2 children)
    # 							[16] [Identifier:"writable"] (0 children)
    # 							[17] [Literal::{'raw': 'true', 'value': True}] (0 children)
    # 				[18] [Property] (2 children)
    # 					[19] [Identifier:"property2"] (0 children)
    # 					[20] [ObjectExpression] (2 children)
    # 						[21] [Property] (2 children)
    # 							[22] [Identifier:"value"] (0 children)
    # 							[23] [Identifier:"z"] (0 children)
    # 						[24] [Property] (2 children)
    # 							[25] [Identifier:"writable"] (0 children)
    # 							[26] [Literal::{'raw': 'false', 'value': False}] (0 children)
    object_define_properties_pattern = \
        Node("CallExpression") \
            .child(
                Node("MemberExpression")
                    .child(
                        Node.identifier("Object")
                    )
                    .child(
                        Node.identifier("defineProperties")
                    )
            )\
            .child(
                Node("ObjectExpression")
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Object.defineProperties() Pattern:\n{object_define_properties_pattern}")

    for pattern_match in pdg.find_pattern(object_define_properties_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,  # IMPORTANT!
                                          allow_different_child_order=False):
        # Syntax (see
        #   https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties):
        #
        # Object.defineProperties(obj, props)
        #
        # obj:   The object on which to define or modify properties.
        # props: An object whose keys represent the names of properties to be defined or modified and whose values are
        #        objects describing those properties. Each value in props must be either a data descriptor or an
        #        accessor descriptor; it cannot be both (see Object.defineProperty() for more details).
        #
        # Return value: The object that was passed to the function.

        assert pattern_match.name == "CallExpression"

        if len(pattern_match.children) < 3:
            # 0th child of CallExpression = "Object.defineProperties" MemberExpression
            # 1st child of CallExpression = obj parameter
            # 2nd child of CallExpression = props parameter
            # + as for any JavaScript function, additional redundant parameters may be supplied w/o having any effect!
            print(f"[Warning] incorrect usage of Object.defineProperties(obj, props) found "
                  f"in line {pattern_match.get_line()} (file {pattern_match.get_file()}): "
                  f"supplied too few arguments: {len(pattern_match.children) - 1} instead of 2; no data flow added.")
            continue

        obj: Node = pattern_match.children[1]
        if obj.name == "Identifier":
            props: Node = pattern_match.children[2]
            if props.name == "ObjectExpression":
                for property_ in props.children:
                    if property_.name == "Property" and len(property_.children) == 2 and property_.rhs().name == "ObjectExpression":
                        for property__ in property_.rhs().children:
                            if (property__.name == "Property"
                                    and len(property_.children) == 2
                                    and property__.lhs().name == "Identifier"
                                    and property__.lhs().attributes['name'] == "value"):
                                value = property__.rhs()  # "y" in the example above
                                for value_identifier in value.get_all_identifiers():
                                    # Add a data flow edge: y --data--> x
                                    data_flow_edges_added += value_identifier.set_data_dependency(obj)
                                    # => includes call: value_identifier._data_dep_children.append(extremity=obj)

        else:
            print(f"[Warning] obj parameter found in Object.defineProperties(obj, props) call "
                  f"(in line {pattern_match.get_line()}, file {pattern_match.get_file()}) is not an "
                  f"Identifier; no data flow added.")

    return data_flow_edges_added


def add_missing_data_flow_edges_chrome_apis(pdg: Node) -> int:
    """
    Similar to add_missing_data_flow_edges_standard_library_functions() but for Chrome extension API functions
    instead of JavaScript standard library functions.

    Adds missing data flows from `y` to `x` in CallExpressions like:

    * chrome.scripting.executeScript({target: { tabId: tab.id }, func: (x) => {}, args: [y]});
    """

    data_flow_edges_added = 0

    # ##### ##### ##### ##### ##### chrome.scripting.executeScript(): ##### ##### ##### ##### #####

    # chrome.scripting.executeScript(
    #   injection: ScriptInjection,
    #   callback?: function,
    # )
    #
    # Description:
    #   Injects a script into a target context. By default, the script will be run at document_idle, or immediately if
    #   the page has already loaded. If the injectImmediately property is set, the script will inject without waiting,
    #   even if the page has not finished loading. If the script evaluates to a promise, the browser will wait for the
    #   promise to settle and return the resulting value.
    #
    # Parameters:
    #   injection: The details of the script which to inject.
    #   callback:  (results: InjectionResult[]) => void        // <== we do not care about this
    #
    # where:
    #
    #   ScriptInjection:
    #     Properties:
    #       args:              any[]           optional // The arguments to pass to the provided function.
    #                                                   // This is only valid if the func parameter is specified.
    #                                                   // These arguments must be JSON-serializable.
    #       files:             string[]        optional // Exactly one of files or func must be specified.
    #       injectImmediately: boolean         optional
    #       target:            InjectionTarget
    #       world:             ExecutionWorld  optional // enum: either "ISOLATED" or "MAIN"
    #       func:              void            optional // The func function looks like: () => {...}
    #                                                   // A JavaScript function to inject. This function will be
    #                                                   // serialized, and then deserialized for injection. This means
    #                                                   // that any bound parameters and execution context will be lost.
    #                                                   // Exactly one of files or func must be specified.
    #
    #   InjectionTarget:
    #     Properties:
    #       allFrames:   boolean  optional  // Whether the script should inject into all frames within the tab.
    #                                       // Defaults to false. This must not be true if frameIds is specified.
    #       documentIds: string[] optional  // The IDs of specific documentIds to inject into.
    #                                       // This must not be set if frameIds is set.
    #       frameIds:    number[] optional  // The IDs of specific frames to inject into.
    #       tabId:       number             // The ID of the tab into which to inject.
    #
    #   InjectionResult:
    #     Properties:
    #       documentId: string
    #       frameId: number
    #       result: any optional
    #
    # => https://developer.chrome.com/docs/extensions/reference/api/scripting
    # => https://developer.chrome.com/docs/extensions/reference/api/scripting#type-ScriptInjection
    # => https://developer.chrome.com/docs/extensions/reference/api/scripting#type-InjectionTarget
    # => https://developer.chrome.com/docs/extensions/reference/api/scripting#type-InjectionResult
    #
    # Example:
    #
    #                 chrome.scripting.executeScript({
    #                     target: { tabId: tab.id },
    #                     func: (uname) => {
    #                         const body = document.getElementsByTagName('body')[0];
    #                         const new_span = document.createElement('span');
    #                         new_span.innerHTML = 'Hello ' + uname + '!';
    #                         body.append(new_span);
    #                     },
    #                     args: [msg["user_name"]]
    #                 });
    #
    # Data flows to add:
    #   * from all identifiers in the i-th element of `args` to the i-th argument of the `func` function

    chrome_scripting_executeScript_pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node.identifier_regex("browser|chrome")
                            )
                            .child(
                                Node.identifier("scripting")
                            )
                    )
                    .child(
                        Node.identifier("executeScript")
                    )
            )\
            .child(
                Node("ObjectExpression")
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"chrome.scripting.executeScript() Pattern:\n{chrome_scripting_executeScript_pattern}")

    for pattern_match in pdg.find_pattern(chrome_scripting_executeScript_pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        assert pattern_match.name == "CallExpression"

        object_expression: Node = pattern_match.get_child("ObjectExpression")
        args_property: Node = object_expression.object_expression_get_property_value("args")
        func_property: Node = object_expression.object_expression_get_property_value("func")

        if args_property is not None and func_property is not None:  # both "args" and "func" are optional to specify!
            if args_property.name == "ArrayExpression":
                args_supplied: List[Node] = args_property.children
                try:
                    args_used: List[Node] = func_property.functional_arg_get_args(resolve_args_to_identifiers=True)

                    for i in range(min(len(args_supplied), len(args_used))):
                        arg_supplied: Node = args_supplied[i]  # in the example (see above): msg["user_name"]
                        arg_used: Node = args_used[i]  # in the example (see above): uname
                        if arg_used is not None:  # List returned by functional_arg_get_args() may return Nones for errors
                            for arg_supplied_identifier in arg_supplied.get_all_identifiers():
                                # Add data flow:
                                data_flow_edges_added += arg_supplied_identifier.set_data_dependency(arg_used)
                                # => includes call: arg_supplied._data_dep_children.append(extremity=arg_used)
                except TypeError:
                    # when func_property is neither an (Arrow)FunctionExpression nor an Identifier:
                    print(f"[Warning] 'func' argument of chrome.scripting.executeScript() call in "
                          f"line {func_property.get_line()} (file {func_property.get_file()}) "
                          f"has unknown form: {func_property.name}")
                except KeyError:
                    # when func_property is an Identifier but couldn't be resolved to a FunctionDeclaration:
                    print(f"[Warning] 'func' argument of chrome.scripting.executeScript() call in "
                          f"line {func_property.get_line()} (file {func_property.get_file()}) "
                          f"is an identifier that couldn't be resolved to a function: "
                          f"'{func_property.attributes['name']}'")

    return data_flow_edges_added
