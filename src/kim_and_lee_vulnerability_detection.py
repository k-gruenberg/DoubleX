import os
import logging
import timeit
import json
import re
from collections import defaultdict
from typing import List, Optional
import time
import traceback

import tldextract

import utility
from pdg_js.node import Node
from pdg_js.LHSException import LHSException
from pdg_js.RHSException import RHSException
from pdg_js.StaticEvalException import StaticEvalException
from DataFlow import DataFlow
from DoubleDataFlow import DoubleDataFlow
from vulnerability_detection import store_analysis_results, default

from multiprocessing import Process, Queue
import queue

PRINT_DEBUG = utility.PRINT_DEBUG


def queue_get_last(q: Queue):
    """
    As queues are FIFO (first-in-first-out), calling get() will retrieve the first element added to the queue.
    This function however returns the *last* item added to the queue (or `None` if the queue is empty).
    After this function has executed, the given queue will be empty.
    Non-blocking.
    """
    last = None
    while True:
        try:
            last = q.get(block=False)
        except queue.Empty:
            return last


def generate_pdg(whoami: str, file_path: str, benchmarks_dict: dict) -> Node:
    pdg = Node.pdg_from_file(file=file_path,
                             benchmarks=benchmarks_dict)

    if os.environ.get('PRINT_PDGS') == "yes":
        print()
        print(f"PDG ({whoami}):\n{pdg}")  # <pdg_js.node.Node object>
        print()

    return pdg


def analyze_bp(file_path: str, bp_benchmarks_dict_queue: Queue, bp_res_dict_queue: Queue):
    bp_benchmarks_dict = dict()
    bp_res_dict = dict()
    bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

    try:

        pdg_bp: Node = generate_pdg("bp", file_path, bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        bp_res_dict['code_stats'] = {
            "avg_name_len_identifiers": pdg_bp.average_identifier_length(),
            "avg_name_len_declared_vars": pdg_bp.average_declared_variable_name_length(),
            "avg_name_len_declared_funcs": pdg_bp.average_function_declaration_name_length(),
            "avg_name_len_declared_classes": pdg_bp.average_class_name_length(),
            "one_character_identifier_percentage": pdg_bp.one_character_identifier_percentage()
        }
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        bp_exfiltration_dangers = bp_res_dict['exfiltration_dangers'] = []
        bp_infiltration_dangers = bp_res_dict['infiltration_dangers'] = []

        # 4.1: Execute Privileged Browser APIs (non-UXSS / UXSS):
        detect_41_31_vuln_in_bp_no_uxss(pdg_bp=pdg_bp, results=bp_exfiltration_dangers, benchmarks=bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)
        detect_41_31_vuln_in_bp_uxss(pdg_bp=pdg_bp, results=bp_infiltration_dangers, benchmarks=bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        # 4.2: Write Sensitive Extension Data (UXSS):
        detect_42_32_vuln_in_bp(pdg_bp=pdg_bp, results=bp_infiltration_dangers, benchmarks=bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        # 4.3: Read Sensitive Extension Data (non-UXSS):
        #      => 3.1: exfiltration via extension message
        #      => 3.2: exfiltration via extension storage
        detect_43_31_vuln_in_bp(pdg_bp=pdg_bp, results=bp_exfiltration_dangers, benchmarks=bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)
        detect_43_32_vuln_in_bp(pdg_bp=pdg_bp, results=bp_exfiltration_dangers, benchmarks=bp_benchmarks_dict)
        bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        # Other violations of 3.1 (Extension Message Authentication) w/o privileged API access:
        if os.environ.get('INCLUDE_31_VIOLATIONS_WITHOUT_PRIVILEGED_API_ACCESS') == "yes":
            bp_31_violations_without_sensitive_api_access = \
                bp_res_dict['31_violations_without_sensitive_api_access'] = []
            detect_31_vuln_in_bp(pdg_bp=pdg_bp,
                                 results=bp_31_violations_without_sensitive_api_access,
                                 benchmarks=bp_benchmarks_dict)
            bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)

        # Possible candidates for extension-storage-based 4.3 vulnerabilities (Read Sensitive Extension Data):
        bp_res_dict["extension_storage_accesses"] = get_extension_storage_accesses(
            pdg=pdg_bp,
            is_cs=False,
            benchmarks=bp_benchmarks_dict,
            storage_areas="local|sync|managed",
            # * Note that "storage.local" and "storage.sync" are equivalent when syncing is disabled.
            # * Note that, by default, "storage.session" is not exposed to content scripts, therefore, we shall not
            #   worry about what the BP puts there unless we explicitly see "storage.session" accessed in the CS (see
            #   below)!!!
            # => https://developer.chrome.com/docs/extensions/reference/api/storage#storage_areas
        )

    except Exception as e:
        print(traceback.format_exc())
        if "crashes" not in bp_benchmarks_dict:
            bp_benchmarks_dict["crashes"] = list()
        bp_benchmarks_dict["crashes"].append(f"Python Exception during BP analysis: {repr(e)}")

    bp_benchmarks_dict_queue.put(bp_benchmarks_dict), bp_res_dict_queue.put(bp_res_dict)


def analyze_cs(file_path: str, cs_benchmarks_dict_queue: Queue, cs_res_dict_queue: Queue):
    cs_benchmarks_dict = dict()
    cs_res_dict = dict()
    cs_benchmarks_dict_queue.put(cs_benchmarks_dict), cs_res_dict_queue.put(cs_res_dict)

    try:

        pdg_cs: Node = generate_pdg("cs", file_path, cs_benchmarks_dict)
        cs_benchmarks_dict_queue.put(cs_benchmarks_dict), cs_res_dict_queue.put(cs_res_dict)

        cs_res_dict['code_stats'] = {
            "avg_name_len_identifiers": pdg_cs.average_identifier_length(),
            "avg_name_len_declared_vars": pdg_cs.average_declared_variable_name_length(),
            "avg_name_len_declared_funcs": pdg_cs.average_function_declaration_name_length(),
            "avg_name_len_declared_classes": pdg_cs.average_class_name_length(),
            "one_character_identifier_percentage": pdg_cs.one_character_identifier_percentage()
        }
        cs_benchmarks_dict_queue.put(cs_benchmarks_dict), cs_res_dict_queue.put(cs_res_dict)

        cs_exfiltration_dangers = cs_res_dict['exfiltration_dangers'] = []
        cs_infiltration_dangers = cs_res_dict['infiltration_dangers'] = []

        # 4.2: Write Sensitive Extension Data (UXSS):
        detect_42_32_vuln_in_cs(pdg_cs=pdg_cs, results=cs_infiltration_dangers, benchmarks=cs_benchmarks_dict)
        cs_benchmarks_dict_queue.put(cs_benchmarks_dict), cs_res_dict_queue.put(cs_res_dict)

        # Possible candidates for extension-storage-based 4.3 vulnerabilities (Read Sensitive Extension Data):
        cs_res_dict["extension_storage_accesses"] = get_extension_storage_accesses(
            pdg=pdg_cs,
            is_cs=True,
            benchmarks=cs_benchmarks_dict,
            storage_areas="local|sync|session|managed",
            # * Note that, by default, "storage.session" is not exposed to content scripts, therefore, it will be all
            #   the more interesting if it *is* accessed by the CS!
        )

    except Exception as e:
        print(traceback.format_exc())
        if "crashes" not in cs_benchmarks_dict:
            cs_benchmarks_dict["crashes"] = list()
        cs_benchmarks_dict["crashes"].append(f"Python Exception during CS analysis: {repr(e)}")

    cs_benchmarks_dict_queue.put(cs_benchmarks_dict), cs_res_dict_queue.put(cs_res_dict)


def analyze_extension(cs_path, bp_path, json_analysis=None, pdg=False, chrome=True, war=False,
                      json_messages=None, json_apis='permissions', manifest_path=None, return_result=True,
                      store_result_as_json_file=True, print_result=False):
    # Note pdg=True if the PDGs have already been generated!

    res_dict = dict()
    extension_path = res_dict['extension'] = os.path.dirname(cs_path)
    benchmarks = res_dict['benchmarks'] = dict()
    messages_dict = dict()

    if manifest_path is None:
        manifest_path = os.path.join(extension_path, 'manifest.json')

    # cf. check_permissions.py:permission_check() and check_permissions.py:permission_check_v3():
    try:
        manifest = json.load(open(manifest_path))
        res_dict['manifest_version'] = manifest['manifest_version']
        if 'content_scripts' in manifest:
            urls = [cs['matches'] for cs in manifest['content_scripts']]
            res_dict['content_script_injected_into'] = [x for xs in urls for x in xs]  # flatten list of lists of URLs
        else:
            res_dict['content_script_injected_into'] = []
    except FileNotFoundError:
        logging.critical('No manifest file found in %s', manifest_path)

    # Start 1 process generating the BP PDG:
    bp_benchmarks_dict_queue = Queue(maxsize=16)
    bp_res_dict_queue = Queue(maxsize=16)
    bp_process = Process(target=analyze_bp, args=[bp_path, bp_benchmarks_dict_queue, bp_res_dict_queue])
    bp_process.start()

    # Start 1 process generating the CS PDG:
    cs_benchmarks_dict_queue = Queue(maxsize=16)
    cs_res_dict_queue = Queue(maxsize=16)
    cs_process = Process(target=analyze_cs, args=[cs_path, cs_benchmarks_dict_queue, cs_res_dict_queue])
    cs_process.start()

    # Wait until either both BP and CS analysis have finished, or until a timeout occurs:
    start_time = time.time()
    timeout: int = int(os.environ['TIMEOUT'])  # (in seconds)
    while time.time() - start_time < timeout:
        bp_process.join(timeout=3)
        cs_process.join(timeout=3)

        if not bp_process.is_alive() and not cs_process.is_alive():  # both have finished: stop waiting
            break

    # After timeout, if any process is still alive, terminate it; otherwise collect the result:

    if bp_process.is_alive():
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] "
              f"Analyzing BP '{bp_path}' timed out, terminating process...")
        bp_process.terminate()
        if 'crashes' not in benchmarks:
            benchmarks['crashes'] = []
        benchmarks['crashes'].append('bp-analysis-timeout')
    # Whether there was a timeout or not, we retrieve the (possibly partial) results:
    benchmarks["bp"] = queue_get_last(bp_benchmarks_dict_queue)
    res_dict["bp"] = queue_get_last(bp_res_dict_queue)

    if cs_process.is_alive():
        print(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] "
              f"Analyzing CS '{cs_path}' timed out, terminating process...")
        cs_process.terminate()
        if 'crashes' not in benchmarks:
            benchmarks['crashes'] = []
        benchmarks['crashes'].append('cs-analysis-timeout')
    # Whether there was a timeout or not, we retrieve the (possibly partial) results:
    benchmarks["cs"] = queue_get_last(cs_benchmarks_dict_queue)
    res_dict["cs"] = queue_get_last(cs_res_dict_queue)

    if print_result or PRINT_DEBUG:
        print(json.dumps(res_dict, indent=4, sort_keys=False, default=default, skipkeys=True))
    if store_result_as_json_file:
        store_analysis_results(extension_path, json_analysis, json_messages,
                               res_dict, messages_dict, outfile_name="analysis_renderer_attacker.json")
    if return_result:
        return res_dict


def get_all_response_identifiers(pdg: Node,
                                 call_expr_patterns: List[Node],
                                 callback_parameter_index: int,
                                 resolve_function_references=True) -> List[Node]:
    """
    Some Chrome API functions return a Promise but also provide a callback parameter for compatability.
    Notable examples of this are:
        - chrome.cookies.get(details: CookieDetails, callback?: function)
          => https://developer.chrome.com/docs/extensions/reference/api/cookies#method-get
        - chrome.cookies.getAll(details: object, callback?: function)
          => https://developer.chrome.com/docs/extensions/reference/api/cookies#method-getAll
        - StorageArea.get(keys?: string | string[] | object, callback?: function),
          e.g., chrome.storage.local.get(), or chrome.storage.sync.get()
          => https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea

    This function retrieves the response identifiers, no matter whether the callback parameter is used or
    whether .then() is being called on the returned Promise; for example the "cookies" Identifier is returned in
    both of the following two cases:
    (1) chrome.cookies.getAll({}, (cookies) => { sendResponse(cookies); });
    (2) chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });

    This function extracts common logic from
    get_all_cookie_response_identifiers() and get_all_storage_response_identifiers().

    Parameters:
        pdg: the PDG (or, maybe, part of the PDG) in which to perform the search
        call_expr_patterns: a pattern matching the CallExpressions you desire;
                  identifier names will be matched but literals and operators won't be,
                  additional children will be allowed but no different child order
        callback_parameter_index: the index of the callback parameter (*if* present);
                                  1 in the examples given above (as the callback is the 2nd parameter)
        resolve_function_references: whether to resolve function references/identifiers; defaults to True
    """
    result = []
    for pattern in call_expr_patterns:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # should be irrelevant
                                              match_operators=False,  # should be irrelevant
                                              allow_additional_children=True,
                                              allow_different_child_order=False):

            assert pattern_match.name == "CallExpression"

            no_of_args = len(pattern_match.call_expression_get_all_arguments())
            uses_callback = callback_parameter_index < no_of_args

            if uses_callback:  # uses callback (MV2 backwards compatibility) instead of Promises, e.g.: chrome.cookies.get({}, (cookie) => { /* ... */ });

                # ToDo: handle ".bind(this)" being called on the (Arrow)FunctionExpression passed !!!!!

                if pattern_match.has_child("FunctionExpression"):  # case 1: FunctionExpression:
                    function_expr: Node = pattern_match.get_child("FunctionExpression")
                    response_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if response_parameter is not None:
                        cookie_identifier = response_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("ArrowFunctionExpression"):  # case 2: ArrowFunctionExpression:
                    function_expr: Node = pattern_match.get_child("ArrowFunctionExpression")
                    response_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if response_parameter is not None:
                        cookie_identifier = response_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("Identifier") and resolve_function_references:  # case 3: Identifier:
                    # Example:
                    #         function msg_handler(msg, sender, sendResponse) {
                    #             function cookies_handler(cookies) {
                    #                 sendResponse(cookies);
                    #             }
                    #
                    #             chrome.cookies.getAll({}, cookies_handler);
                    #             return true;
                    #         }
                    #
                    #         chrome.runtime.onMessage.addListener(msg_handler);
                    function_reference = pattern_match.get_child("Identifier")
                    function_declaration = function_reference.function_Identifier_get_FunctionDeclaration(True)
                    if function_declaration is None:
                        print(f"[Warning] couldn't resolve function reference '{function_reference.attributes['name']}' "
                              f"in line {function_reference.get_line()}, file {function_reference.get_file()}, in "
                              f"chrome.cookies.get()/getAll() call!")
                    else:
                        assert function_declaration.name == "FunctionDeclaration"
                        # [1] [FunctionDeclaration] (3 children) --e--> [4]
                        # 			[2] [Identifier:"cookies_handler"] (0 children) --data--> [...]
                        # 			[3] [Identifier:"cookies"] (0 children) --data--> [...]
                        # 			[4] [BlockStatement] (1 child) --e--> [5]
                        # Note that one cannot simply take index X here as hoisted functions can create arbitrarily many
                        #   more children inside a FunctionDeclaration, e.g.: "function foo() { function bar() {} }":
                        # [1] [FunctionDeclaration] (3 children) --e--> [4] --e--> [3]
                        # 		[4] [FunctionDeclaration] (2 children) --e--> [6]
                        # 			[5] [Identifier:"bar"] (0 children)
                        # 			[6] [BlockStatement] (0 children)
                        # 		[2] [Identifier:"foo"] (0 children)
                        # 		[3] [BlockStatement] (0 children)
                        function_declaration_params = function_declaration.function_declaration_get_params()
                        if len(function_declaration_params) >= 1:
                            response_parameter = function_declaration_params[0]
                            # Note that the cookies_handler might also contain more redundant parameters, the cookie(s)
                            #   parameter however will always be at index 1.

                            # A FunctionParameter of a FunctionDeclaration may be one of the following types:
                            #     type FunctionParameter = AssignmentPattern | Identifier | BindingPattern;
                            # where:
                            #     type BindingPattern = ArrayPattern | ObjectPattern;
                            #
                            # * function cookies_handler(cookies) { ... }
                            # * function cookies_handler(cookies=null) { ... }
                            # * function cookies_handler({a:b, x:y}) { ... }
                            # * function cookies_handler([x,y]) { ... }
                            #
                            # The function_param_get_identifier() and function_param_get_identifiers() methods however
                            #   handle this for us!
                            response_identifier: Optional[Node] = response_parameter.function_param_get_identifier()  # e.g. `cookies`, for both `cookies` and `cookies=null`
                            if response_identifier is not None:
                                result.append(response_identifier)
                            else:
                                print(f"[Warning] Cookie/Storage response parameter "
                                      f"in line {response_parameter.get_line()}, file "
                                      f"{response_parameter.get_file()} has unexpected form: {response_parameter.name}")
                            # ToDo: handle cookie destructurings using cookie_parameter.function_param_get_identifiers() ?!

                else:
                    print(f"[Warning] couldn't identify cookie/storage response identifier for "
                          f"{pattern_match.call_expression_get_full_function_name()}() call "
                          f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                          f"function call has no function expression, "
                          f"no arrow function expression and no identifier child")

            else:  # uses Promise instead of callback, e.g.: chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });

                all_then_calls = pattern_match.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
                for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
                    result.extend(then_call.then_call_get_param_identifiers())

    return result


# chrome.cookies.getAll(
#   details: object,
#   callback?: function,    // (cookies: Cookie[]) => void
# )
# // Returns: Promise<Cookie[]>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
#
# chrome.cookies.get(
#   details: CookieDetails,
#   callback?: function,       // (cookie?: Cookie) => void
# )
# // Returns: Promise<Cookie | undefined>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
#
# => https://developer.chrome.com/docs/extensions/reference/api/cookies
COOKIES_PATTERN =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(Node.identifier_regex("browser|chrome"))  # ToDo: handle programmer aliasing chrome.cookies.getAll
                            .child(Node.identifier("cookies"))
                    )
                    .child(
                        Node.identifier_regex("get|getAll")
                    )
            )

COOKIE_PATTERNS = [COOKIES_PATTERN]


def get_all_cookie_response_identifiers(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "cookie" (or arbitrarily named) identifiers coming from a
    ```
    chrome.cookies.getAll({}, function(cookies) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.getAll({}, (cookies) => { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, function(cookie) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, (cookie) => { /* ... */ });
    ```
    call.
    All these identifiers potentially contain very sensitive cookie data and shall not get into a
    content-script-accessible sink w/o proper authentication of the content script's URL!

    Also, one can also use the Promise returned by chrome.cookies.getAll()/get(); either by awaiting it:
    ```
    (async () => {
        let cookies = await chrome.cookies.getAll({});
        sendResponse(cookies);
    })();
    ```
    ...or one can call .then() on the returned Promise:
    ```
    chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });
    ```
    """
    return get_all_response_identifiers(
        pdg=pdg,
        call_expr_patterns=COOKIE_PATTERNS,
        callback_parameter_index=1,
        resolve_function_references=resolve_function_references
    )


def get_all_cookie_function_identifiers(pdg: Node) -> List[Node]:
    result = []
    for pattern in COOKIE_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,  # necessary!
                                              allow_different_child_order=False):
            assert pattern_match.name == "CallExpression"
            function_identifier = pattern_match.get_child("MemberExpression").rhs()  # "get" or "getAll"
            result.append(function_identifier)
    return result


STORAGE_GET_PATTERN =\
    Node("CallExpression")\
        .child(
            Node("MemberExpression")
                .child(
                    Node("MemberExpression")
                        .child(
                            Node("MemberExpression")
                                .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.storage
                                # e.g., "chrome", "browser", "this.browser", "this._namespace", ...
                                # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                # calling "runtime.onMessage" doesn't work!
                                .child(Node.identifier("storage"))
                        )
                        .child(Node.identifier_regex("local|sync"))
                        # Note: When syncing is disabled, "storage.sync" behaves exactly like "storage.local"!
                        # Note: there are also the "manged" and "session" StorageAreas, however the "managed"
                        #       StorageArea is read-only for the entire extension, and the "session" StorageArea
                        #       is not exposed to content scripts by default;
                        #       therefore, both are inaccessible to the renderer attacker!
                        # => https://developer.chrome.com/docs/extensions/reference/api/storage
                )
                .child(Node.identifier("get"))
        )


STORAGE_GET_PATTERNS = [STORAGE_GET_PATTERN]


def get_all_storage_response_identifiers(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "result" (or arbitrarily named) identifiers coming from a
    ```
    chrome.storage.local.get(["key"]).then((result) => {});
    ```
    or
    ```
    chrome.storage.local.get(["key"]).then(function (result) {});
    ```
    or
    ```
    chrome.storage.local.get('key', (result) => {});
    ```
    or
    ```
    chrome.storage.local.get('key', function (result) {});
    ```
    call.
    All these identifiers contain data under control of the content script and therefore a renderer attacker;
    they shall not be put into other websites un-sanitized, this would create a UXSS vector!

    Note: instead of "storage.local", "storage.sync" may be used as well!
    """
    return get_all_response_identifiers(
        pdg=pdg,
        call_expr_patterns=STORAGE_GET_PATTERNS,
        callback_parameter_index=1,
        resolve_function_references=resolve_function_references
    )


def get_all_storage_get_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all "get" Identifiers from *.storage.local.get() or *.storage.sync.get() calls
    (e.g., "chrome.storage.local.get()").

    References:
        https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea
    """
    result = []
    for pattern in STORAGE_GET_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,  # necessary!
                                              allow_different_child_order=False):
            assert pattern_match.name == "CallExpression"
            function_identifier = pattern_match.get_child("MemberExpression").rhs()  # "get"
            result.append(function_identifier)
    return result


def get_all_fetch_response_identifiers(pdg: Node, all_fetch_identifiers=None) -> List[Node]:
    """
    Returns all "response1", "response2", "response3", etc. (or arbitrarily named) identifiers coming from a
    ```
    fetch('https://example.com/')
        .then((response1) => response1.json())
        .then((response2, response3) => console.log(response2, response3));
    ```
    call.

    Note that while, in the example above, there are data flows from "response1", "response2" and "response3",
    there is no outgoing data flow from "fetch"; cf. get_all_fetch_identifiers() for cases where that might be of
    interest!

    Note that because of "then"-chaining, the returned identifiers may be of any arbitrary data type!

    Note that, as each then() call returns another Promise, the example above might also be the RHS of an
    AssignmentExpression!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker
        all_fetch_identifiers: optional, the result of `get_all_fetch_identifiers(pdg=pdg)`
                               (to avoid duplicate code calling)

    Returns:
        a list of Identifier Nodes, the concatenated (lambda/function) arguments of each then() call
    """
    if all_fetch_identifiers is None:
        all_fetch_identifiers = get_all_fetch_identifiers(pdg=pdg)

    result = []

    for fetch_identifier in all_fetch_identifiers:
        call_expression = fetch_identifier.get_parent(["CallExpression"])
        all_then_calls = call_expression.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
        for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
            result.extend(then_call.then_call_get_param_identifiers())

    return result


def get_all_fetch_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all "fetch" identifiers coming from the 0th child of a CallExpression, such as
    ```
    response1 = await fetch(url);
    ```
    or
    ```
    response1 = fetch(url);
    ```
    or
    ```
    response1 = yield fetch(url, options);
    ```
    call.

    Note that in all of these cases there is a --data--> flow edge from the "fetch" identifier to the "response1"
    identifier, meaning you can directly follow any data flow from the returned "fetch" identifiers!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker

    Returns:
        a list of Identifier Nodes whose name is "fetch"
    """
    pattern1 =\
        Node("CallExpression")\
            .child(
                Node.identifier("fetch")  # ToDo: handle aliasing of "fetch", e.g., "foobar = fetch; foobar(...);"
            )

    patterns = [pattern1]

    if os.environ.get('PRINT_PDGS') == "yes":
        for i in range(len(patterns)):
            pattern = patterns[i]
            print(f"Fetch Identifier Pattern #{i + 1}:\n{pattern}")

    result = []
    for pattern in patterns:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,
                                              allow_different_child_order=False):
            if (len(pattern_match.children) in [2, 3]  # either "fetch(resource)" or "fetch(resource, options)"
                and pattern_match.children[0].name == "Identifier"
                    and pattern_match.children[0].attributes['name'] == "fetch"):  # ensure it's not, for example, "foo(fetch)"
                result.append(pattern_match.children[0])  # "fetch"
    return result


def get_all_chrome_runtime_onMessage_addListener_args(pdg: Node, arg_index: int,
                                                      resolve_function_references=True) -> List[Node]:
    """
    Extracts common code logic from get_all_sendResponse_sinks() and get_all_msg_sources().
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    # e.g., "chrome", "browser", "this.browser",
                                    #       "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                                    # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                    # calling "runtime.onMessage" doesn't work!
                                    .child(Node.identifier("runtime"))
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )
            #.child(
            #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
            #)

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"chrome.runtime.onMessage.addListener() Pattern #1:\n{pattern}")

    result = []

    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        assert pattern_match.name == "CallExpression"
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onMessage.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        callback_arg: Node = args[0]
        try:
            # listener arguments are:
            #   0. message
            #   1. sender
            #   2. sendResponse
            # (programmer might add redundant additional arguments, but they don't matter)
            result.append(callback_arg.functional_arg_get_arg(arg_index, resolve_arg_to_identifier=True))
        except IndexError:
            # There is no argument at index `arg_index` => there is nothing to return.
            # The programmer may easily leave out trailing parameters: either (message, sender) or just (message).
            # An example for this would be: chrome.runtime.onMessage.addListener((message) => { /* ... */ });
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onMessage.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify {arg_index}-th argument of chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return result


def get_all_sendResponse_sinks(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "sendResponse" (or arbitrarily named) identifiers coming from a
    ```
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { /* ... */ });
    ```
    or
    ```
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { /* ... */ });
    ```
    call.
    All these identifiers describe content-script-accessible sinks!
    """
    # listener arguments are:
    #   0. message
    #   1. sender
    #   2. sendResponse <-----
    # (programmer might add redundant additional arguments, but they don't matter)
    return get_all_chrome_runtime_onMessage_addListener_args(pdg=pdg,
                                                             arg_index=2,
                                                             resolve_function_references=resolve_function_references)


def get_all_msg_sources(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "message" (or arbitrarily named) identifiers coming from a
    ```
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { /* ... */ });
    ```
    or
    ```
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { /* ... */ });
    ```
    call.
    All these identifiers describe content-script-controlled sources!
    """
    # listener arguments are:
    #   0. message      <-----
    #   1. sender
    #   2. sendResponse
    # (programmer might add redundant additional arguments, but they don't matter)
    return get_all_chrome_runtime_onMessage_addListener_args(pdg=pdg,
                                                             arg_index=0,
                                                             resolve_function_references=resolve_function_references)


def get_all_port_postMessage_sinks(pdg: Node) -> List[Node]:
    """
    Returns all "port.postMessage" sinks, referring to the "postMessage" method of a port given by
    chrome.runtime.onConnect.addListener(); an example:

    ```
    chrome.runtime.onConnect.addListener(port => {
        port.postMessage("pong");
    });
    ```
    => cf. /oocalimimngaihdkbihfgmpkcpnmlaoa-3.4.0-Crx4Chrome.com/background.js ("Netflix Party is now Teleparty")

    Returns:
        a list of MemberExpressions (LHS = identifier with data flow from "port"; RHS = "postMessage" Identifier)
        whose parents are CallExpressions
    """
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=de#event-onConnect:
    # chrome.runtime.onConnect.addListener(
    #   callback: function,                    // (port: Port) => void
    # )
    #
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=en#type-Port:
    # * Port.name:                             string                  => irrelevant
    # * Port.onDisconnect(callback: function): Event<functionvoidvoid> => irrelevant, no data flow
    # * Port.onMessage(callback: function):    Event<functionvoidvoid> => will be relevant for INFILTRATION/UXSS dangers
    # * Port.sender:                           MessageSender           => relevant for auth check: origin, tab, url
    # * Port.disconnect():                     void                    => irrelevant, no data flow
    # * Port.postMessage(message: any):        void                    => relevant here, for EXFILTRATION dangers!!!
    pattern = \
        Node("CallExpression") \
            .child(
            Node("MemberExpression")
            .child(
                Node("MemberExpression")
                .child(
                    Node("MemberExpression")
                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onConnect
                    # e.g., "chrome", "browser", "this.browser", "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                    .child(Node.identifier("runtime"))
                )
                .child(Node.identifier("onConnect"))
            )
            .child(
                Node.identifier("addListener")
            )
        )
    # .child(
    #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
    # )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"onConnect Pattern #1:\n{pattern}")

    postMessage_sinks = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        # pattern_match = "chrome.runtime.onConnect.addListener(port => { port.postMessage("pong"); });"
        assert pattern_match.name == "CallExpression"
        # args = ["port => { port.postMessage("pong"); }"]
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onConnect.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        # callback_arg = "port => { port.postMessage("pong"); }"
        callback_arg: Node = args[0]
        try:
            # port_argument = "port"
            port_argument: Node = callback_arg.functional_arg_get_arg(0, resolve_arg_to_identifier=True)
            port_data_flows: List[DataFlow] = DataFlow.all_continued_beginning_at(port_argument)
            for port_data_flow in port_data_flows:
                for identifier_node in port_data_flow.nodes:
                    # "port.postMessage(x);" becomes:
                    # [1] [CallExpression] (2 children)
                    # 	[2] [MemberExpression:"False"] (2 children)      <----- return value
                    # 		[3] [Identifier:"port"] (0 children)         <----- identifier_node
                    # 		[4] [Identifier:"postMessage"] (0 children)
                    # 	[5] [Identifier:"x"] (0 children)
                    if (identifier_node.parent.name == "MemberExpression" # ToDo: handle the 2 different cases of MemberExpressions, i.e. also handle port['postMessage']
                            and identifier_node.grandparent().name == "CallExpression"
                            and identifier_node.parent.lhs() == identifier_node
                            and identifier_node.parent.rhs().name == "Identifier"
                            and identifier_node.parent.rhs().attributes['name'] == "postMessage"):
                        # found "port.postMessage(...);" call, return the "port.postMessage" MemberExpression:
                        postMessage_sinks.append(identifier_node.parent)
        except IndexError:
            # There is no argument at index no. 0 => there is no "port" argument to use further.
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onConnect.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify port sink for chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return postMessage_sinks


def get_all_document_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all Identifiers named "document" within the given PDG.
    """
    return [identifier for identifier in pdg.get_all_as_iter("Identifier")
            if identifier.attributes['name'] == "document"]


def get_all_chrome_tabs_executeScript_sinks(pdg: Node) -> List[Node]:
    """
    Returns all "chrome.tabs.executeScript" MemberExpression sinks that

    Note that the chrome.tabs.executeScript() API is a deprecated MV2 API!

    Example:
    ```
    chrome.tabs.executeScript(
        tab_id,
        {code: my_code}
    );
    ```

    Returns:
        a list of all "chrome.tabs.executeScript" MemberExpressions that are part of a CallExpression which also
        contains an ObjectExpression parameter with a Property named "code".
    """

    # https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript:
    #
    # chrome.tabs.executeScript(
    #   tabId?: number,
    #   details: InjectDetails,   // <=== the sink that we care about!!!
    #   callback?: function,      // (result?: any[]) => void
    # )
    #
    # Returns: Promise<any[] | undefined>
    #          Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
    #          You cannot use both on the same function call.
    #          The promise resolves with the same type that is passed to the callback.
    #
    # where:
    #   tabId: The ID of the tab in which to run the script; defaults to the active tab of the current window.
    #   details: Details of the script to run.
    #            Either the code or the file property must be set, but both may not be set at the same time.
    #   callback: The callback parameter looks like: (result?: any[]) => void
    #             where: result: The result of the script in every injected frame.
    #
    # https://developer.chrome.com/docs/extensions/reference/api/extensionTypes#type-InjectDetails:
    #
    # InjectDetails:
    #   Details of the script or CSS to inject.
    #   Either the code or the file property must be set, but both may not be set at the same time.
    #   Properties:
    #     allFrames: boolean optional
    #     code: string optional              // <=== Chrome docs even explicitly warn about the XSS danger here!!!
    #     cssOrigin: CSSOrigin optional
    #     file: string optional
    #     frameId: number optional
    #     matchAboutBlank: boolean optional
    #     runAt: RunAt optional

    # Example PDG (taken from the "ClassLink OneClick Extension" code):
    # [522] [CallExpression] (3 children)
    #        [523] [MemberExpression:"False"] (2 children)
    #            [524] [MemberExpression:"False"] (2 children)
    #                [525] [Identifier:"chrome"] (0 children)
    #                [526] [Identifier:"tabs"] (0 children)
    #            [527] [Identifier:"executeScript"] (0 children)
    #        [528] [Identifier:"n"] (0 children)
    #        [529] [ObjectExpression] (1 child)
    #            [530] [Property] (2 children)
    #                [531] [Identifier:"code"] (0 children)
    #                [532] [Identifier:"f"] (0 children)      // <----- has incoming data flows

    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node.identifier_regex("browser|chrome")
                            )
                            .child(
                                Node.identifier("tabs")
                            )
                    )
                    .child(
                        Node.identifier("executeScript")
                    )
            )\
            .child(
                Node("ObjectExpression")
                    .child(
                        Node("Property")
                            .child(
                                Node.identifier("code")
                            )
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"chrome.tabs.executeScript() code Pattern #1:\n{pattern}")

    code_sinks: List[Node] = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,  # IMPORTANT!
                                          allow_different_child_order=False):
        assert pattern_match.name == "CallExpression"
        assert pattern_match.children[0].name == "MemberExpression" # ToDo: what if it's foo(chrome.tabs.executeScript) ?!
        code_sinks.append(pattern_match.children[0])

    return code_sinks


def get_all_message_listeners(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all message listeners in the given PDG.
    More precisely:
    Returns for all `x` for all `chrome.runtime.onMessage.addListener(x)` calls.
    Those xs returned should usually be one of the following:
    * a FunctionExpression
    * an ArrowFunctionExpression
    * a FunctionDeclaration (if resolve_function_references=True, which is the default)
    * an Identifier (if resolve_function_references=False, or when resolving a function reference failed!)
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    # e.g., "chrome", "browser", "this.browser",
                                    #       "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                                    # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                    # calling "runtime.onMessage" doesn't work!
                                    .child(Node.identifier("runtime"))
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Get All Message Listeners Pattern #1:\n{pattern}")

    result = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        if len(pattern_match.children) >= 2:
            x = pattern_match.children[1]  # the `x` in `chrome.runtime.onMessage.addListener(x)`

            # Resolve function references if parameter resolve_function_references=True:
            if x.name == "Identifier" and resolve_function_references:
                function_declaration = x.function_Identifier_get_FunctionDeclaration(True)
                if function_declaration is None:
                    result.append(x)
                else:
                    assert function_declaration.name == "FunctionDeclaration"
                    result.append(function_declaration)

                # function foo(x,y,z) {}
                # chrome.runtime.onMessage.addListener(foo);
                #
                # [1] [Program] (2 children)
                # 	[2] [FunctionDeclaration] (5 children) --e--> [7]             <-----
                # 		[3] [Identifier:"foo"] (0 children) --data--> [17]        <-----
                # 		[4] [Identifier:"x"] (0 children)
                # 		[5] [Identifier:"y"] (0 children)
                # 		[6] [Identifier:"z"] (0 children)
                # 		[7] [BlockStatement] (0 children)
                # 	[8] [ExpressionStatement] (1 child)
                # 		[9] [CallExpression] (2 children)
                # 			[10] [MemberExpression] (2 children)
                # 				[11] [MemberExpression] (2 children)
                # 					[12] [MemberExpression] (2 children)
                # 						[13] [Identifier:"chrome"] (0 children)
                # 						[14] [Identifier:"runtime"] (0 children)
                # 					[15] [Identifier:"onMessage"] (0 children)
                # 				[16] [Identifier:"addListener"] (0 children)
                # 			[17] [Identifier:"foo"] (0 children)                  <-----

            else:
                result.append(x)

        # If len(pattern_match.children) < 2, we have a "chrome.runtime.onMessage.addListener()" call, i.e., the
        #   argument is missing!

    return result


def expression_correctly_verifies_sender_object(test_expression: Node, sender_object_node: Node) -> bool:  # ToDo
    """
    Helper function for expression_correctly_verifies_sender().
    Unlike for the `sender_node` of expression_correctly_verifies_sender(), we already know here that the
    `sender_object_node` is *directly* the "sender" object (with .url, .tab.url, .origin, etc. attributes), and not,
    for example, already some attribute/member of it (like sender.url).

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender?!
        sender_object_node: the part of the `test_expression` representing the sender
                            (has .url, .tab.url and .origin attributes, among others)

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender, False otherwise.
    """
    return False


def is_safe_url_prefix(url_prefix: str) -> bool:
    """
    E.g., "https://admin.com/" is a safe URL prefix but "https://admin.com" (w/o the trailing slash) isn't!
    "https://" on its own is also an unsafe prefix!
    Note that the prefix doesn't have to end with a slash though, "https://admin.com/foo" is also a safe URL prefix.
    """
    if os.environ.get('CONSIDER_HTTP_AS_SAFE') == "yes":
        return re.fullmatch("^https?://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    else:
        return re.fullmatch("^https://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    # Checking that the URL has an http:// prefix is still considered an insecure verification of the sender as the
    #   authenticity of such a sender still cannot be guaranteed. A renderer attacker + network attacker would still be
    #   able to exploit the vulnerability in the extension!
    # This default behavior is only deactivated when the user supplies the --consider-http-as-safe argument.


def is_safe_origin_suffix(origin_suffix: str) -> bool:
    """
    E.g., ".admin.com" and ".admin.co.uk" are safe origin suffixes but "admin.com" and ".co.uk" aren't!
    "/admin.com", "//admin.com", "://admin.com" and "https://admin.com" can also be considered safe suffixes
    (but not "http://admin.com", see below).

    Note that by using Mozilla's Public Suffix List (PSL) (https://publicsuffix.org/), we can identify a danger even
    when the code checks for a suffix like ".blogspot.com" for example!

    Note that even a triple-suffix like ".sth.ac.at" can be available for public registration and hence unsafe!
    """
    if "http://" in origin_suffix:
        # The origin is essentially checked to be equal to a http:// domain, this means that the entire origin check
        #   is essentially pointless though, since all HTTP communication can be manipulated anyways.
        return False
    elif "/" in origin_suffix:
        # As the sender.origin will never contain a slash except for the one from "https://",
        #   if there's a "/" in the origin suffix check, this always means there's essentially a check on the entire
        #   origin!
        return True
    elif "." not in origin_suffix:
        return False  # e.g. simply suffix check for "com" => not even REMOTELY sufficient!
    else:  # e.g. ".admin.co.uk" or ".admin.com" or "foo.admin.com" (all good) or "admin.co.uk" or "admin.com" (all bad)
        actually_verified_suffix = origin_suffix[origin_suffix.index(".")+1:]  # only everything after the first "." is actually verified
        extract = tldextract.TLDExtract()
        return extract(actually_verified_suffix, include_psl_private_domains=True).domain != ''


def expression_correctly_verifies_sender_url(test_expression: Node, sender_url_node: Node) -> bool:
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender URL verifications:
    * url == "https://admin.com/"
    * url === "https://admin.com/"
    * url.startsWith("https://admin.com/")
    * ["option1", "option2"].includes(url)
    * url == "option1" | url == "option2"
    * url === "option1" || url === "option2"

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (url == "https://admin.com/" & something_else())
    * (url == "https://admin.com/" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (URL)?!
        sender_url_node: the part of the `test_expression` representing the sender URL

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender URL, False otherwise.
    """
    if not sender_url_node.lies_within(test_expression)\
            and not any(identifier.is_data_flow_equivalent_identifier(sender_url_node)
                        for identifier in test_expression.get_all_identifiers()):
        # `test_expression` cannot verify `sender_url_node` if `test_expression` does not *contain* `sender_url_node`
        #     (or at least a "data-flow-equivalent" node, take "url == 'foo' || url == 'foo'" for example where both
        #     "url" identifiers are deemed "data-flow-equivalent")
        return False

    elif test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] in ["==", "==="]:
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        if left_operand.equivalent(right_operand):
            return False  # "url == url" or "url === url" is trivially True and therefore *not* a sufficient check!
        elif sender_url_node.lies_within(left_operand) and sender_url_node.lies_within(right_operand):
            # Something like, maybe, "url == url.toLowerCase()", or "url == url.substring(0,30)",
            # or "url.length == url.substring(20,22)"
            # => all unsafe checks
            # Something like, maybe, "url == 'foo' + url" would always be False and therefore *THEORETICALLY* be a
            # good enough "protection" for a block of code. However, (a) it seems unlikely that someone would write
            # such an always-False "check" and (b) even *if*, we simply return it as a vulnerability, leaving some
            # manual verification effort for the human (as always).
            return False
        elif os.environ.get('CONSIDER_HTTP_AS_SAFE') != "yes" and\
                (left_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*") or
                 right_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*")):
            return False  # return False for "url == 'http://...'" as HTTP is unsafe!!! (renderer + network attacker)
        else:
            return True  # We assume "url == ...", "... == url", "url === ..." or "... === url" to be valid checks!

    # "url == "https://admin.com/" && something_else()"  (ONE side of the "&&" needs to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "&&"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "&":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url =\
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url or right_operand_correctly_verifies_sender_url

    # "url == "option1" || url == "option2"" (BOTH sides of the "||" need to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "||"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "|":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url and right_operand_correctly_verifies_sender_url

    # "url.startsWith("https://admin.com/")" (URL needs to end with a '/' that's *not* the slash from 'https://'!):
    #     [1] [CallExpression] (2 children)
    #         [2] [MemberExpression] (2 children)
    #             [3] [Identifier:"url"] (0 children)            == sender_url_node
    #             [4] [Identifier:"startsWith"] (0 children)
    #         [5] [Literal:""https://admin.com/""] (0 children)
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0] == sender_url_node\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "startsWith"\
            and test_expression.children[1].name == "Literal"\
            and is_safe_url_prefix(test_expression.children[1].string_literal_without_quotation_marks()):
        return True

    # "["option1", "option2"].includes(url)":
    # [1] [CallExpression] (2 children)
    #     [2] [MemberExpression] (2 children)
    #         [3] [ArrayExpression] (2 children)
    #             [4] [Literal:""option1""] (0 children)
    #             [5] [Literal:""option2""] (0 children)
    #         [6] [Identifier:"includes"] (0 children)
    #     [7] [Identifier:"url"] (0 children)             == sender_url_node
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0].name == "ArrayExpression"\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "includes"\
            and test_expression.children[1] == sender_url_node:
        return True

    else:
        return False

    # ToDo: handle UnaryExpression with '!' operator!!!


def expression_correctly_verifies_sender_origin(test_expression: Node, sender_origin_node: Node) -> bool: # ToDo
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender origin verifications:
    * origin == "https://admin.com"
    * origin === "https://admin.com"
    * origin.endsWith(".admin.com")
    * origin.endsWith(".admin.co.uk")
    * origin.endsWith("/admin.com")
    * ["option1", "option2"].includes(origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (origin == "https://admin.com" & something_else())
    * (origin == "https://admin.com" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (origin)?!
        sender_origin_node:

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender origin, False otherwise.
    """
    return False


def expression_correctly_verifies_sender(test_expression: Node, sender_node: Node, data_flow: DataFlow) -> bool:
    """
    Helper function for verifies_sender_is_safe().
    Note that it is assumed that `sender_node.lies_within(test_expression)`!
    It is also assumed that `sender_node in data_flow.nodes`!

    Note that the sender_node may be:
    (1) simply the `sender` variable from `(msg, sender, sendResponse)`
    (2) a renamed alias of it, e.g.: `let from = sender;`
    (3) a variable storing a property of the sender, e.g.: `let url = sender.url;`
    (4)                                       ...but also: `let len = sender.url.length;`
                                                       or: `let active = sender.tab.active;` (which is simply a boolean)
    (5) some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`

    Parameters:
        test_expression: the expression to check: Does it correctly *verify* the sender?!
        sender_node: the PDG node having a data flow from `sender` into it *and* lying within `test_expression`
        data_flow: the complete data from `sender` that `sender_node` is a part of

    Returns:
        a boolean indicating whether `test_expression` correctly verifies the sender
    """
    assert sender_node.lies_within(test_expression)
    assert sender_node in data_flow.nodes

    data_flow = data_flow.get_sub_flow(last_node=sender_node)
    accessed_members = data_flow.get_accessed_members(include_method_calls=False)
    if accessed_members == []:  # case (1) or (2): sender_node is still simply the sender object
        return expression_correctly_verifies_sender_object(test_expression=test_expression, sender_object_node=sender_node)
    elif accessed_members == ["url"] or accessed_members == ["tab", "url"]:  # case (3): sender_node === sender.url or sender.tab.url
        return expression_correctly_verifies_sender_url(test_expression=test_expression, sender_url_node=sender_node)
    elif accessed_members == ["origin"]:  # case (3): sender_node === sender.origin
        return expression_correctly_verifies_sender_origin(test_expression=test_expression, sender_origin_node=sender_node)
    else:
        # case (4): some other property of sender that is not useful as a safety check is used in the test_expression
        # case (5): some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`
        # Note that while this *might* still be a correct sender verification, we are in doubt and still return the
        #   vulnerability, leaving it to the human to verify the vulnerability!
        return False


def verifies_sender_is_safe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool:
    """
    Returns True if the `test_expression` Expression Node *correctly* verifies the safety of the sender stored in
    `sender_identifier_or_pattern`.

    Examples of correct sender verifications:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (sender.url == "https://admin.com/" & something_else())
    * (sender.url == "https://admin.com/" && something_else())

    Also, the sender URL/origin might have been written into another intermediary variable first:
    ```
    let url = sender.url;
    if (url == "https://admin.com/") {
        /* ... */
    }
    ```

    Also note that "sender.tab.url" may be used instead of "sender.url" as well!

    (!!!) The `test_expression` evaluating to TRUE must IMPLY that the sender is safe. (!!!)

    (!!!) The if-branch of the if-statement is safe. (!!!)
    """
    sender_identifier_data_flows = DataFlow.all_continued_beginning_at(sender_identifier_or_pattern)
    # For each data flow sender -> ... -> ... -> ...:
    for sender_identifier_data_flow in sender_identifier_data_flows:
        if os.environ.get('PRINT_PDGS') == "yes":                      #
            print(f"Sender data flow: {sender_identifier_data_flow}")  #

        # For each node in such a data flow: sender -> ... -> ... -> ...:
        #                                    |____|    |_|    |_|    |_|
        for sender_node in sender_identifier_data_flow.nodes:

            # If this node lies within the test expression of which we want to check whether it verifies sender safety:
            if sender_node.lies_within(test_expression):
                if os.environ.get('PRINT_PDGS') == "yes":                                                 #
                    print(f"\t=> [{sender_node.id}] lies within test expression [{test_expression.id}]")  #

                # Check if the `test_expression` *correctly* verifies the safety of the sender represented by `sender_node`:
                if expression_correctly_verifies_sender(test_expression, sender_node, sender_identifier_data_flow):
                    print(f"Found correct sender verification in {test_expression.get_file()}, "
                          f"line {test_expression.get_line()}: {test_expression.get_whole_line_of_code_as_string()}")
                    return True
                # Note that the sender may occur more than once inside the `test_expression`, e.g.:
                #     if (sender && sender.url == "https://admin.com/") { /* ... */ }
                #     if (sender.url.length > 18 && sender.url.startsWith("https://admin.com/")) {/ *...* /}
                # => Therefore, we cannot simply return False when expression_correctly_verifies_sender() returns False!

    # Either no flow from `sender_identifier_or_pattern` into the `test_expression` could be found,
    # or the `test_expression` did not correctly verify the `sender_identifier_or_pattern`:
    return False


def verifies_sender_is_unsafe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool: # ToDo
    """
    Note that this function does *not* simply return the opposite of the verifies_sender_is_safe() function!
    A test expression may neither verify safety *nor* non-safety of the sender, e.g., when it doesn't perform a check on
    the sender at all, doing something completely unrelated, or, when it performs in incorrect/incomplete check of the
    sender!

    Also note that a sender un-safety check may be combined with other checks in a DISJUNCTION ("|" or "||" operator)
    but NOT in a CONJUNCTION ("&" or "&&" operator), i.e., the exact opposite of the verifies_sender_is_safe() function!
    Think of it as swapping the "if" and "else" branches / negating the condition. Example:
    * (sender.url != "https://admin.com/" | something_else())
    * (sender.url != "https://admin.com/" || something_else())

    (!!!) The sender being unsafe must IMPLY that the `test_expression` evaluates to TRUE. (!!!)

    (!!!) The else-branch of the if-statement is safe. (!!!)
    """
    pass


def get_protected_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Returns all blocks of code inside the given `pdg_subtree` where the sender identifier (given as the second argument)
    is *correctly* verified.

    There are 3 different ways of sender URL/origin verification that we consider to be "correct":
    (1) checking the URL (either sender.url or sender.tab.url) or origin (sender.origin) for equality using "==" or
        "===" or using an Array.includes() call (except when checking for trivial equality to itself of course)
    (2) checking a URL prefix, prefix must contain a slash "/" other than the two slashes from "://", this ensures that
        there's an (implicit) equality check for the origin
    (3) checking the suffix of origin, such that there's an (implicit) equality check of the domain name,
        e.g., ".admin.com" or ".admin.co.uk" but not "admin.com" or ".co.uk" (!!!)

    Some examples of correct sender verifications are:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    Some examples of *incorrect* sender verifications are:
    * sender.url == sender.url
    * sender.url === sender.url
    * sender.origin == sender.origin
    * sender.origin === sender.origin
    * sender.url != "https://bad.com/"
    * sender.url !== "https://bad.com/"
    * sender.url.startsWith("https://admin.com")    sender.origin.startsWith("https://admin.com")
    * sender.url.includes("admin.com")              sender.origin.includes("admin.com")
    * sender.url.endsWith("admin.html")             sender.origin.endsWith("admin.com")
    * sender.url.endsWith(".admin.com/")            sender.origin.endsWith(".co.uk")
    * ["option1", "option2", sender.url].includes(sender.url)
    * ["option1", "option2", sender.origin].includes(sender.origin)

    Note that, instead of sender.url, sender.tab.url may be also used (extension requires the "tabs" permission though).

    Also note that sender.url, sender.tab.url or sender.origin might also flow into another variable before being
    checked!
    """
    protected_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None
        # The else_block could be another IfStatement, in that case it will *also* be enumerated by
        #     get_all_if_statements_inside().

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            protected_blocks_of_code.append(if_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and\
                else_block is not None:
            protected_blocks_of_code.append(else_block)

        # Note how this even catches the following case:
        #
        # if (sender.url != "safe.com") {
        #     /* ... */
        # } else if (something_completely_unrelated()) {
        #     /* PROTECTED BLOCK OF CODE */
        #     sendResponse(cookies);
        # }

    return protected_blocks_of_code


def get_explicitly_unsafe_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Cf. get_protected_blocks_of_code() but returns all blocks of code where it has been explicitly verified that the
    sender is *not* safe!
    """
    explicitly_unsafe_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and \
                else_block is not None:
            explicitly_unsafe_blocks_of_code.append(else_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            explicitly_unsafe_blocks_of_code.append(if_block)

    return explicitly_unsafe_blocks_of_code


def identifier_get_all_member_identifiers(identifier: Node, member_name: str, allow_method_calls=False) -> List[Node]:
    """
    Input:  (A) Identifier Node, e.g., "port"
            (B) Member name, e.g., "sender"
    Output: list of all Identifier Nodes with a data flow from "port.sender" into them
    """
    assert identifier.name == "Identifier"
    result = set()
    for data_flow_parent in identifier.get_data_flow_parents():
        for data_flow in DataFlow.all_continued_beginning_at(data_flow_parent):
            for node in data_flow.nodes:
                partial_data_flow = data_flow.get_sub_flow(first_node=None, last_node=node)
                # partial_data_flow: self --data--> ... --data--> node
                if allow_method_calls:
                    if partial_data_flow.get_accessed_members(include_method_calls=False) == [member_name]:
                        result.add(node)
                else:
                    if partial_data_flow.get_accessed_members(include_method_calls=True) == [member_name]:
                        result.add(node)
    assert all(node.name == "Identifier" for node in result)
    return list(result)
    # ToDo: make this a member function of Node?!


def detect_41_31_vuln_in_bp_no_uxss(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Look for type 4.1 vulnerabilities in the given background page/service worker (or rather its PDG), type 4.1
    vulnerabilities refer to the ability to `Execute Privileged Browser APIs` w/o (sufficiently) verifying `sender.url`,
    which is a security violation of type 3.1: `Extension Message Authentication`
    (refer to Kim and Lee paper for more info)

    Example vulnerability (with no authentication of `sender.url` or `sender.tab.url` or `sender.origin` whatsoever):
    ```
    chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
        chrome.cookies.getAll({},
            function(cookies) {
                sendResponse(cookies);
            }
        );
        return true;
    });
    ```

    This function only looks for *exfiltration* dangers, refer to detect_41_31_vuln_in_bp_uxss() for the detection of
    UXSS/*infiltration* dangers!
    """
    start = timeit.default_timer()

    # ##### ##### Sources: ##### #####
    cookie_sources: List[Node] = get_all_cookie_function_identifiers(pdg_bp)
    # => e.g., returns the "getAll" in "cookies1 = await chrome.cookies.getAll({});"
    #    => data flow may continue from there, first into "cookies1" and then beyond...
    cookie_response_sources: List[Node] = get_all_cookie_response_identifiers(pdg_bp)  # (optional ToDo: optimization: reuse cookie_sources result)
    # => e.g., returns the "cookies" in "chrome.cookies.getAll({}, (cookies) => { /* ... */ });",
    #               or the "cookie"  in "chrome.cookies.get({}, function(cookie) { /* ... */ });"
    #               or the "cookies" in "chrome.cookies.getAll({}).then((cookies) => { /* ... */ });"
    #    => data flow may continue from there, inside the (anonymous) function...
    fetch_sources: List[Node] = get_all_fetch_identifiers(pdg_bp)
    # => e.g., returns the "fetch" in "response1 = await fetch(url);"
    #    => data flow may continue from there, first into "response1" and then beyond...
    fetch_response_sources: List[Node] = get_all_fetch_response_identifiers(pdg=pdg_bp,
                                                                            all_fetch_identifiers=fetch_sources)
    # => e.g., returns the "response1" in "fetch(url).then((response1) => console.log(response1))"
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = cookie_sources + cookie_response_sources + fetch_sources + fetch_response_sources

    # ##### ##### Sinks (plus their respective sender identifiers/patterns): ##### #####
    sendResponse_sinks: List[Node] = get_all_sendResponse_sinks(pdg_bp)  # "sendResponse" Identifiers
    port_postMessage_sinks: List[Node] = get_all_port_postMessage_sinks(pdg_bp)  # "port.postMessage" MemberExpressions
    assert all(port_postMessage_sink.parent.name == "CallExpression" for port_postMessage_sink in port_postMessage_sinks)
    sinks: List[Node] =\
        sendResponse_sinks +\
        port_postMessage_sinks
    sink_senders: List[List[Node]] =\
        [[sendResponse_sink.get_sibling_relative(-1)] for sendResponse_sink in sendResponse_sinks] +\
        [identifier_get_all_member_identifiers(port_postMessage_sink.lhs(), "sender")
                                                      for port_postMessage_sink in port_postMessage_sinks]
    # Note: the "sender" is the left sibling (relative -1) of "sendResponse": (message, sender, sendResponse)

    print(f"[3.1+4.1] No. of sources: {len(sources)}")
    print(f"\t=> No. of cookie sources: {len(cookie_sources) + len(cookie_response_sources)}")
    print(f"\t=> No. of fetch sources: {len(fetch_sources) + len(fetch_response_sources)}")

    print(f"[3.1+4.1] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of sendResponse sinks: {len(sendResponse_sinks)}")
    print(f"\t=> No. of port.postMessage sinks: {len(port_postMessage_sinks)}")

    detect_vuln(
        pdg=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=sink_senders,
        rendezvous_nodes=["CallExpression"],
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.1/3.1 non-UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.1/3.1 non-UXSS vulnerabilities"] = time_diff


def detect_41_31_vuln_in_bp_uxss(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    start = timeit.default_timer()

    # ##### ##### Sources (plus their respective sender identifiers/patterns): ##### #####
    msg_sources: List[Node] = get_all_msg_sources(pdg_bp)
    # => e.g., returns the "message" in "chrome.runtime.onMessage.addListener((message, sender, sendResponse) => ...);"
    sources: List[Node] =\
        msg_sources
    src_senders: List[List[Node]] =\
        [[s for s in [msg_src.get_sibling_relative_or_none(+1)] if s is not None] for msg_src in msg_sources]
    # Note: The "sender" is the right sibling (relative +1) of "message": (message, sender, sendResponse)
    #       It might not be present however when the programmer has left out parameters: (message) (!!!)
    # Note: The expression above turns `None` into `[]` and `s` into `[s]`.

    # ##### ##### Sinks: ##### #####
    document_sinks: List[Node] = get_all_document_identifiers(pdg_bp)  # "document" Identifiers
    chrome_tabs_executeScript_sinks: List[Node] =\
        get_all_chrome_tabs_executeScript_sinks(pdg_bp)  # "chrome.tabs.executeScript" MemberExpressions
    sinks: List[Node] = document_sinks + chrome_tabs_executeScript_sinks

    # Note that although "chrome.tabs.executeScript" is a deprecated <=MV2 API, "chrome.scripting.executeScript" dangers
    #   (MV3) are nonetheless detected via `document_sinks = get_all_document_identifiers(pdg_bp)` (see above)
    #   and `add_missing_data_flow_edges_chrome_apis()`, which has been previously executed!
    # = https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript

    print(f"[3.1+4.1/UXSS] No. of sources: {len(sources)}")
    print(f"\t=> No. of message sources: {len(msg_sources)}")

    print(f"[3.1+4.1/UXSS] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of document sinks: {len(document_sinks)}")
    print(f"\t=> No. of chrome.tabs.executeScript sinks (deprecated <=MV2 API): {len(chrome_tabs_executeScript_sinks)}")

    detect_vuln(
        pdg=pdg_bp,
        sources=sources, src_senders=src_senders,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression", "AssignmentExpression"],
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.1/3.1 UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.1/3.1 UXSS vulnerabilities"] = time_diff


def detect_vuln(pdg: Node,
                sources: List[Node], src_senders: Optional[List[List[Node]]],
                sinks: List[Node], sink_senders: Optional[List[List[Node]]],
                rendezvous_nodes: List[str],
                results: list,
                debug_prints: bool):
    """
    Extraction of common logic from detect_41_31_vuln_in_bp_no_uxss(), detect_41_31_vuln_in_bp_uxss(),
    detect_42_32_vuln_in_bp() and detect_42_32_vuln_in_cs().
    The main difference between the three however is whether there *is* a sender that might be verified and whether
        that sender is associated with the source (as with 4.1/3.1/UXSS) or with the sink (4.1/3.1/non-UXSS):
    * for 4.1/3.1/non-UXSS vulnerabilities, each sender corresponds to exactly one sink (sendResponse),
    * for 4.1/3.1/UXSS vulnerabilities, each sender corresponds to exactly one source (msg),
    * for 4.2/3.2/UXSS vulnerabilities, there is no sender (as the dangerous source is the extension storage!).
    Therefore, at most one of `src_senders` or `sink_senders` may be not `None`!

    This function has no return value.
    Instead, it appends to the given `results` list.

    Parameters:
        pdg:          the root Node of either the service worker's or the content script's PDG
        sources:      the list of all Nodes where data flows may start
        src_senders:  has to be None if sink_senders is not None; has to have the same length as sources if not None
        sinks:        the list of all Nodes where data flows may end
        sink_senders: has to be None if src_senders is not None; has to have the same length as sinks if not None
        rendezvous_nodes: the list of allowed rendezvous Node names as strings,
                          cf. corresponding DoubleDataFlow.data_flows_into_function() parameter;
                          e.g.: ["CallExpression", "AssignmentExpression"]
        results:      the list to store the results in
        debug_prints: boolean, whether to print debug prints
    """
    assert not (src_senders is not None and sink_senders is not None)
    if sink_senders is not None:
        assert len(sinks) == len(sink_senders)
    if src_senders is not None:
        assert len(sources) == len(src_senders)

    try:
        for src_idx in range(len(sources)):
            for sink_idx in range(len(sinks)):
                if sink_senders is not None:
                    # Non-UXSS vulnerabilities/exfiltration dangers:
                    #   A: (msg, sender, sendResponse) where sendResponse=sink and therefore there's one sender per *sink*
                    #   B: port.postMessage=sink and sender=port.sender and therefore there's one sender per *sink*
                    sender_identifiers_or_patterns = sink_senders[sink_idx]
                elif src_senders is not None:
                    # UXSS vulnerabilities/infiltration dangers:
                    #   A: (msg, sender, sendResponse) where msg=source and therefore there's one sender per *source*
                    #   B: port.onMessage.addListener(msg => ...) where msg=source and sender=port.sender
                    #        and therefore there's one sender per *source*
                    sender_identifiers_or_patterns = src_senders[src_idx]
                else:
                    sender_identifiers_or_patterns = None  # no sender checks.

                source = sources[src_idx]
                sink = sinks[sink_idx]

                data_flows: List[DoubleDataFlow] = DoubleDataFlow.data_flows_into_function(
                    pdg=pdg,
                    from_node=source,
                    to_node=sink,
                    rendezvous_nodes=rendezvous_nodes,
                    return_multiple=(os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') == "yes" or
                                     os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') != "yes")
                )
                # We need all data flows when there are multiple ones if...:
                # (a) the user specified --return-multiple-flow-variants
                # and/or
                # (b) the check for sender verification is on, i.e., RETURN_SAFE_FLOWS_VERIFIED is OFF(!)
                #
                # In other words:
                # We can *only* refrain from searching for multiple data flow if...:
                # (a) the user did *not* specify --return-multiple-flow-variants
                # *and*
                # (b) the check for sender verification is off, i.e., RETURN_SAFE_FLOWS_VERIFIED is ON
                #     (otherwise we could potentially miss an unsafe flow if we only look for 1 flow and that one just
                #      happens to be a safe one!)

                for data_flow in data_flows:
                    if debug_prints:
                        print(f"[Debug] Data flow: {data_flow}")

                    # the final dangerous rendezvous Node (CallExpr/AssignmentExpr):
                    sink_call: Node = data_flow.from_flow.last_node().get_ancestor(data_flow.rendezvous_nodes)

                    # Logic:

                    # if any node in data_flow lies_within any protected_block_of_code:
                    #    safe
                    # elif is there a return statement before the sink call and that return statement lies_within an
                    #      explicitly_dangerous_part_of_code and the if statement it's in is on the same depth as the sink call?:
                    #    safe
                    # else:
                    #    unsafe

                    # If *any* data flow node ("to" or "from" flow) lies within *any* protected block of code,
                    #     this data flow is safe:
                    if sender_identifiers_or_patterns is not None and\
                       any(any(node.lies_within(protected_block_of_code)
                               for sender_identifier_or_pattern in sender_identifiers_or_patterns
                               for protected_block_of_code in get_protected_blocks_of_code(pdg=pdg,
                                                                                           pdg_subtree=pdg,
                                                                                           # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                           sender_identifier_or_pattern=sender_identifier_or_pattern))
                           for node in data_flow.from_flow.nodes + data_flow.to_flow.nodes):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                    # If *any* return statement lies within *any* explicitly unsafe block of code that occurs before
                    #     the sink call, where if statement and sink call are on the same "indentation level", this
                    #     data flow is safe:
                    elif sender_identifiers_or_patterns is not None and\
                         any(any(return_statement.lies_within(explicitly_unsafe_block_of_code)
                                 and return_statement.occurs_in_code_before(sink_call)
                                 and return_statement.get_innermost_surrounding_if_statement().is_sibling_of(sink_call)
                                 for sender_identifier_or_pattern in sender_identifiers_or_patterns
                                 for explicitly_unsafe_block_of_code in get_explicitly_unsafe_blocks_of_code(pdg=pdg,
                                                                                                             pdg_subtree=pdg,
                                                                                                             # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                                             sender_identifier_or_pattern=sender_identifier_or_pattern))
                             for return_statement in pdg.get_all_return_statements_inside()):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                        # Catches:
                        #
                        # if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #     return; // return_statement // explicitly_unsafe_block_of_code
                        # }                               // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # But not:
                        #
                        # if (sender.url != "safe.com") {      // explicitly_unsafe_block_of_code
                        #     if (1==2) {                      // explicitly_unsafe_block_of_code
                        #          return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                                // explicitly_unsafe_block_of_code
                        # }                                    // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # And also not:
                        #
                        # if (1==1) {
                        #     /* ... */
                        # } else {
                        #     if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #         return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                               // explicitly_unsafe_block_of_code
                        # }
                        # sendResponse(cookies); // sink_call

                    else:
                        # unsafe
                        print(f"[4.1/3.1] Data flow found:\n{str(data_flow)}\n")
                        results.append(data_flow.as_pretty_dict())
                        if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                            raise StopIteration

    except StopIteration:
        pass


def detect_31_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict):  # ToDo: include instances of chrome.runtime.onConnect as well!!!
    """
    Detects all violations of Kim and Lee's Security Requirement 3.1 (Extension Message Authentication),
    for which there is **NO** type 4.1 vulnerability (Execution of Privileged Browser APIs).

    An example of this would be the "Cisco Webex Extension" that violates Sec. Req. 3.1 by not authenticating
    incoming extension messages, however only resulting in the "Start Cisco Webex Meetings application", i.e.,
    something relatively harmless, no sensitive data exfiltration, no UXSS vector (cf. detect_41_31_vuln_in_bp()):

    ```
    chrome.runtime.onMessage.addListener(function(e, n) {
        if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
            var o = {
                category: "browser-extension",
                event: "launch-meeting",
                extVal: e
            };
            doi.send("Event", o, !0)
        }
    })
    ```
    (code from the Cisco WebEx Extension, version 1.17.0)

    This function shall only be executed when the user supplies the
        --include-31-violations-without-privileged-api-access
    command line argument.
    """
    start = timeit.default_timer()

    all_msg_listeners: List[Node] = get_all_message_listeners(pdg_bp, resolve_function_references=True)
    print(f"[3.1, no 4.1] {len(all_msg_listeners)} message listeners found in total (in BP).")
    for msg_listener in all_msg_listeners:
        print(f"[3.1, no 4.1] Looking at message listener in line {msg_listener.get_line()} in file "
              f"'{msg_listener.get_file()}'...")
        if msg_listener.name == "FunctionExpression":
            # [1] [FunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- optional name for FunctionExpressions!!!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "ArrowFunctionExpression":
            # [1] [ArrowFunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- hypothetical, not actually possible for ArrowFE!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "FunctionDeclaration":
            # [1] [FunctionDeclaration] (5 children) --e--> [6]
            # 		[2] [Identifier:"foo"] (0 children) --data--> [...]
            # 		[3] [Identifier:"msg"] (0 children)
            # 		[4] [Identifier:"sender"] (0 children)               <----- sender_identifier_or_pattern
            # 		[5] [Identifier:"sendResponse"] (0 children)
            # 		[6] [BlockStatement] (0 children)                    <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.function_declaration_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "Identifier":
            print(f"[3.1, no 4.1] [Warning] message listener function reference '{msg_listener.attributes['name']}' "
                  f"in line {msg_listener.get_line()}, file '{msg_listener.get_file()}', could not be resolved, "
                  f"likely missing something...")
            continue
        else:
            print(f"[3.1, no 4.1] [Warning] Unexpected Node type of message listener: {msg_listener.name}, "
                  f"likely missing something...")
            continue

        # print(f"[3.1, no 4.1] block_of_code = {block_of_code}")
        # print(f"[3.1, no 4.1] sender_identifier_or_pattern = {sender_identifier_or_pattern}")

        # For each block of code inside a message listener, add it to the result set, if:
        #     (a) the block contains no sensitive API access whatsoever
        #     (b) the block contains no (correct) sender verification whatsoever

        sensitive_apis = block_of_code.get_sensitive_apis_accessed()
        print(f"[3.1, no 4.1] {len(sensitive_apis)} sensitive APIs found.")

        protected_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_protected_blocks_of_code(pdg=pdg_bp,
                                                                         pdg_subtree=block_of_code,
                                                                         sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(protected_blocks_of_code)} protected blocks of code found.")

        explicitly_unsafe_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_explicitly_unsafe_blocks_of_code(pdg=pdg_bp,
                                                                                 pdg_subtree=block_of_code,
                                                                                 sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(explicitly_unsafe_blocks_of_code)} explicitly unsafe blocks of code found.")

        # --include-31-violations-without-privileged-api-access help text:
        #     Include violations of Security Requirement 3.1 (Extension Message Authentication),
        #         even when no privileged API (like chrome.cookies, chrome.scripting or indexedDB)
        #         is accessed (4.1).
        if (len(sensitive_apis) == 0  # no 4.1 vulnerability...
                and len(protected_blocks_of_code) == 0  # ...but still a 3.1 security requirement violation.
                and len(explicitly_unsafe_blocks_of_code) == 0):
            results.append({
                "msg_listener": {
                    "location": msg_listener.get_location(),
                    "filename": msg_listener.get_file(),
                    "line_of_code": msg_listener.get_whole_line_of_code_as_string()
                },
                "block_of_code": {
                    "location": block_of_code.get_location(),
                    "filename": block_of_code.get_file(),
                    "line_of_code": block_of_code.get_whole_line_of_code_as_string()
                }
            })

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 3.1 violations w/o privileged API access in {time_diff}s')
    benchmarks[f"bp: 3.1 violations w/o privileged API access"] = time_diff


def detect_42_32_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Look for type 4.2 vulnerabilities in the given background page/service worker (or rather its PDG), type 4.2
    vulnerabilities refer to the ability to `Write Sensitive Extension Data`,
    which is a security violation of type 3.2: `Non-sensitive Data in Extension Storage`
    (refer to Kim and Lee paper for more info)

    We shall restrict ourselves to *infiltration* dangers, leading to UXSS, cf. detect_41_31_vuln_in_bp_uxss(),
    where the dangerous source is an extension message instead of the extension storage, which it is here.

    Example vulnerability:
    ```
    chrome.storage.local.get(["user_name"]).then((result) => {
        chrome.tabs.query({},
            (tabs) => {
                tabs.forEach((tab) => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        func: (uname) => {
                            const body = document.getElementsByTagName('body')[0];
                            const new_span = document.createElement('span');
                            new_span.innerHTML = 'Hello ' + uname + '!';
                            body.append(new_span);

                        },
                        args: ["" + result["user_name"]]
                    });
                });
            }
        );
    });
    ```

    Note that, as opposed to 4.1/3.1 vulnerabilities, there is no way to *verify* a sender, as there is no sender
    (the infiltrated data stems from the extension storage and not from an extension message); therefore we do not
    have to check for sender verification and the code logic is simpler.
    """
    start = timeit.default_timer()

    # ##### ##### Sources (cf. detect_41_31_vuln_in_bp_no_uxss()): ##### #####
    # Sources might be:
    #     - the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #     - the "result" in: chrome.storage.local.get('key', function (result) {});
    #     - the "result" in: const result = await chrome.storage.local.get("key");
    #     ...where "storage.local" may be replaced with "storage.sync"
    #        and "chrome" may be replaced with "browser" or any other arbitrary MemberExpression!
    storage_get_sources: List[Node] = get_all_storage_get_identifiers(pdg_bp)
    # => e.g., returns the "get" in "const result = await chrome.storage.local.get('key')"
    #    => data flow may continue from there, first into "result" and then beyond...
    storage_response_sources: List[Node] = get_all_storage_response_identifiers(pdg_bp)  # (optional ToDo: optimization: reuse storage_get_sources result)
    # => e.g., returns the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #               or the "result" in: chrome.storage.local.get('key', function (result) {});
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = storage_get_sources + storage_response_sources

    # ##### ##### Sinks (cf. detect_41_31_vuln_in_bp_uxss()): ##### #####
    document_sinks: List[Node] = get_all_document_identifiers(pdg_bp)  # "document" Identifiers
    chrome_tabs_executeScript_sinks: List[Node] = \
        get_all_chrome_tabs_executeScript_sinks(pdg_bp)  # "chrome.tabs.executeScript" MemberExpressions
    sinks: List[Node] = document_sinks + chrome_tabs_executeScript_sinks

    # Note that although "chrome.tabs.executeScript" is a deprecated <=MV2 API, "chrome.scripting.executeScript" dangers
    #   (MV3) are nonetheless detected via `document_sinks = get_all_document_identifiers(pdg_bp)` (see above)
    #   and `add_missing_data_flow_edges_chrome_apis()`, which has been previously executed!
    # = https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript

    detect_vuln(
        pdg=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression", "AssignmentExpression"],
        results=results,
        debug_prints=debug_prints
    )

    print(f"[3.2+4.2/UXSS] No. of sources: {len(sources)}")
    print(f"\t=> No. of StorageArea.get() sources: {len(storage_get_sources) + len(storage_response_sources)}")

    print(f"[3.2+4.2/UXSS] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of document sinks: {len(document_sinks)}")
    print(f"\t=> No. of chrome.tabs.executeScript sinks (deprecated <=MV2 API): {len(chrome_tabs_executeScript_sinks)}")

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.2/3.2 UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.2/3.2 UXSS vulnerabilities"] = time_diff


def detect_42_32_vuln_in_cs(pdg_cs: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Look for type ~4.2 vulnerabilities in the given content script (!) (or rather its PDG), being
    security violations of type 3.2: `Non-sensitive Data in Extension Storage`
    (refer to Kim and Lee paper for more info)

    Note that *technically* the vulnerabilities found by this function aren't 4.2 vulnerabilities as no extension page
    behavior is modified! Nonetheless, they lead to UXSS and are extremely similar in nature to the 4.2 vulnerabilities
    found by detect_42_32_vuln_in_bp().

    Example vulnerability:
    ```
    chrome.storage.local.get(["user_name"]).then((result) => {
        const user_name = result["user_name"];
        const body = document.getElementsByTagName('body')[0];
        const new_span = document.createElement('span');
        new_span.innerHTML = 'Hello ' + user_name + '!';
        body.append(new_span);
    });
    ```

    Note that, there is no way to verify a sender, as
    (a) there is no sender, we're talking about access to the extension storage here;
    (b) we're talking about content script (!) code here,
        i.e., anything the renderer attacker can *already* do on his or her own.
    """
    start = timeit.default_timer()

    # ##### ##### Sources (cf. detect_42_32_vuln_in_bp()): ##### #####
    # Sources might be:
    #     - the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #     - the "result" in: chrome.storage.local.get('key', function (result) {});
    #     - the "result" in: const result = await chrome.storage.local.get("key");
    #     ...where "storage.local" may be replaced with "storage.sync"
    #        and "chrome" may be replaced with "browser" or any other arbitrary MemberExpression!
    storage_get_sources: List[Node] = get_all_storage_get_identifiers(pdg_cs)
    # => e.g., returns the "get" in "const result = await chrome.storage.local.get('key')"
    #    => data flow may continue from there, first into "result" and then beyond...
    storage_response_sources: List[Node] = get_all_storage_response_identifiers(pdg_cs)  # (optional ToDo: optimization: reuse storage_get_sources result)
    # => e.g., returns the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #               or the "result" in: chrome.storage.local.get('key', function (result) {});
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = storage_get_sources + storage_response_sources

    # ##### ##### Sinks (cf. detect_42_32_vuln_in_bp()): ##### #####
    document_sinks: List[Node] = get_all_document_identifiers(pdg_cs)  # "document" Identifiers
    # Note that the "chrome.tabs.executeScript" API may only be used by the BP and not by the CS.
    #   => https://developer.chrome.com/docs/extensions/reference/api/tabs
    sinks: List[Node] = document_sinks

    detect_vuln(
        pdg=pdg_cs,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression", "AssignmentExpression"],
        results=results,
        debug_prints=debug_prints
    )

    print(f"[3.2+4.2/UXSS/CS] No. of sources: {len(sources)}")
    print(f"\t=> No. of StorageArea.get() sources: {len(storage_get_sources) + len(storage_response_sources)}")

    print(f"[3.2+4.2/UXSS/CS] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of document sinks: {len(document_sinks)}")

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed CS for ~4.2/3.2 UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"cs: ~4.2/3.2 UXSS vulnerabilities"] = time_diff


def get_all_indexedDB_identifiers(pdg: Node) -> List[Node]:
    return [identifier
            for identifier in pdg.get_all_as_iter("Identifier")
            if identifier.attributes['name'] == "indexedDB"]
    # (ToDo: exclude "indexedDB" identifiers referring to user-defined objects instead of the standard "indexedDB" ???)


def detect_43_31_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Detects 4.3-type vulnerabilities ("Read Sensitive Extension Data") in the background page/service worker.
    Security Requirement Violation: 3.1 Extension Message Authentication

    Example:
        chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    sendResponse(event.target.result.pw);
                };
            };
            return true;
        });
    """

    # https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/open:
    # IDBFactory: open() method
    # Syntax:
    #     open(name)
    #     open(name, version)
    # Parameters:
    #     name: The name of the database.
    #     version (optional): Optional. The version to open the database with. If the version is not provided and the
    #                         database exists, then a connection to the database will be opened without changing its
    #                         version. If the version is not provided and the database does not exist, then it will be
    #                         created with version 1.
    # Return value:
    #     A IDBOpenDBRequest object on which subsequent events related to this request are fired.
    #     If the operation is successful, the value of the request's result property is a IDBDatabase object
    #     representing the connection to the database.
    # Examples:
    #     const request = window.indexedDB.open("toDoList", 4);
    #
    # https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest:
    #     -> inherits properties and methods from its parents IDBRequest and EventTarget.
    #
    # https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest:
    #     -> inherits from EventTarget
    # Instance properties:
    #     IDBRequest.error       (Read only)
    #     IDBRequest.result      (Read only)
    #         => https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/result:
    #            "The result read-only property of the IDBRequest interface returns the result of the request. If the
    #             request is not completed, the result is not available and an InvalidStateError exception is thrown."
    #     IDBRequest.source      (Read only)
    #         => "If no source exists (such as when calling IDBFactory.open), it returns null."
    #     IDBRequest.readyState  (Read only)
    #     IDBRequest.transaction (Read only)
    # Events:
    #     "Listen to these events using `addEventListener()` or by assigning an event listener to the `oneventname`
    #     property of this interface":
    #     * error: Fired when an error caused a request to fail.
    #              => https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/error_event:
    #                 Syntax: addEventListener("error", (event) => {});
    #                         onerror = (event) => {};
    #     * success: Fired when an IDBRequest succeeds.
    #                => https://developer.mozilla.org/en-US/docs/Web/API/IDBRequest/success_event:
    #                   "The success event is fired when an IDBRequest succeeds. In the success event handler, you can
    #                    access the result of the request, as well as place more requests to the same transaction."
    #
    # https://developer.mozilla.org/en-US/docs/Web/API/EventTarget:
    # Instance methods:
    #     EventTarget.addEventListener()
    #     EventTarget.removeEventListener()
    #     EventTarget.dispatchEvent()
    #
    # https://developer.mozilla.org/en-US/docs/Web/API/IDBDatabase:
    # Instance methods (Inherits from: EventTarget):
    #     IDBDatabase.close()
    #     IDBDatabase.createObjectStore()
    #     IDBDatabase.deleteObjectStore()
    #     IDBDatabase.transaction()
    #
    # https://developer.mozilla.org/en-US/docs/Web/API/IDBTransaction:
    # Instance properties:
    #     IDBTransaction.db               (Read only)
    #     IDBTransaction.durability       (Read only)
    #     IDBTransaction.error            (Read only)
    #     IDBTransaction.mode             (Read only)
    #     IDBTransaction.objectStoreNames (Read only)
    # Instance methods (Inherits from: EventTarget):
    #     IDBTransaction.abort()
    #     IDBTransaction.objectStore()
    #     IDBTransaction.commit()
    # Events:
    #     "Listen to these events using `addEventListener()` or by assigning an event listener to the `oneventname`
    #     property of this interface":
    #     * abort: An event fired when the IndexedDB transaction is aborted.
    #              Also available via the onabort property; this event bubbles to IDBDatabase.
    #     * complete: An event fired when the transaction successfully completes.
    #                 Also available via the oncomplete property.
    #     * error: An event fired when a request returns an error and the event bubbles up to the connection object
    #              (IDBDatabase). Also available via the onerror property.
    #
    # However, we shall not bother about any of this^^
    # We simply follow the data flow from "indexedDB" to the sink, using our advanced data flow logic, implemented
    #   by add_missing_data_flow_edges().

    start = timeit.default_timer()

    # ##### ##### Sources: ##### #####
    indexedDB_sources: List[Node] = get_all_indexedDB_identifiers(pdg_bp)
    sources: List[Node] = indexedDB_sources

    # ToDo: improve efficiency / avoid double computation by using the sinks
    #       as already previously computed by detect_41_31_vuln_in_bp_no_uxss() !!!!!

    # ##### ##### Sinks (cf. detect_41_31_vuln_in_bp_no_uxss()): ##### #####
    sendResponse_sinks: List[Node] = get_all_sendResponse_sinks(pdg_bp)  # "sendResponse" Identifiers
    port_postMessage_sinks: List[Node] = get_all_port_postMessage_sinks(pdg_bp)  # "port.postMessage" MemberExpressions
    assert all(
        port_postMessage_sink.parent.name == "CallExpression" for port_postMessage_sink in port_postMessage_sinks)
    sinks: List[Node] = \
        sendResponse_sinks + \
        port_postMessage_sinks
    sink_senders: List[List[Node]] = \
        [[sendResponse_sink.get_sibling_relative(-1)] for sendResponse_sink in sendResponse_sinks] + \
        [identifier_get_all_member_identifiers(port_postMessage_sink.lhs(), "sender")
         for port_postMessage_sink in port_postMessage_sinks]
    # Note: the "sender" is the left sibling (relative -1) of "sendResponse": (message, sender, sendResponse)

    print(f"[3.1+4.3] No. of sources: {len(sources)}")
    print(f"\t=> No. of indexedDB sources: {len(indexedDB_sources)}")

    print(f"[3.1+4.3] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of sendResponse sinks: {len(sendResponse_sinks)}")
    print(f"\t=> No. of port.postMessage sinks: {len(port_postMessage_sinks)}")

    detect_vuln(
        pdg=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=sink_senders,
        rendezvous_nodes=["CallExpression"],  # cf. detect_41_31_vuln_in_bp_no_uxss()
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.3/3.1 vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.3/3.1 vulnerabilities"] = time_diff


def get_all_storage_sinks(pdg: Node,
                          storage_areas: str = "local|sync") -> List[Node]:
    """
    Returns all "set" Identifiers from chrome.storage.local.set() or chrome.storage.sync.set() calls
    (actually, "chrome" may be replaced by any arbitrary MemberExpression, e.g., "this.browser").

    Note that calls without any arguments (should they exist) are *not* returned.

    An example would be the chrome.storage.local.set() call in the following piece of BP code:
        chrome.action.onClicked.addListener(() => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    chrome.storage.local.set({ "pw": event.target.result.pw })
                        .then(() => {});
                };
            };
            return true;
        });

    Parameters:
        pdg: the PDG in which to look for chrome.storage.local.set(), ... calls
        storage_areas: should be "local|sync" for BP code (default), "local|sync|session" for CS code; the reason being
                       that the session storage isn't exposed to content scripts by default
                       (cf. https://developer.chrome.com/docs/extensions/reference/api/storage#storage_areas)
    """
    result: List[Node] = []

    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")  # ToDo: handle chrome['storage'] MemberExpressions!!!
                                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.storage
                                    # e.g., "chrome", "browser", "this.browser", "this._namespace", ...
                                    # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                    # calling "runtime.onMessage" doesn't work!
                                    .child(Node.identifier("storage"))
                            )
                            .child(Node.identifier_regex(storage_areas))
                            # => "managed" is read-only & "session" inaccessible to the CS (by default)
                    )
                    .child(Node.identifier("set"))  # e.g.: "get|set|getBytesInUse|remove"
            )

    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant
                                          match_operators=False,  # irrelevant
                                          allow_additional_children=True,  # important!
                                          allow_different_child_order=False):
        call_expr: Node = pattern_match
        assert call_expr.name == "CallExpression"
        # interface CallExpression {
        #     callee: Expression | Import;
        #     arguments: ArgumentListElement[];
        # }
        callee: Node = call_expr.get("callee")[0]
        arguments: List[Node] = call_expr.get("arguments")

        if (callee.name == "MemberExpression" and callee.rhs().name == "Identifier"
                and callee.rhs().attributes['name'] == "set" and len(arguments) > 0):
            # Note that we're excluding CallExpressions w/o arguments as they cannot act as a sink for anything!
            result.append(callee.rhs())  # appends the "set" Identifier to the result list

    return result


def detect_43_32_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Detects 4.3-type vulnerabilities ("Read Sensitive Extension Data") in the background page/service worker.
    Security Requirement Violation: 3.2 Non-sensitive Data in Extension Storage

    Example:
        chrome.action.onClicked.addListener(() => {
            const openReq = indexedDB.open("account_db", 2);
            openReq.onsuccess = (event) => {
                const db = event.target.result;
                db.transaction("accounts")
                  .objectStore("accounts")
                  .get("Alice").onsuccess = (event) => {
                    chrome.storage.local.set({ "pw": event.target.result.pw })
                        .then(() => {});
                };
            };
            return true;
        });
    """
    start = timeit.default_timer()

    # ##### ##### Sources: ##### #####
    indexedDB_sources: List[Node] = get_all_indexedDB_identifiers(pdg_bp)
    sources: List[Node] = indexedDB_sources

    # ##### ##### Sinks: ##### #####
    storage_sinks: List[Node] = get_all_storage_sinks(pdg_bp)
    sinks: List[Node] = storage_sinks

    print(f"[3.2+4.3] No. of sources: {len(sources)}")
    print(f"\t=> No. of indexedDB sources: {len(indexedDB_sources)}")

    print(f"[3.2+4.3] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of storage sinks: {len(storage_sinks)}")

    detect_vuln(
        pdg=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression"],  # cf. detect_41_31_vuln_in_bp_no_uxss()
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.3/3.2 vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.3/3.2 vulnerabilities"] = time_diff


def get_extension_storage_accesses(pdg: Node,
                                   is_cs: bool,
                                   benchmarks: dict,
                                   storage_areas: str = "local|sync|session|managed",
                                   access_methods: str = "get|set|getBytesInUse|remove") -> dict:
    """
    Detects (candidates for!) extension-storage-based(!) 4.3-type vulnerabilities ("Read Sensitive Extension Data").
    Security Requirement Violation:             3.2 Non-sensitive Data in Extension Storage
                                    + possibly: 3.3 Non-sensitive Data in Content Script (Attacker_R)
                                                (only if the given `pdg` is from the CS)
    (refer to Kim and Lee paper for more info)

    Parameters:
        pdg: the PDG in which to look for all extension storage accesses
        is_cs: whether the given PDG is the PDG of a content script
               (set to False for background page/service worker PDGs)
        benchmarks: the benchmark dictionary in which to store the no. of seconds this function took to execute
        storage_areas: a regular expression listing all storage areas to consider;
                       possible storage areas are: "local", "sync", "session", "managed"
                       (cf. https://developer.chrome.com/docs/extensions/reference/api/storage);
                       default: "local|sync|session|managed"
        access_methods: a regular expression listing all access methods to consider
                        (cf. https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea);
                        supported access methods are: "get", "set", "getBytesInUse", "remove";
                        default: "get|set|getBytesInUse|remove"

    Returns:
        a dictionary, e.g.,
        {
            "local": {
                "password": {
                    "access_methods": ["get", "set"],
                    "values": ["123456"],
                    "locations": ["123:10 - 123:50", "456:20 - 456:60"]
                }
            }
        }
    """
    start = timeit.default_timer()

    pattern = \
        Node("CallExpression") \
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")  # ToDo: handle chrome['storage'] MemberExpressions!!!
                                .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.storage
                                # e.g., "chrome", "browser", "this.browser", "this._namespace", ...
                                # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                # calling "runtime.onMessage" doesn't work!
                                .child(Node.identifier("storage"))
                            )
                            .child(Node.identifier_regex(storage_areas))  # e.g.: "local|sync"
                    )
                    .child(Node.identifier_regex(access_methods))  # e.g.: "get|set|getBytesInUse|remove"
            )

    result = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    # => e.g.: result["local"]["password"]["access_methods"].append("get")

    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant
                                          match_operators=False,  # irrelevant
                                          allow_additional_children=True,  # important!
                                          allow_different_child_order=False):
        call_expr: Node = pattern_match
        assert call_expr.name == "CallExpression"
        # interface CallExpression {
        #     callee: Expression | Import;
        #     arguments: ArgumentListElement[];
        # }
        callee: Node = call_expr.get("callee")[0]
        arguments: List[Node] = call_expr.get("arguments")

        if callee.name == "MemberExpression" and len(arguments) > 0:  # ToDo: remove redundant double-checking of len(args) > 0 (see below)!
            try:
                access_method: str = callee.rhs().attributes['name']  # "get", "set", "getBytesInUse", "remove"
                assert re.fullmatch(access_methods, access_method)

                storage_area: str = callee.lhs().rhs().attributes['name']  # "local", "sync", "session", "managed"
                assert re.fullmatch(storage_areas, storage_area)

                # From https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea:
                # - get: (keys?: string | string[] | object, callback?: function) => {...}
                #   -> keys: "A single key to get, list of keys to get, or a dictionary specifying default values"
                # - getBytesInUse: (keys?: string | string[], callback?: function) => {...}
                #   -> keys: "A single key or list of keys to get the total usage for."
                # - remove: (keys: string | string[], callback?: function) => {...}
                #   -> keys: "A single key or a list of keys for items to remove."
                # - set: (items: object, callback?: function) => {...}
                #   -> items: "An object which gives each key/value pair to update storage with."
                #
                # Note that we treat all of these in the same way, because...:
                #     1. the argument containing our data of interest is always the 0th argument
                #     2. it's always one of string | string[] | object
                #     3. we treat default values and assigned values the same, we only want to collect values :)
                #
                # *** Examples: ***
                # chrome.storage.local.set({ key: value }).then(() => {
                #   console.log("Value is set");
                # });
                #
                # chrome.storage.local.get(["key"]).then((result) => {
                #   console.log("Value is " + result.key);
                # });

                args: List[Node] = call_expr.call_expression_get_all_arguments()
                if len(args) > 0:
                    keys_param: Node = args[0]
                    try:
                        keys = keys_param.static_eval(allow_partial_eval=True)  # turns a JS into a Python object :)

                        if isinstance(keys, (str, list)):  # string | string[]
                            keys: list = keys if isinstance(keys, list) else [keys]  # string[]
                            for key in keys:  # string
                                if isinstance(key, str):
                                    # Append to "access_methods" field:
                                    result[storage_area][key]["access_methods"].append(access_method)
                                    # Appending to "values" is not applicable here:
                                    # ---
                                    # Append to "locations" field:
                                    result[storage_area][key]["locations"].append(keys_param.get_location())
                                else:
                                    print(f"[Warning] invalid key parameter; not a string: {key}")
                                    continue
                        elif isinstance(keys, dict):  # object
                            for key, value in keys.items():
                                # Append to "access_methods" field:
                                result[storage_area][key]["access_methods"].append(access_method)
                                # Append to "values" field (default value given; if possible):
                                if value is not None:  # `value` will be None if static eval failed partially
                                    result[storage_area][key]["values"].append(value)
                                # Append to "locations" field:
                                result[storage_area][key]["locations"].append(keys_param.get_location())
                        else:
                            print(f"[Warning] was able to statically evaluate keys parameter of extension storage "
                                  f"access in line {keys_param.get_line()} but type is none of the permitted types "
                                  f"(string | string[] | object): {type(keys)} (value: {keys})")
                            continue

                    except StaticEvalException:
                        # The argument cannot be evaluated statically, try luck again with the next pattern found...
                        continue
                    except Exception:
                        # Some other type of exception during static evaluation, print stack trace and then continue...
                        traceback.print_exc()
                        continue

            except (LHSException, RHSException, KeyError):  # When one of .lhs(), .rhs() or .attributes['name'] fails:
                continue

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed PDG for (possible) 4.3/3.2/(3.3) extension storage accesses in {time_diff}s')
    benchmarks[f"{'cs' if is_cs else 'bp'}: 4.3/3.2{'/3.3' if is_cs else ''} extension storage accesses"] = time_diff
    # 4.3 = vulnerability type             = Read Sensitive Extension Data
    # 3.2 = security requirement violation = Non-sensitive Data in Extension Storage
    # 3.3 = security requirement violation = Non-sensitive Data in Content Script (Attacker_R)

    return utility.nested_default_dicts_to_nested_dicts(result)
    # NOTE: Turning defaultdicts into dicts is crucial, otherwise multiprocessing cannot serialize them...


# ToDo: detect 4.3/3.1 vulnerabilities, too! (data flows in the BP from indexedDB into an ext. msg to the CS)
