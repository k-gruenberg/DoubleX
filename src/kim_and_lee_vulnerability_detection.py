import os
import logging
import timeit
import json
import re
from typing import List, Self, Dict

import tldextract

import pdg_js.utility_df as utility_df

from extension_communication import build_extension_pdg
import utility
from pdg_js.node import Node, Identifier
from DataFlow import DataFlow
from DoubleDataFlow import DoubleDataFlow
from vulnerability_detection import store_analysis_results, default
from add_missing_data_flow_edges import add_missing_data_flow_edges

PRINT_DEBUG = utility.PRINT_DEBUG


def analyze_extension(cs_path, bp_path, json_analysis=None, pdg=False, chrome=True, war=False,
                      json_messages=None, json_apis='permissions', manifest_path=None, return_result=True,
                      store_result_as_json_file=True, print_result=False):
    # Note pdg=True if the PDGs have already been generated!

    res_dict = dict()
    extension_path = res_dict['extension'] = os.path.dirname(cs_path)
    benchmarks = res_dict['benchmarks'] = dict()
    messages_dict = dict()

    if manifest_path is None:
        manifest_path = os.path.join(extension_path, 'manifest.json')

    # cf. check_permissions.py:permission_check() and check_permissions.py:permission_check_v3():
    try:
        manifest = json.load(open(manifest_path))
        res_dict['manifest_version'] = manifest['manifest_version']
        if 'content_scripts' in manifest:
            urls = [cs['matches'] for cs in manifest['content_scripts']]
            res_dict['content_script_injected_into'] = [x for xs in urls for x in xs]  # flatten list of lists of URLs
        else:
            res_dict['content_script_injected_into'] = []
    except FileNotFoundError:
        logging.critical('No manifest file found in %s', manifest_path)

    pdg_cs, pdg_bp = build_extension_pdg(cs_path=cs_path, bp_path=bp_path, benchmarks=benchmarks,
                                         pdg=pdg, chrome=chrome, messages_dict=messages_dict)

    logging.info('Finished to link CS with BP using the message passing APIs')

    # ToDo: stop linking messages; allow either of the two parses (CS/BP) to fail (!!!)

    no_added_df_edges_cs = add_missing_data_flow_edges(pdg_cs)
    print(f"{no_added_df_edges_cs} missing data flows edges added to CS PDG")
    no_added_df_edges_bp = add_missing_data_flow_edges(pdg_bp)
    print(f"{no_added_df_edges_bp} missing data flows edges added to BP PDG")

    if os.environ.get('PRINT_PDGS') == "yes":
        print()
        print(f"PDG (CS):\n{pdg_cs}")  # <pdg_js.node.Node object>
        print()
        print(f"PDG (BP):\n{pdg_bp}")
        print()

    res_dict["bp"] = dict()
    bp_exfiltration_dangers = res_dict["bp"]['exfiltration_dangers'] = []
    bp_infiltration_dangers = res_dict["bp"]['infiltration_dangers'] = []
    if os.environ.get('INCLUDE_31_VIOLATIONS_WITHOUT_PRIVILEGED_API_ACCESS') == "yes":
        bp_31_violations_without_sensitive_api_access = res_dict["bp"]['31_violations_without_sensitive_api_access'] = []

    res_dict["cs"] = dict()
    cs_exfiltration_dangers = res_dict["cs"]['exfiltration_dangers'] = []
    cs_infiltration_dangers = res_dict["cs"]['infiltration_dangers'] = []

    try:
        with utility_df.Timeout(600):  # Tries to analyze an extension within 10 minutes
            detect_41_31_vuln_in_bp(pdg_bp=pdg_bp, results=bp_exfiltration_dangers, benchmarks=benchmarks, uxss=False)
            #detect_41_31_vuln_in_bp(pdg_bp=pdg_bp, res_dict=bp_infiltration_dict, uxss=True) # ToDo
            if os.environ.get('INCLUDE_31_VIOLATIONS_WITHOUT_PRIVILEGED_API_ACCESS') == "yes":
                detect_31_vuln_in_bp(pdg_bp=pdg_bp,
                                     results=bp_31_violations_without_sensitive_api_access,
                                     benchmarks=benchmarks)

    except utility_df.Timeout.Timeout:
        logging.exception('Analyzing the extension timed out for %s %s', cs_path, bp_path)
        if 'crashes' not in benchmarks:
            benchmarks['crashes'] = []
        benchmarks['crashes'].append('extension-analysis-timeout')

    if print_result or PRINT_DEBUG:
        print(json.dumps(res_dict, indent=4, sort_keys=False, default=default, skipkeys=True))
    if store_result_as_json_file:
        store_analysis_results(extension_path, json_analysis, json_messages,
                               res_dict, messages_dict, outfile_name="analysis_renderer_attacker.json")
    if return_result:
        return res_dict


# chrome.cookies.getAll(
#   details: object,
#   callback?: function,    // (cookies: Cookie[]) => void
# )
# // Returns: Promise<Cookie[]>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
# => https://developer.chrome.com/docs/extensions/reference/api/cookies
CHROME_COOKIES_GET_ALL_PATTERN =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(Node.identifier("chrome"))  # ToDo: handle programmer aliasing chrome.cookies.getAll
                            .child(Node.identifier("cookies"))
                    )
                    .child(
                        Node.identifier("getAll")
                    )
            )

# chrome.cookies.get(
#   details: CookieDetails,
#   callback?: function,       // (cookie?: Cookie) => void
# )
# // Returns: Promise<Cookie | undefined>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
CHROME_COOKIES_GET_PATTERN =\
        Node("CallExpression") \
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(Node.identifier("chrome"))  # ToDo: handle programmer aliasing chrome.cookies.getAll
                            .child(Node.identifier("cookies"))
                    )
                    .child(
                        Node.identifier("get")
                    )
            )

COOKIE_PATTERNS = [CHROME_COOKIES_GET_ALL_PATTERN, CHROME_COOKIES_GET_PATTERN]


def get_all_cookie_response_identifiers(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "cookie" (or arbitrarily named) identifiers coming from a
    ```
    chrome.cookies.getAll({}, function(cookies) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.getAll({}, (cookies) => { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, function(cookie) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, (cookie) => { /* ... */ });
    ```
    call.
    All these identifiers potentially contain very sensitive cookie data and shall not get into a
    content-script-accessible sink w/o proper authentication of the content script's URL!

    Also, one can also use the Promise returned by chrome.cookies.getAll()/get(); either by awaiting it:
    ```
    (async () => {
        let cookies = await chrome.cookies.getAll({});
        sendResponse(cookies);
    })();
    ```
    ...or one can call .then() on the returned Promise:
    ```
    chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });
    ```
    """
    result = []
    for pattern in COOKIE_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,   # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,
                                              allow_different_child_order=False):

            assert pattern_match.name == "CallExpression"

            no_of_args = len(pattern_match.children) - 1  # (MemberExpression, arg1, arg2, ...)
            uses_callback = (no_of_args > 1)

            if uses_callback:  # uses callback (MV2 backwards compatibility) instead of Promises, e.g.: chrome.cookies.get({}, (cookie) => { /* ... */ });

                if pattern_match.has_child("FunctionExpression"):  # case 1: FunctionExpression:
                    function_expr: Node = pattern_match.get_child("FunctionExpression")
                    cookie_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if cookie_parameter is not None:
                        cookie_identifier = cookie_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("ArrowFunctionExpression"):  # case 2: ArrowFunctionExpression:
                    function_expr: Node = pattern_match.get_child("ArrowFunctionExpression")
                    cookie_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if cookie_parameter is not None:
                        cookie_identifier = cookie_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("Identifier") and resolve_function_references:  # case 3: Identifier:
                    # Example:
                    #         function msg_handler(msg, sender, sendResponse) {
                    #             function cookies_handler(cookies) {
                    #                 sendResponse(cookies);
                    #             }
                    #
                    #             chrome.cookies.getAll({}, cookies_handler);
                    #             return true;
                    #         }
                    #
                    #         chrome.runtime.onMessage.addListener(msg_handler);
                    function_reference = pattern_match.get_child("Identifier")
                    function_declaration = function_reference.function_Identifier_get_FunctionDeclaration(True)
                    if function_declaration is None:
                        print(f"[Warning] couldn't resolve function reference '{function_reference.attributes['name']}' "
                              f"in line {function_reference.get_line()}, file {function_reference.get_file()}, in "
                              f"chrome.cookies.get()/getAll() call!")
                    else:
                        assert function_declaration.name == "FunctionDeclaration"
                        # [1] [FunctionDeclaration] (3 children) --e--> [4]
                        # 			[2] [Identifier:"cookies_handler"] (0 children) --data--> [...]
                        # 			[3] [Identifier:"cookies"] (0 children) --data--> [...]
                        # 			[4] [BlockStatement] (1 child) --e--> [5]
                        # Note that one cannot simply take index X here as hoisted functions can create arbitrarily many
                        #   more children inside a FunctionDeclaration, e.g.: "function foo() { function bar() {} }":
                        # [1] [FunctionDeclaration] (3 children) --e--> [4] --e--> [3]
                        # 		[4] [FunctionDeclaration] (2 children) --e--> [6]
                        # 			[5] [Identifier:"bar"] (0 children)
                        # 			[6] [BlockStatement] (0 children)
                        # 		[2] [Identifier:"foo"] (0 children)
                        # 		[3] [BlockStatement] (0 children)
                        function_declaration_params = function_declaration.function_declaration_get_params()
                        if len(function_declaration_params) >= 1:
                            cookie_parameter = function_declaration_params[0]
                            # Note that the cookies_handler might also contain more redundant parameters, the cookie(s)
                            #   parameter however will always be at index 1.

                            # A FunctionParameter of a FunctionDeclaration may be one of the following types:
                            #     type FunctionParameter = AssignmentPattern | Identifier | BindingPattern;
                            # where:
                            #     type BindingPattern = ArrayPattern | ObjectPattern;
                            #
                            # * function cookies_handler(cookies) { ... }
                            # * function cookies_handler(cookies=null) { ... }
                            # * function cookies_handler({a:b, x:y}) { ... }
                            # * function cookies_handler([x,y]) { ... }
                            #
                            # The function_param_get_identifier() and function_param_get_identifiers() methods however
                            #   handle this for us!
                            cookie_identifier = cookie_parameter.function_param_get_identifier()  # `cookies`, for both `cookies` and `cookies=null`
                            if cookie_identifier is not None:
                                result.append(cookie_identifier)
                            else:
                                print(f"[Warning] Cookie parameter in line {cookie_parameter.get_line()}, file "
                                      f"{cookie_parameter.get_file()} has unexpected form: {cookie_parameter.name}")
                            # ToDo: handle cookie destructurings using cookie_parameter.function_param_get_identifiers() ?!

                else:
                    print(f"[Warning] couldn't identify cookie identifier for chrome.cookies.get()/getAll() call "
                          f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                          f"function call has no function expression, no arrow function expression and no identifier child")

            else:  # uses Promise instead of callback, e.g.: chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });

                all_then_calls = pattern_match.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
                for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
                    result.extend(then_call.then_call_get_param_identifiers())

    return result


def get_all_cookie_function_identifiers(pdg: Node) -> List[Node]:
    result = []
    for pattern in COOKIE_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,
                                              allow_different_child_order=False):
            assert pattern_match.name == "CallExpression"
            function_identifier = pattern_match.get_child("MemberExpression").rhs()  # "get" or "getAll"
            result.append(function_identifier)
    return result


def get_all_fetch_response_identifiers(pdg: Node, all_fetch_identifiers=None) -> List[Node]:
    """
    Returns all "response1", "response2", "response3", etc. (or arbitrarily named) identifiers coming from a
    ```
    fetch('https://example.com/')
        .then((response1) => response1.json())
        .then((response2, response3) => console.log(response2, response3));
    ```
    call.

    Note that while, in the example above, there are data flows from "response1", "response2" and "response3",
    there is no outgoing data flow from "fetch"; cf. get_all_fetch_identifiers() for cases where that might be of
    interest!

    Note that because of "then"-chaining, the returned identifiers may be of any arbitrary data type!

    Note that, as each then() call returns another Promise, the example above might also be the RHS of an
    AssignmentExpression!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker
        all_fetch_identifiers: optional, the result of `get_all_fetch_identifiers(pdg=pdg)`
                               (to avoid duplicate code calling)

    Returns:
        a list of Identifier Nodes, the concatenated (lambda/function) arguments of each then() call
    """
    if all_fetch_identifiers is None:
        all_fetch_identifiers = get_all_fetch_identifiers(pdg=pdg)

    result = []

    for fetch_identifier in all_fetch_identifiers:
        call_expression = fetch_identifier.get_parent(["CallExpression"])
        all_then_calls = call_expression.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
        for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
            result.extend(then_call.then_call_get_param_identifiers())

    return result


def get_all_fetch_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all "fetch" identifiers coming from the 0th child of a CallExpression, such as
    ```
    response1 = await fetch(url);
    ```
    or
    ```
    response1 = fetch(url);
    ```
    or
    ```
    response1 = yield fetch(url, options);
    ```
    call.

    Note that in all of these cases there is a --data--> flow edge from the "fetch" identifier to the "response1"
    identifier, meaning you can directly follow any data flow from the returned "fetch" identifiers!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker

    Returns:
        a list of Identifier Nodes whose name is "fetch"
    """
    pattern1 =\
        Node("CallExpression")\
            .child(
                Node.identifier("fetch")  # ToDo: handle aliasing of "fetch", e.g., "foobar = fetch; foobar(...);"
            )

    patterns = [pattern1]

    if os.environ.get('PRINT_PDGS') == "yes":
        for i in range(len(patterns)):
            pattern = patterns[i]
            print(f"Fetch Identifier Pattern #{i + 1}:\n{pattern}")

    result = []
    for pattern in patterns:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,
                                              allow_different_child_order=False):
            if (len(pattern_match.children) in [2, 3]  # either "fetch(resource)" or "fetch(resource, options)"
                and pattern_match.children[0].name == "Identifier"
                    and pattern_match.children[0].attributes['name'] == "fetch"):  # ensure it's not, for example, "foo(fetch)"
                result.append(pattern_match.children[0])  # "fetch"
    return result


def get_all_sendResponse_sinks(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "sendResponse" (or arbitrarily named) identifiers coming from a
    ```
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { /* ... */ });
    ```
    or
    ```
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { /* ... */ });
    ```
    call.
    All these identifiers describe content-script-accessible sinks!
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.identifier("chrome"))   # Note that the "chrome" is necessary, simply  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    .child(Node.identifier("runtime"))  # calling "runtime.onMessage" doesn't work!
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )
            #.child(
            #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
            #)

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"SendResponse Pattern #1:\n{pattern}")

    result = []

    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        assert pattern_match.name == "CallExpression"
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onMessage.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        callback_arg: Node = args[0]
        try:
            # listener arguments are:
            #   0. message
            #   1. sender
            #   2. sendResponse
            # (programmer might add redundant additional arguments, but they don't matter)
            result.append(callback_arg.functional_arg_get_arg(2, resolve_arg_to_identifier=True))
        except IndexError:
            # There is no argument at index no. 2 => there is no sendResponse sink to return.
            # The programmer may easily leave out trailing parameters: either (message, sender) or just (message).
            # An example for this would be: chrome.runtime.onMessage.addListener((message) => { /* ... */ });
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onMessage.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify sendResponse sink for chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return result


def get_all_port_postMessage_sinks(pdg: Node) -> List[Node]:
    """
    Returns all "port.postMessage" sinks, referring to the "postMessage" method of a port given by
    chrome.runtime.onConnect.addListener(); an example:

    ```
    chrome.runtime.onConnect.addListener(port => {
        port.postMessage("pong");
    });
    ```
    => cf. /oocalimimngaihdkbihfgmpkcpnmlaoa-3.4.0-Crx4Chrome.com/background.js ("Netflix Party is now Teleparty")

    Returns:
        a list of MemberExpressions (LHS = identifier with data flow from "port"; RHS = "postMessage" Identifier)
        whose parents are CallExpressions
    """
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=de#event-onConnect:
    # chrome.runtime.onConnect.addListener(
    #   callback: function,                    // (port: Port) => void
    # )
    #
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=en#type-Port:
    # * Port.name:                             string                  => irrelevant
    # * Port.onDisconnect(callback: function): Event<functionvoidvoid> => irrelevant, no data flow
    # * Port.onMessage(callback: function):    Event<functionvoidvoid> => will be relevant for INFILTRATION/UXSS dangers
    # * Port.sender:                           MessageSender           => relevant for auth check: origin, tab, url
    # * Port.disconnect():                     void                    => irrelevant, no data flow
    # * Port.postMessage(message: any):        void                    => relevant here, for EXFILTRATION dangers!!!
    pattern = \
        Node("CallExpression") \
            .child(
            Node("MemberExpression")
            .child(
                Node("MemberExpression")
                .child(
                    Node("MemberExpression")
                    .child(Node.identifier("chrome"))  # ToDo: handle programmer aliasing chrome.runtime.onConnect
                    .child(Node.identifier("runtime"))
                )
                .child(Node.identifier("onConnect"))
            )
            .child(
                Node.identifier("addListener")
            )
        )
    # .child(
    #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
    # )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"onConnect Pattern #1:\n{pattern}")

    postMessage_sinks = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        # pattern_match = "chrome.runtime.onConnect.addListener(port => { port.postMessage("pong"); });"
        assert pattern_match.name == "CallExpression"
        # args = ["port => { port.postMessage("pong"); }"]
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onConnect.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        # callback_arg = "port => { port.postMessage("pong"); }"
        callback_arg: Node = args[0]
        try:
            # port_argument = "port"
            port_argument: Node = callback_arg.functional_arg_get_arg(0, resolve_arg_to_identifier=True)
            port_data_flows: List[DataFlow] = DataFlow.all_continued_beginning_at(port_argument)
            for port_data_flow in port_data_flows:
                for identifier_node in port_data_flow.nodes:
                    # "port.postMessage(x);" becomes:
                    # [1] [CallExpression] (2 children)
                    # 	[2] [MemberExpression:"False"] (2 children)      <----- return value
                    # 		[3] [Identifier:"port"] (0 children)         <----- identifier_node
                    # 		[4] [Identifier:"postMessage"] (0 children)
                    # 	[5] [Identifier:"x"] (0 children)
                    if (identifier_node.parent.name == "MemberExpression" # ToDo: handle the 2 different cases of MemberExpressions, i.e. also handle port['postMessage']
                            and identifier_node.grandparent().name == "CallExpression"
                            and identifier_node.parent.lhs() == identifier_node
                            and identifier_node.parent.rhs().name == "Identifier"
                            and identifier_node.parent.rhs().attributes['name'] == "postMessage"):
                        # found "port.postMessage(...);" call, return the "port.postMessage" MemberExpression:
                        postMessage_sinks.append(identifier_node.parent)
        except IndexError:
            # There is no argument at index no. 0 => there is no "port" argument to use further.
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onConnect.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify port sink for chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return postMessage_sinks


def get_all_message_listeners(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all message listeners in the given PDG.
    More precisely:
    Returns for all `x` for all `chrome.runtime.onMessage.addListener(x)` calls.
    Those xs returned should usually be one of the following:
    * a FunctionExpression
    * an ArrowFunctionExpression
    * a FunctionDeclaration (if resolve_function_references=True, which is the default)
    * an Identifier (if resolve_function_references=False, or when resolving a function reference failed!)
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.identifier("chrome"))   # Note that the "chrome" is necessary, simply  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    .child(Node.identifier("runtime"))  # calling "runtime.onMessage" doesn't work!
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Get All Message Listeners Pattern #1:\n{pattern}")

    result = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        if len(pattern_match.children) >= 2:
            x = pattern_match.children[1]  # the `x` in `chrome.runtime.onMessage.addListener(x)`

            # Resolve function references if parameter resolve_function_references=True:
            if x.name == "Identifier" and resolve_function_references:
                function_declaration = x.function_Identifier_get_FunctionDeclaration(True)
                if function_declaration is None:
                    result.append(x)
                else:
                    assert function_declaration.name == "FunctionDeclaration"
                    result.append(function_declaration)

                # function foo(x,y,z) {}
                # chrome.runtime.onMessage.addListener(foo);
                #
                # [1] [Program] (2 children)
                # 	[2] [FunctionDeclaration] (5 children) --e--> [7]             <-----
                # 		[3] [Identifier:"foo"] (0 children) --data--> [17]        <-----
                # 		[4] [Identifier:"x"] (0 children)
                # 		[5] [Identifier:"y"] (0 children)
                # 		[6] [Identifier:"z"] (0 children)
                # 		[7] [BlockStatement] (0 children)
                # 	[8] [ExpressionStatement] (1 child)
                # 		[9] [CallExpression] (2 children)
                # 			[10] [MemberExpression] (2 children)
                # 				[11] [MemberExpression] (2 children)
                # 					[12] [MemberExpression] (2 children)
                # 						[13] [Identifier:"chrome"] (0 children)
                # 						[14] [Identifier:"runtime"] (0 children)
                # 					[15] [Identifier:"onMessage"] (0 children)
                # 				[16] [Identifier:"addListener"] (0 children)
                # 			[17] [Identifier:"foo"] (0 children)                  <-----

            else:
                result.append(x)

        # If len(pattern_match.children) < 2, we have a "chrome.runtime.onMessage.addListener()" call, i.e., the
        #   argument is missing!

    return result


def data_flows_into_function(pdg: Node, from_node: Node, to_node: Node, return_multiple=True) -> List[DoubleDataFlow]:
    """
    Returns the empty list `[]` if no data flow exists from `from_node` to `to_node`.
    Otherwise, returns the data flow(s) from `from_node` to `to_node` as DoubleDataFlow objects.
    Each such DoubleDataFlow consists of:
    * a "from_flow" (from `from_node` to a "CallExpression"), and
    * a "to_flow" (from `to_node` to the *same* "CallExpression").

    Parameters:
        pdg: the entire PDG
        from_node: an Identifier Node of a value containing sensitive data (e.g., cookies);
                   alternatively: an ObjectPattern (equivalent to calling this function on each Property/Identifier in
                                                    that ObjectPattern separately)
        to_node: an Identifier Node of a function representing a dangerous sink (e.g., sendResponse);
                 may also be a MemberExpression (e.g., port.postMessage), no data flow will be followed then, however
        return_multiple: a boolean indicating whether to return multiple data flows if multiple data flows exist from
                         the given `from_node` to the given `to_node`; when set to False, the returned list will either
                         be empty or contain exactly 1 element; when set to True, the returned list can have arbitrary
                         length;
                         set to True when you later want to filter the returned data flows, e.g., only for the
                         unprotected/un-checked/un-sanitized ones (!!!)

    Returns:
        Returns the empty list `[]` if no data flow exists from `from_node` to `to_node`.
        Otherwise, returns the data flow(s) from `from_node` to `to_node` as DoubleDataFlow objects.
    """
    assert to_node.name in ["Identifier", "MemberExpression"] # ToDo: handle MemberExpression

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Looking for data flow in PDG [{pdg.id}] from node [{from_node.id}] to function [{to_node.id}] ...")

    data_flows_from = DataFlow.all_continued_beginning_at(from_node)  # from_node may be an ObjectPattern

    data_flows_to = DataFlow.beginning_at(to_node)[0].get_all_continued_flows()\
                        if to_node.name == "Identifier"\
                        else [DataFlow.pseudo(to_node)]
    # No actual data flow may begin at a MemberExpression, hence a "pseudo" data flow!

    # Check if any data flow from `data_flows_from` and any data flow from `data_flows_to` end up in the same
    #   CallExpression; if so return both of these data flows:
    results = []
    for from_flow in data_flows_from: # ToDo: what if data flow continues beyond the CallExpression, e.g., when the function's return value is used?!!! => it's not enough to just check each last_node() then!!!
        for to_flow in data_flows_to:
            if from_flow.last_node().parent.id == to_flow.last_node().parent.id and from_flow.last_node().parent.name == "CallExpression":
                result = DoubleDataFlow(from_flow=from_flow, to_flow=to_flow)
                if return_multiple:
                    results.append(result)
                else:
                    result.data_flow_number = f"1/1+"  # meaning: 1st data flow of 1 (or more) total data flows
                    return [result]

    for i in range(len(results)):
        results[i].data_flow_number = f"{i+1}/{len(results)}"

    return results


def expression_correctly_verifies_sender_object(test_expression: Node, sender_object_node: Node) -> bool:  # ToDo
    """
    Helper function for expression_correctly_verifies_sender().
    Unlike for the `sender_node` of expression_correctly_verifies_sender(), we already know here that the
    `sender_object_node` is *directly* the "sender" object (with .url, .tab.url, .origin, etc. attributes), and not,
    for example, already some attribute/member of it (like sender.url).

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender?!
        sender_object_node: the part of the `test_expression` representing the sender
                            (has .url, .tab.url and .origin attributes, among others)

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender, False otherwise.
    """
    return False


def is_safe_url_prefix(url_prefix: str) -> bool:
    """
    E.g., "https://admin.com/" is a safe URL prefix but "https://admin.com" (w/o the trailing slash) isn't!
    "https://" on its own is also an unsafe prefix!
    Note that the prefix doesn't have to end with a slash though, "https://admin.com/foo" is also a safe URL prefix.
    """
    if os.environ.get('CONSIDER_HTTP_AS_SAFE') == "yes":
        return re.fullmatch("^https?://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    else:
        return re.fullmatch("^https://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    # Checking that the URL has an http:// prefix is still considered an insecure verification of the sender as the
    #   authenticity of such a sender still cannot be guaranteed. A renderer attacker + network attacker would still be
    #   able to exploit the vulnerability in the extension!
    # This default behavior is only deactivated when the user supplies the --consider-http-as-safe argument.


def is_safe_origin_suffix(origin_suffix: str) -> bool:
    """
    E.g., ".admin.com" and ".admin.co.uk" are safe origin suffixes but "admin.com" and ".co.uk" aren't!
    "/admin.com", "//admin.com", "://admin.com" and "https://admin.com" can also be considered safe suffixes
    (but not "http://admin.com", see below).

    Note that by using Mozilla's Public Suffix List (PSL) (https://publicsuffix.org/), we can identify a danger even
    when the code checks for a suffix like ".blogspot.com" for example!

    Note that even a triple-suffix like ".sth.ac.at" can be available for public registration and hence unsafe!
    """
    if "http://" in origin_suffix:
        # The origin is essentially checked to be equal to a http:// domain, this means that the entire origin check
        #   is essentially pointless though, since all HTTP communication can be manipulated anyways.
        return False
    elif "/" in origin_suffix:
        # As the sender.origin will never contain a slash except for the one from "https://",
        #   if there's a "/" in the origin suffix check, this always means there's essentially a check on the entire
        #   origin!
        return True
    elif "." not in origin_suffix:
        return False  # e.g. simply suffix check for "com" => not even REMOTELY sufficient!
    else:  # e.g. ".admin.co.uk" or ".admin.com" or "foo.admin.com" (all good) or "admin.co.uk" or "admin.com" (all bad)
        actually_verified_suffix = origin_suffix[origin_suffix.index(".")+1:]  # only everything after the first "." is actually verified
        extract = tldextract.TLDExtract()
        return extract(actually_verified_suffix, include_psl_private_domains=True).domain != ''


def expression_correctly_verifies_sender_url(test_expression: Node, sender_url_node: Node) -> bool:
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender URL verifications:
    * url == "https://admin.com/"
    * url === "https://admin.com/"
    * url.startsWith("https://admin.com/")
    * ["option1", "option2"].includes(url)
    * url == "option1" | url == "option2"
    * url === "option1" || url === "option2"

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (url == "https://admin.com/" & something_else())
    * (url == "https://admin.com/" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (URL)?!
        sender_url_node: the part of the `test_expression` representing the sender URL

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender URL, False otherwise.
    """
    if not sender_url_node.lies_within(test_expression)\
            and not any(identifier.is_data_flow_equivalent_identifier(sender_url_node)
                        for identifier in test_expression.get_all_identifiers()):
        # `test_expression` cannot verify `sender_url_node` if `test_expression` does not *contain* `sender_url_node`
        #     (or at least a "data-flow-equivalent" node, take "url == 'foo' || url == 'foo'" for example where both
        #     "url" identifiers are deemed "data-flow-equivalent")
        return False

    elif test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] in ["==", "==="]:
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        if left_operand.equivalent(right_operand):
            return False  # "url == url" or "url === url" is trivially True and therefore *not* a sufficient check!
        elif sender_url_node.lies_within(left_operand) and sender_url_node.lies_within(right_operand):
            # Something like, maybe, "url == url.toLowerCase()", or "url == url.substring(0,30)",
            # or "url.length == url.substring(20,22)"
            # => all unsafe checks
            # Something like, maybe, "url == 'foo' + url" would always be False and therefore *THEORETICALLY* be a
            # good enough "protection" for a block of code. However, (a) it seems unlikely that someone would write
            # such an always-False "check" and (b) even *if*, we simply return it as a vulnerability, leaving some
            # manual verification effort for the human (as always).
            return False
        elif os.environ.get('CONSIDER_HTTP_AS_SAFE') != "yes" and\
                (left_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*") or
                 right_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*")):
            return False  # return False for "url == 'http://...'" as HTTP is unsafe!!! (renderer + network attacker)
        else:
            return True  # We assume "url == ...", "... == url", "url === ..." or "... === url" to be valid checks!

    # "url == "https://admin.com/" && something_else()"  (ONE side of the "&&" needs to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "&&"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "&":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url =\
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url or right_operand_correctly_verifies_sender_url

    # "url == "option1" || url == "option2"" (BOTH sides of the "||" need to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "||"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "|":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url and right_operand_correctly_verifies_sender_url

    # "url.startsWith("https://admin.com/")" (URL needs to end with a '/' that's *not* the slash from 'https://'!):
    #     [1] [CallExpression] (2 children)
    #         [2] [MemberExpression] (2 children)
    #             [3] [Identifier:"url"] (0 children)            == sender_url_node
    #             [4] [Identifier:"startsWith"] (0 children)
    #         [5] [Literal:""https://admin.com/""] (0 children)
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0] == sender_url_node\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "startsWith"\
            and test_expression.children[1].name == "Literal"\
            and is_safe_url_prefix(test_expression.children[1].string_literal_without_quotation_marks()):
        return True

    # "["option1", "option2"].includes(url)":
    # [1] [CallExpression] (2 children)
    #     [2] [MemberExpression] (2 children)
    #         [3] [ArrayExpression] (2 children)
    #             [4] [Literal:""option1""] (0 children)
    #             [5] [Literal:""option2""] (0 children)
    #         [6] [Identifier:"includes"] (0 children)
    #     [7] [Identifier:"url"] (0 children)             == sender_url_node
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0].name == "ArrayExpression"\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "includes"\
            and test_expression.children[1] == sender_url_node:
        return True

    else:
        return False

    # ToDo: handle UnaryExpression with '!' operator!!!


def expression_correctly_verifies_sender_origin(test_expression: Node, sender_origin_node: Node) -> bool: # ToDo
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender origin verifications:
    * origin == "https://admin.com"
    * origin === "https://admin.com"
    * origin.endsWith(".admin.com")
    * origin.endsWith(".admin.co.uk")
    * origin.endsWith("/admin.com")
    * ["option1", "option2"].includes(origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (origin == "https://admin.com" & something_else())
    * (origin == "https://admin.com" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (origin)?!
        sender_origin_node:

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender origin, False otherwise.
    """
    return False


def expression_correctly_verifies_sender(test_expression: Node, sender_node: Node, data_flow: DataFlow) -> bool:
    """
    Helper function for verifies_sender_is_safe().
    Note that it is assumed that `sender_node.lies_within(test_expression)`!
    It is also assumed that `sender_node in data_flow.nodes`!

    Note that the sender_node may be:
    (1) simply the `sender` variable from `(msg, sender, sendResponse)`
    (2) a renamed alias of it, e.g.: `let from = sender;`
    (3) a variable storing a property of the sender, e.g.: `let url = sender.url;`
    (4)                                       ...but also: `let len = sender.url.length;`
                                                       or: `let active = sender.tab.active;` (which is simply a boolean)
    (5) some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`

    Parameters:
        test_expression: the expression to check: Does it correctly *verify* the sender?!
        sender_node: the PDG node having a data flow from `sender` into it *and* lying within `test_expression`
        data_flow: the complete data from `sender` that `sender_node` is a part of

    Returns:
        a boolean indicating whether `test_expression` correctly verifies the sender
    """
    assert sender_node.lies_within(test_expression)
    assert sender_node in data_flow.nodes

    data_flow = data_flow.get_sub_flow(last_node=sender_node)
    accessed_members = data_flow.get_accessed_members(include_method_calls=False)
    if accessed_members == []:  # case (1) or (2): sender_node is still simply the sender object
        return expression_correctly_verifies_sender_object(test_expression=test_expression, sender_object_node=sender_node)
    elif accessed_members == ["url"] or accessed_members == ["tab", "url"]:  # case (3): sender_node === sender.url or sender.tab.url
        return expression_correctly_verifies_sender_url(test_expression=test_expression, sender_url_node=sender_node)
    elif accessed_members == ["origin"]:  # case (3): sender_node === sender.origin
        return expression_correctly_verifies_sender_origin(test_expression=test_expression, sender_origin_node=sender_node)
    else:
        # case (4): some other property of sender that is not useful as a safety check is used in the test_expression
        # case (5): some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`
        # Note that while this *might* still be a correct sender verification, we are in doubt and still return the
        #   vulnerability, leaving it to the human to verify the vulnerability!
        return False


def verifies_sender_is_safe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool:
    """
    Returns True if the `test_expression` Expression Node *correctly* verifies the safety of the sender stored in
    `sender_identifier_or_pattern`.

    Examples of correct sender verifications:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (sender.url == "https://admin.com/" & something_else())
    * (sender.url == "https://admin.com/" && something_else())

    Also, the sender URL/origin might have been written into another intermediary variable first:
    ```
    let url = sender.url;
    if (url == "https://admin.com/") {
        /* ... */
    }
    ```

    Also note that "sender.tab.url" may be used instead of "sender.url" as well!

    (!!!) The `test_expression` evaluating to TRUE must IMPLY that the sender is safe. (!!!)

    (!!!) The if-branch of the if-statement is safe. (!!!)
    """
    sender_identifier_data_flows = DataFlow.all_continued_beginning_at(sender_identifier_or_pattern)
    # For each data flow sender -> ... -> ... -> ...:
    for sender_identifier_data_flow in sender_identifier_data_flows:
        if os.environ.get('PRINT_PDGS') == "yes":                      #
            print(f"Sender data flow: {sender_identifier_data_flow}")  #

        # For each node in such a data flow: sender -> ... -> ... -> ...:
        #                                    |____|    |_|    |_|    |_|
        for sender_node in sender_identifier_data_flow.nodes:

            # If this node lies within the test expression of which we want to check whether it verifies sender safety:
            if sender_node.lies_within(test_expression):
                if os.environ.get('PRINT_PDGS') == "yes":                                                 #
                    print(f"\t=> [{sender_node.id}] lies within test expression [{test_expression.id}]")  #

                # Check if the `test_expression` *correctly* verifies the safety of the sender represented by `sender_node`:
                if expression_correctly_verifies_sender(test_expression, sender_node, sender_identifier_data_flow):
                    print(f"Found correct sender verification in {test_expression.get_file()}, "
                          f"line {test_expression.get_line()}: {test_expression.get_whole_line_of_code_as_string()}")
                    return True
                # Note that the sender may occur more than once inside the `test_expression`, e.g.:
                #     if (sender && sender.url == "https://admin.com/") { /* ... */ }
                #     if (sender.url.length > 18 && sender.url.startsWith("https://admin.com/")) {/ *...* /}
                # => Therefore, we cannot simply return False when expression_correctly_verifies_sender() returns False!

    # Either no flow from `sender_identifier_or_pattern` into the `test_expression` could be found,
    # or the `test_expression` did not correctly verify the `sender_identifier_or_pattern`:
    return False


def verifies_sender_is_unsafe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool: # ToDo
    """
    Note that this function does *not* simply return the opposite of the verifies_sender_is_safe() function!
    A test expression may neither verify safety *nor* non-safety of the sender, e.g., when it doesn't perform a check on
    the sender at all, doing something completely unrelated, or, when it performs in incorrect/incomplete check of the
    sender!

    Also note that a sender un-safety check may be combined with other checks in a DISJUNCTION ("|" or "||" operator)
    but NOT in a CONJUNCTION ("&" or "&&" operator), i.e., the exact opposite of the verifies_sender_is_safe() function!
    Think of it as swapping the "if" and "else" branches / negating the condition. Example:
    * (sender.url != "https://admin.com/" | something_else())
    * (sender.url != "https://admin.com/" || something_else())

    (!!!) The sender being unsafe must IMPLY that the `test_expression` evaluates to TRUE. (!!!)

    (!!!) The else-branch of the if-statement is safe. (!!!)
    """
    pass


def get_protected_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Returns all blocks of code inside the given `pdg_subtree` where the sender identifier (given as the second argument)
    is *correctly* verified.

    There are 3 different ways of sender URL/origin verification that we consider to be "correct":
    (1) checking the URL (either sender.url or sender.tab.url) or origin (sender.origin) for equality using "==" or
        "===" or using an Array.includes() call (except when checking for trivial equality to itself of course)
    (2) checking a URL prefix, prefix must contain a slash "/" other than the two slashes from "://", this ensures that
        there's an (implicit) equality check for the origin
    (3) checking the suffix of origin, such that there's an (implicit) equality check of the domain name,
        e.g., ".admin.com" or ".admin.co.uk" but not "admin.com" or ".co.uk" (!!!)

    Some examples of correct sender verifications are:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    Some examples of *incorrect* sender verifications are:
    * sender.url == sender.url
    * sender.url === sender.url
    * sender.origin == sender.origin
    * sender.origin === sender.origin
    * sender.url != "https://bad.com/"
    * sender.url !== "https://bad.com/"
    * sender.url.startsWith("https://admin.com")    sender.origin.startsWith("https://admin.com")
    * sender.url.includes("admin.com")              sender.origin.includes("admin.com")
    * sender.url.endsWith("admin.html")             sender.origin.endsWith("admin.com")
    * sender.url.endsWith(".admin.com/")            sender.origin.endsWith(".co.uk")
    * ["option1", "option2", sender.url].includes(sender.url)
    * ["option1", "option2", sender.origin].includes(sender.origin)

    Note that, instead of sender.url, sender.tab.url may be also used (extension requires the "tabs" permission though).

    Also note that sender.url, sender.tab.url or sender.origin might also flow into another variable before being
    checked!
    """
    protected_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None
        # The else_block could be another IfStatement, in that case it will *also* be enumerated by
        #     get_all_if_statements_inside().

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            protected_blocks_of_code.append(if_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and\
                else_block is not None:
            protected_blocks_of_code.append(else_block)

        # Note how this even catches the following case:
        #
        # if (sender.url != "safe.com") {
        #     /* ... */
        # } else if (something_completely_unrelated()) {
        #     /* PROTECTED BLOCK OF CODE */
        #     sendResponse(cookies);
        # }

    return protected_blocks_of_code


def get_explicitly_unsafe_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Cf. get_protected_blocks_of_code() but returns all blocks of code where it has been explicitly verified that the
    sender is *not* safe!
    """
    explicitly_unsafe_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and \
                else_block is not None:
            explicitly_unsafe_blocks_of_code.append(else_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            explicitly_unsafe_blocks_of_code.append(if_block)

    return explicitly_unsafe_blocks_of_code


def identifier_get_all_member_identifiers(identifier: Node, member_name: str, allow_method_calls=False) -> List[Node]:
    """
    Input:  (A) Identifier Node, e.g., "port"
            (B) Member name, e.g., "sender"
    Output: list of all Identifier Nodes with a data flow from "port.sender" into them
    """
    print(f"<identifier_get_all_member_identifiers(identifier={identifier})>")
    assert identifier.name == "Identifier"
    result = set()
    for data_flow_parent in identifier.get_data_flow_parents():
        for data_flow in DataFlow.all_continued_beginning_at(data_flow_parent):
            print(f"identifier_get_all_member_identifiers(): data_flow = {data_flow}")
            for node in data_flow.nodes:
                print(f"identifier_get_all_member_identifiers(): node = {node} (line {node.get_line()})")
                partial_data_flow = data_flow.get_sub_flow(first_node=None, last_node=node)
                # partial_data_flow: self --data--> ... --data--> node
                if allow_method_calls:
                    if partial_data_flow.get_accessed_members(include_method_calls=False) == [member_name]:
                        result.add(node)
                else:
                    if partial_data_flow.get_accessed_members(include_method_calls=True) == [member_name]:
                        result.add(node)
    assert all(node.name == "Identifier" for node in result)
    print(f"</identifier_get_all_member_identifiers() returns {len(result)} Nodes: {[(node.id, node.name, node.attributes['name'] if node.name == 'Identifier' else '', node.get_line()) for node in result]}>")
    return list(result)


def detect_41_31_vuln_in_bp(pdg_bp: Node, results, benchmarks, uxss=False, debug_prints=False):  # ToDo: handle uxss=True
    """
    Look for type 4.1 vulnerabilities in the given background page/service worker (or rather its PDG), type 4.1
    vulnerabilities refer to the ability to `Execute Privileged Browser APIs` w/o (sufficiently) verifying `sender.url`,
    which is a security violation of type 3.1: `Extension Message Authentication`
    (refer to Kim and Lee paper for more info)

    Example vulnerability (with no authentication of `sender.url` or `sender.tab.url` or `sender.origin` whatsoever):
    ```
    chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
        chrome.cookies.getAll({},
            function(cookies) {
                sendResponse(cookies);
            }
        );
        return true;
    });
    ```
    """
    start = timeit.default_timer()

    # ##### ##### Sources: ##### #####
    cookie_sources: List[Node] = get_all_cookie_function_identifiers(pdg_bp)
    # e.g., returns the "getAll" in "cookies1 = await chrome.cookies.getAll({});"
    #     => data flow may continue from there, first into "cookies1" and then beyond...
    cookie_response_sources: List[Node] = get_all_cookie_response_identifiers(pdg_bp)  # (optional ToDo: optimization: reuse cookie_sources result)
    # => e.g., returns the "cookies" in "chrome.cookies.getAll({}, (cookies) => { /* ... */ });",
    #          or the "cookie" in "chrome.cookies.get({}, function(cookie) { /* ... */ });"
    #          or the "cookies" in "chrome.cookies.getAll({}).then((cookies) => { /* ... */ });"
    #    => data flow may continue from there, inside the (anonymous) function...
    fetch_sources: List[Node] = get_all_fetch_identifiers(pdg_bp)
    # => e.g., returns the "fetch" in "response1 = await fetch(url);"
    #    => data flow may continue from there, first into "response1" and then beyond...
    fetch_response_sources: List[Node] = get_all_fetch_response_identifiers(pdg=pdg_bp,
                                                                            all_fetch_identifiers=fetch_sources)
    # => e.g., returns the "response1" in "fetch(url).then((response1) => console.log(response1))"
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = cookie_sources + cookie_response_sources + fetch_sources + fetch_response_sources

    # ##### ##### Sinks (plus their respective sender identifiers/patterns): ##### #####
    sendResponse_sinks: List[Node] = get_all_sendResponse_sinks(pdg_bp)  # "sendResponse" Identifiers
    port_postMessage_sinks: List[Node] = get_all_port_postMessage_sinks(pdg_bp)  # "port.postMessage" MemberExpressions
    assert all(port_postMessage_sink.parent.name == "CallExpression" for port_postMessage_sink in port_postMessage_sinks)
    sinks: Dict[Node, List[Node]] = (
            {sendResponse_sink: [sendResponse_sink.get_sibling_relative(-1)]  # (message, sender, sendResponse)
             for sendResponse_sink in sendResponse_sinks}
            |  # join dicts
            {port_postMessage_sink: identifier_get_all_member_identifiers(port_postMessage_sink.lhs(), "sender")
             for port_postMessage_sink in port_postMessage_sinks}
    )

    print(f"[3.1+4.1] No. of sources: {len(sources)}")
    print(f"\t=> No. of cookie sources: {len(cookie_sources) + len(cookie_response_sources)}")
    print(f"\t=> No. of fetch sources: {len(fetch_sources) + len(fetch_response_sources)}")
    if debug_prints:
        for i in range(len(sources)):
            src = sources[i]
            print(f"[Debug] Source #{i+1}: [{src.id}] {src.name} in line {src.get_line()}")
            if os.environ.get('PRINT_PDGS') == "yes":
                print(src)

    print(f"[3.1+4.1] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of sendResponse sinks: {len(sendResponse_sinks)}")
    print(f"\t=> No. of port.postMessage sinks: {len(port_postMessage_sinks)}")
    if debug_prints:
        counter = 1
        for sink, sender_identifiers_or_patterns in sinks.items():
            print(f"[Debug] Sink #{counter}: [{sink.id}] {sink.name} in line {sink.get_line()} => "
                  f"{len(sender_identifiers_or_patterns)} corresponding sender identifiers/patterns: "
                  f"{sender_identifiers_or_patterns}")
            counter += 1
            if os.environ.get('PRINT_PDGS') == "yes":
                print(sink)

    try:
        for source in sources:
            for sink, sender_identifiers_or_patterns in sinks.items():

                data_flows = data_flows_into_function(pdg=pdg_bp,
                                                      from_node=source,
                                                      to_node=sink,
                                                      return_multiple=(os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') == "yes" or
                                                                       os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') != "yes"))
                # We need all data flows when there are multiple ones if...:
                # (a) the user specified --return-multiple-flow-variants
                # and/or
                # (b) the check for sender verification is on, i.e., RETURN_SAFE_FLOWS_VERIFIED is OFF(!)
                #
                # In other words:
                # We can *only* refrain from searching for multiple data flow if...:
                # (a) the user did *not* specify --return-multiple-flow-variants
                # *and*
                # (b) the check for sender verification is off, i.e., RETURN_SAFE_FLOWS_VERIFIED is ON
                #     (otherwise we could potentially miss an unsafe flow if we only look for 1 flow and that one just
                #      happens to be a safe one!)

                for data_flow in data_flows:
                    if debug_prints:
                        print(f"[Debug] Data flow: {data_flow}")

                    sink_call = data_flow.from_flow.last_node().parent  # the final dangerous CallExpression
                    assert sink_call.name == "CallExpression"

                    # Logic:

                    # if any node in data_flow lies_within any protected_block_of_code:
                    #    safe
                    # elif is there a return statement before the sink call and that return statement lies_within an
                    #      explicitly_dangerous_part_of_code and the if statement it's in is on the same depth as the sink call?:
                    #    safe
                    # else:
                    #    unsafe

                    # If *any* data flow node ("to" or "from" flow) lies within *any* protected block of code,
                    #     this data flow is safe:
                    if any(any(node.lies_within(protected_block_of_code)
                                for sender_identifier_or_pattern in sender_identifiers_or_patterns
                                for protected_block_of_code in get_protected_blocks_of_code(pdg=pdg_bp,
                                                                                            pdg_subtree=pdg_bp,  # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                            sender_identifier_or_pattern=sender_identifier_or_pattern))
                                for node in data_flow.from_flow.nodes + data_flow.to_flow.nodes):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                    # If *any* return statement lies within *any* explicitly unsafe block of code that occurs before
                    #     the sink call, where if statement and sink call are on the same "indentation level", this
                    #     data flow is safe:
                    elif any(any(return_statement.lies_within(explicitly_unsafe_block_of_code)
                                 and return_statement.occurs_in_code_before(sink_call)
                                 and return_statement.get_innermost_surrounding_if_statement().is_sibling_of(sink_call)
                                 for sender_identifier_or_pattern in sender_identifiers_or_patterns
                                 for explicitly_unsafe_block_of_code in get_explicitly_unsafe_blocks_of_code(pdg=pdg_bp,
                                                                                                             pdg_subtree=pdg_bp,  # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                                             sender_identifier_or_pattern=sender_identifier_or_pattern))
                                 for return_statement in pdg_bp.get_all_return_statements_inside()):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                        # Catches:
                        #
                        # if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #     return; // return_statement // explicitly_unsafe_block_of_code
                        # }                               // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # But not:
                        #
                        # if (sender.url != "safe.com") {      // explicitly_unsafe_block_of_code
                        #     if (1==2) {                      // explicitly_unsafe_block_of_code
                        #          return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                                // explicitly_unsafe_block_of_code
                        # }                                    // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # And also not:
                        #
                        # if (1==1) {
                        #     /* ... */
                        # } else {
                        #     if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #         return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                               // explicitly_unsafe_block_of_code
                        # }
                        # sendResponse(cookies); // sink_call

                    else:
                        # unsafe
                        print(f"[4.1/3.1] Data flow found:\n{str(data_flow)}\n")
                        results.append(data_flow.as_pretty_dict())
                        if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                            raise StopIteration
    except StopIteration:
        pass

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.1/3.1 vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.1/3.1 vulnerabilities{' (UXSS)' if uxss else ''}"] = time_diff


def detect_31_vuln_in_bp(pdg_bp: Node, results, benchmarks):  # ToDo: include instances of chrome.runtime.onConnect as well!!!
    """
    Detects all violations of Kim and Lee's Security Requirement 3.1 (Extension Message Authentication),
    for which there is **NO** type 4.1 vulnerability (Execution of Privileged Browser APIs).

    An example of this would be the "Cisco Webex Extension" that violates Sec. Req. 3.1 by not authenticating
    incoming extension messages, however only resulting in the "Start Cisco Webex Meetings application", i.e.,
    something relatively harmless, no sensitive data exfiltration, no UXSS vector (cf. detect_41_31_vuln_in_bp()):

    ```
    chrome.runtime.onMessage.addListener(function(e, n) {
        if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
            var o = {
                category: "browser-extension",
                event: "launch-meeting",
                extVal: e
            };
            doi.send("Event", o, !0)
        }
    })
    ```
    (code from the Cisco WebEx Extension, version 1.17.0)

    This function shall only be executed when the user supplies the
        --include-31-violations-without-privileged-api-access
    command line argument.
    """
    start = timeit.default_timer()

    all_msg_listeners: List[Node] = get_all_message_listeners(pdg_bp, resolve_function_references=True)
    print(f"[3.1, no 4.1] {len(all_msg_listeners)} message listeners found in total (in BP).")
    for msg_listener in all_msg_listeners:
        print(f"[3.1, no 4.1] Looking at message listener in line {msg_listener.get_line()} in file "
              f"'{msg_listener.get_file()}'...")
        if msg_listener.name == "FunctionExpression":
            # [1] [FunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- optional name for FunctionExpressions!!!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "ArrowFunctionExpression":
            # [1] [ArrowFunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- hypothetical, not actually possible for ArrowFE!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "FunctionDeclaration":
            # [1] [FunctionDeclaration] (5 children) --e--> [6]
            # 		[2] [Identifier:"foo"] (0 children) --data--> [...]
            # 		[3] [Identifier:"msg"] (0 children)
            # 		[4] [Identifier:"sender"] (0 children)               <----- sender_identifier_or_pattern
            # 		[5] [Identifier:"sendResponse"] (0 children)
            # 		[6] [BlockStatement] (0 children)                    <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.function_declaration_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "Identifier":
            print(f"[3.1, no 4.1] [Warning] message listener function reference '{msg_listener.attributes['name']}' "
                  f"in line {msg_listener.get_line()}, file '{msg_listener.get_file()}', could not be resolved, "
                  f"likely missing something...")
            continue
        else:
            print(f"[3.1, no 4.1] [Warning] Unexpected Node type of message listener: {msg_listener.name}, "
                  f"likely missing something...")
            continue

        # print(f"[3.1, no 4.1] block_of_code = {block_of_code}")
        # print(f"[3.1, no 4.1] sender_identifier_or_pattern = {sender_identifier_or_pattern}")

        # For each block of code inside a message listener, add it to the result set, if:
        #     (a) the block contains no sensitive API access whatsoever
        #     (b) the block contains no (correct) sender verification whatsoever

        sensitive_apis = block_of_code.get_sensitive_apis_accessed()
        print(f"[3.1, no 4.1] {len(sensitive_apis)} sensitive APIs found.")

        protected_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_protected_blocks_of_code(pdg=pdg_bp,
                                                                         pdg_subtree=block_of_code,
                                                                         sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(protected_blocks_of_code)} protected blocks of code found.")

        explicitly_unsafe_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_explicitly_unsafe_blocks_of_code(pdg=pdg_bp,
                                                                                 pdg_subtree=block_of_code,
                                                                                 sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(explicitly_unsafe_blocks_of_code)} explicitly unsafe blocks of code found.")

        # --include-31-violations-without-privileged-api-access help text:
        #     Include violations of Security Requirement 3.1 (Extension Message Authentication),
        #         even when no privileged API (like chrome.cookies, chrome.scripting or indexedDB)
        #         is accessed (4.1).
        if (len(sensitive_apis) == 0  # no 4.1 vulnerability...
                and len(protected_blocks_of_code) == 0  # ...but still a 3.1 security requirement violation.
                and len(explicitly_unsafe_blocks_of_code) == 0):
            results.append({
                "msg_listener": {
                    "location": msg_listener.get_location(),
                    "filename": msg_listener.get_file(),
                    "line_of_code": msg_listener.get_whole_line_of_code_as_string()
                },
                "block_of_code": {
                    "location": block_of_code.get_location(),
                    "filename": block_of_code.get_file(),
                    "line_of_code": block_of_code.get_whole_line_of_code_as_string()
                }
            })

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 3.1 violations w/o privileged API access in {time_diff}s')
    benchmarks[f"bp: 3.1 violations w/o privileged API access"] = time_diff
