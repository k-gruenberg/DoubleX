import os
import logging
import timeit
import json
import re
from typing import List, Self, Dict, Optional
import time
import datetime
import traceback

import tldextract
import graphviz

import pdg_js.utility_df as utility_df

import utility
from pdg_js.node import Node, Identifier
from DataFlow import DataFlow
from DoubleDataFlow import DoubleDataFlow
from vulnerability_detection import store_analysis_results, default
from remove_incorrect_data_flow_edges import remove_incorrect_data_flow_edges
from add_missing_data_flow_edges import add_missing_data_flow_edges
import get_pdg
import display_extension
from extension_communication import update_benchmarks_pdg

from multiprocessing import Process, Queue

PRINT_DEBUG = utility.PRINT_DEBUG


def generate_pdg(whoami: str, file_path: str, benchmarks_dict: dict) -> Node:
    # Use DoubleX to generate the PDG of the file given by `file_path`:
    pdg = get_pdg.get_pdg(file_path=file_path, res_dict=benchmarks_dict)
    update_benchmarks_pdg(benchmarks=benchmarks_dict, whoami=whoami)
    # cf. build_extension_pdg() => produce_extension_pdg() (leaving out message linking!)

    # Remove data flow edges that DoubleX added incorrectly:
    start_time = time.time()
    no_removed_df_edges = remove_incorrect_data_flow_edges(pdg)
    print(f"{no_removed_df_edges} incorrect data flows edges removed from {whoami} PDG in {time.time() - start_time}s")

    # Add data flow edges that DoubleX didn't add:
    start_time = time.time()
    no_added_df_edges = add_missing_data_flow_edges(pdg)
    print(f"{no_added_df_edges} missing data flows edges added to {whoami} PDG in {time.time() - start_time}s")

    if os.environ.get('PRINT_PDGS') == "yes":
        print()
        print(f"PDG ({whoami}):\n{pdg}")  # <pdg_js.node.Node object>
        print()

    return pdg


def analyze_bp(file_path: str, bp_benchmarks_dict_queue: Queue, bp_res_dict_queue: Queue):
    bp_benchmarks_dict = dict()
    bp_res_dict = dict()

    try:

        pdg_bp: Node = generate_pdg("bp", file_path, bp_benchmarks_dict)

        bp_res_dict['code_stats'] = {
            "avg_name_len_identifiers": pdg_bp.average_identifier_length(),
            "avg_name_len_declared_vars": pdg_bp.average_declared_variable_name_length(),
            "avg_name_len_declared_funcs": pdg_bp.average_function_declaration_name_length(),
            "avg_name_len_declared_classes": pdg_bp.average_class_name_length()
        }

        bp_exfiltration_dangers = bp_res_dict['exfiltration_dangers'] = []
        bp_infiltration_dangers = bp_res_dict['infiltration_dangers'] = []

        detect_41_31_vuln_in_bp_no_uxss(pdg_bp=pdg_bp, results=bp_exfiltration_dangers, benchmarks=bp_benchmarks_dict)
        detect_41_31_vuln_in_bp_uxss(pdg_bp=pdg_bp, results=bp_infiltration_dangers, benchmarks=bp_benchmarks_dict)
        detect_42_32_vuln_in_bp(pdg_bp=pdg_bp, results=bp_infiltration_dangers, benchmarks=bp_benchmarks_dict)
        if os.environ.get('INCLUDE_31_VIOLATIONS_WITHOUT_PRIVILEGED_API_ACCESS') == "yes":
            bp_31_violations_without_sensitive_api_access = \
                bp_res_dict['31_violations_without_sensitive_api_access'] = []
            detect_31_vuln_in_bp(pdg_bp=pdg_bp,
                                 results=bp_31_violations_without_sensitive_api_access,
                                 benchmarks=bp_benchmarks_dict)

    except Exception as e:
        print(traceback.format_exc())
        if "crashes" not in bp_benchmarks_dict:
            bp_benchmarks_dict["crashes"] = list()
        bp_benchmarks_dict["crashes"].append(f"Python Exception during BP analysis: {repr(e)}")

    bp_benchmarks_dict_queue.put(bp_benchmarks_dict)
    bp_res_dict_queue.put(bp_res_dict)


def analyze_cs(file_path: str, cs_benchmarks_dict_queue: Queue, cs_res_dict_queue: Queue):
    cs_benchmarks_dict = dict()
    cs_res_dict = dict()

    try:

        pdg_cs: Node = generate_pdg("cs", file_path, cs_benchmarks_dict)

        cs_res_dict['code_stats'] = {
            "avg_name_len_identifiers": pdg_cs.average_identifier_length(),
            "avg_name_len_declared_vars": pdg_cs.average_declared_variable_name_length(),
            "avg_name_len_declared_funcs": pdg_cs.average_function_declaration_name_length(),
            "avg_name_len_declared_classes": pdg_cs.average_class_name_length()
        }

        cs_exfiltration_dangers = cs_res_dict['exfiltration_dangers'] = []
        cs_infiltration_dangers = cs_res_dict['infiltration_dangers'] = []

        # ToDo...

    except Exception as e:
        print(traceback.format_exc())
        if "crashes" not in cs_benchmarks_dict:
            cs_benchmarks_dict["crashes"] = list()
        cs_benchmarks_dict["crashes"].append(f"Python Exception during CS analysis: {repr(e)}")

    cs_benchmarks_dict_queue.put(cs_benchmarks_dict)
    cs_res_dict_queue.put(cs_res_dict)


def analyze_extension(cs_path, bp_path, json_analysis=None, pdg=False, chrome=True, war=False,
                      json_messages=None, json_apis='permissions', manifest_path=None, return_result=True,
                      store_result_as_json_file=True, print_result=False):
    # Note pdg=True if the PDGs have already been generated!

    res_dict = dict()
    extension_path = res_dict['extension'] = os.path.dirname(cs_path)
    benchmarks = res_dict['benchmarks'] = dict()
    messages_dict = dict()

    if manifest_path is None:
        manifest_path = os.path.join(extension_path, 'manifest.json')

    # cf. check_permissions.py:permission_check() and check_permissions.py:permission_check_v3():
    try:
        manifest = json.load(open(manifest_path))
        res_dict['manifest_version'] = manifest['manifest_version']
        if 'content_scripts' in manifest:
            urls = [cs['matches'] for cs in manifest['content_scripts']]
            res_dict['content_script_injected_into'] = [x for xs in urls for x in xs]  # flatten list of lists of URLs
        else:
            res_dict['content_script_injected_into'] = []
    except FileNotFoundError:
        logging.critical('No manifest file found in %s', manifest_path)

    # Start 1 process generating the BP PDG:
    bp_benchmarks_dict_queue = Queue(maxsize=1)  # = kind of an ugly way to allow the Process to return something
    bp_res_dict_queue = Queue(maxsize=1)
    bp_process = Process(target=analyze_bp, args=[bp_path, bp_benchmarks_dict_queue, bp_res_dict_queue])
    bp_process.start()

    # Start 1 process generating the CS PDG:
    cs_benchmarks_dict_queue = Queue(maxsize=1)
    cs_res_dict_queue = Queue(maxsize=1)
    cs_process = Process(target=analyze_cs, args=[cs_path, cs_benchmarks_dict_queue, cs_res_dict_queue])
    cs_process.start()

    # Wait until either both BP and CS analysis have finished, or until a timeout occurs:
    start_time = time.time()
    timeout: int = int(os.environ['TIMEOUT'])  # (in seconds)
    while time.time() - start_time < timeout:
        bp_process.join(timeout=3)
        cs_process.join(timeout=3)

        if not bp_process.is_alive() and not cs_process.is_alive():  # both have finished: stop waiting
            break

    # After timeout, if any process is still alive, terminate it; otherwise collect the result:

    if bp_process.is_alive():
        print(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] "
              f"Analyzing BP '{bp_path}' timed out, terminating process...")
        bp_process.terminate()
        if 'crashes' not in benchmarks:
            benchmarks['crashes'] = []
        benchmarks['crashes'].append('bp-analysis-timeout')
    else:
        benchmarks["bp"] = bp_benchmarks_dict_queue.get(block=False)  # is guaranteed to be there as bp_process finished
        res_dict["bp"] = bp_res_dict_queue.get(block=False)

    if cs_process.is_alive():
        print(f"[{datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] "
              f"Analyzing CS '{cs_path}' timed out, terminating process...")
        cs_process.terminate()
        if 'crashes' not in benchmarks:
            benchmarks['crashes'] = []
        benchmarks['crashes'].append('cs-analysis-timeout')
    else:
        benchmarks["cs"] = cs_benchmarks_dict_queue.get(block=False)
        res_dict["cs"] = cs_res_dict_queue.get(block=False)

    if print_result or PRINT_DEBUG:
        print(json.dumps(res_dict, indent=4, sort_keys=False, default=default, skipkeys=True))
    if store_result_as_json_file:
        store_analysis_results(extension_path, json_analysis, json_messages,
                               res_dict, messages_dict, outfile_name="analysis_renderer_attacker.json")
    if return_result:
        return res_dict


def get_all_response_identifiers(pdg: Node,
                                 call_expr_patterns: List[Node],
                                 callback_parameter_index: int,
                                 resolve_function_references=True) -> List[Node]:
    """
    Some Chrome API functions return a Promise but also provide a callback parameter for compatability.
    Notable examples of this are:
        - chrome.cookies.get(details: CookieDetails, callback?: function)
          => https://developer.chrome.com/docs/extensions/reference/api/cookies#method-get
        - chrome.cookies.getAll(details: object, callback?: function)
          => https://developer.chrome.com/docs/extensions/reference/api/cookies#method-getAll
        - StorageArea.get(keys?: string | string[] | object, callback?: function),
          e.g., chrome.storage.local.get(), or chrome.storage.sync.get()
          => https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea

    This function retrieves the response identifiers, no matter whether the callback parameter is used or
    whether .then() is being called on the returned Promise; for example the "cookies" Identifier is returned in
    both of the following two cases:
    (1) chrome.cookies.getAll({}, (cookies) => { sendResponse(cookies); });
    (2) chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });

    This function extracts common logic from
    get_all_cookie_response_identifiers() and get_all_storage_response_identifiers().

    Parameters:
        pdg: the PDG (or, maybe, part of the PDG) in which to perform the search
        call_expr_patterns: a pattern matching the CallExpressions you desire;
                  identifier names will be matched but literals and operators won't be,
                  additional children will be allowed but no different child order
        callback_parameter_index: the index of the callback parameter (*if* present);
                                  1 in the examples given above (as the callback is the 2nd parameter)
        resolve_function_references: whether to resolve function references/identifiers; defaults to True
    """
    result = []
    for pattern in call_expr_patterns:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # should be irrelevant
                                              match_operators=False,  # should be irrelevant
                                              allow_additional_children=True,
                                              allow_different_child_order=False):

            assert pattern_match.name == "CallExpression"

            no_of_args = len(pattern_match.call_expression_get_all_arguments())
            uses_callback = callback_parameter_index < no_of_args

            if uses_callback:  # uses callback (MV2 backwards compatibility) instead of Promises, e.g.: chrome.cookies.get({}, (cookie) => { /* ... */ });

                # ToDo: handle ".bind(this)" being called on the (Arrow)FunctionExpression passed !!!!!

                if pattern_match.has_child("FunctionExpression"):  # case 1: FunctionExpression:
                    function_expr: Node = pattern_match.get_child("FunctionExpression")
                    response_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if response_parameter is not None:
                        cookie_identifier = response_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("ArrowFunctionExpression"):  # case 2: ArrowFunctionExpression:
                    function_expr: Node = pattern_match.get_child("ArrowFunctionExpression")
                    response_parameter: Node = function_expr.arrow_function_expression_get_nth_param_or_none(0)
                    if response_parameter is not None:
                        cookie_identifier = response_parameter.function_param_get_identifier()
                        if cookie_identifier is not None:
                            result.append(cookie_identifier)

                elif pattern_match.has_child("Identifier") and resolve_function_references:  # case 3: Identifier:
                    # Example:
                    #         function msg_handler(msg, sender, sendResponse) {
                    #             function cookies_handler(cookies) {
                    #                 sendResponse(cookies);
                    #             }
                    #
                    #             chrome.cookies.getAll({}, cookies_handler);
                    #             return true;
                    #         }
                    #
                    #         chrome.runtime.onMessage.addListener(msg_handler);
                    function_reference = pattern_match.get_child("Identifier")
                    function_declaration = function_reference.function_Identifier_get_FunctionDeclaration(True)
                    if function_declaration is None:
                        print(f"[Warning] couldn't resolve function reference '{function_reference.attributes['name']}' "
                              f"in line {function_reference.get_line()}, file {function_reference.get_file()}, in "
                              f"chrome.cookies.get()/getAll() call!")
                    else:
                        assert function_declaration.name == "FunctionDeclaration"
                        # [1] [FunctionDeclaration] (3 children) --e--> [4]
                        # 			[2] [Identifier:"cookies_handler"] (0 children) --data--> [...]
                        # 			[3] [Identifier:"cookies"] (0 children) --data--> [...]
                        # 			[4] [BlockStatement] (1 child) --e--> [5]
                        # Note that one cannot simply take index X here as hoisted functions can create arbitrarily many
                        #   more children inside a FunctionDeclaration, e.g.: "function foo() { function bar() {} }":
                        # [1] [FunctionDeclaration] (3 children) --e--> [4] --e--> [3]
                        # 		[4] [FunctionDeclaration] (2 children) --e--> [6]
                        # 			[5] [Identifier:"bar"] (0 children)
                        # 			[6] [BlockStatement] (0 children)
                        # 		[2] [Identifier:"foo"] (0 children)
                        # 		[3] [BlockStatement] (0 children)
                        function_declaration_params = function_declaration.function_declaration_get_params()
                        if len(function_declaration_params) >= 1:
                            response_parameter = function_declaration_params[0]
                            # Note that the cookies_handler might also contain more redundant parameters, the cookie(s)
                            #   parameter however will always be at index 1.

                            # A FunctionParameter of a FunctionDeclaration may be one of the following types:
                            #     type FunctionParameter = AssignmentPattern | Identifier | BindingPattern;
                            # where:
                            #     type BindingPattern = ArrayPattern | ObjectPattern;
                            #
                            # * function cookies_handler(cookies) { ... }
                            # * function cookies_handler(cookies=null) { ... }
                            # * function cookies_handler({a:b, x:y}) { ... }
                            # * function cookies_handler([x,y]) { ... }
                            #
                            # The function_param_get_identifier() and function_param_get_identifiers() methods however
                            #   handle this for us!
                            response_identifier: Optional[Node] = response_parameter.function_param_get_identifier()  # e.g. `cookies`, for both `cookies` and `cookies=null`
                            if response_identifier is not None:
                                result.append(response_identifier)
                            else:
                                print(f"[Warning] Cookie/Storage response parameter "
                                      f"in line {response_parameter.get_line()}, file "
                                      f"{response_parameter.get_file()} has unexpected form: {response_parameter.name}")
                            # ToDo: handle cookie destructurings using cookie_parameter.function_param_get_identifiers() ?!

                else:
                    print(f"[Warning] couldn't identify cookie/storage response identifier for "
                          f"{pattern_match.call_expression_get_full_function_name()}() call "
                          f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                          f"function call has no function expression, "
                          f"no arrow function expression and no identifier child")

            else:  # uses Promise instead of callback, e.g.: chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });

                all_then_calls = pattern_match.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
                for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
                    result.extend(then_call.then_call_get_param_identifiers())

    return result


# chrome.cookies.getAll(
#   details: object,
#   callback?: function,    // (cookies: Cookie[]) => void
# )
# // Returns: Promise<Cookie[]>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
#
# chrome.cookies.get(
#   details: CookieDetails,
#   callback?: function,       // (cookie?: Cookie) => void
# )
# // Returns: Promise<Cookie | undefined>
# // "Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
# //  You cannot use both on the same function call. The promise resolves with the same type that is passed to the
# //  callback."
#
# => https://developer.chrome.com/docs/extensions/reference/api/cookies
COOKIES_PATTERN =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(Node.identifier_regex("browser|chrome"))  # ToDo: handle programmer aliasing chrome.cookies.getAll
                            .child(Node.identifier("cookies"))
                    )
                    .child(
                        Node.identifier_regex("get|getAll")
                    )
            )

COOKIE_PATTERNS = [COOKIES_PATTERN]


def get_all_cookie_response_identifiers(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "cookie" (or arbitrarily named) identifiers coming from a
    ```
    chrome.cookies.getAll({}, function(cookies) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.getAll({}, (cookies) => { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, function(cookie) { /* ... */ });
    ```
    or
    ```
    chrome.cookies.get({}, (cookie) => { /* ... */ });
    ```
    call.
    All these identifiers potentially contain very sensitive cookie data and shall not get into a
    content-script-accessible sink w/o proper authentication of the content script's URL!

    Also, one can also use the Promise returned by chrome.cookies.getAll()/get(); either by awaiting it:
    ```
    (async () => {
        let cookies = await chrome.cookies.getAll({});
        sendResponse(cookies);
    })();
    ```
    ...or one can call .then() on the returned Promise:
    ```
    chrome.cookies.getAll({}).then((cookies) => { sendResponse(cookies); });
    ```
    """
    return get_all_response_identifiers(
        pdg=pdg,
        call_expr_patterns=COOKIE_PATTERNS,
        callback_parameter_index=1,
        resolve_function_references=resolve_function_references
    )


def get_all_cookie_function_identifiers(pdg: Node) -> List[Node]:
    result = []
    for pattern in COOKIE_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,  # necessary!
                                              allow_different_child_order=False):
            assert pattern_match.name == "CallExpression"
            function_identifier = pattern_match.get_child("MemberExpression").rhs()  # "get" or "getAll"
            result.append(function_identifier)
    return result


STORAGE_GET_PATTERN =\
    Node("CallExpression")\
        .child(
            Node("MemberExpression")
                .child(
                    Node("MemberExpression")
                        .child(
                            Node("MemberExpression")
                                .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                # e.g., "chrome", "browser", "this.browser", "this._namespace", ...
                                # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                # calling "runtime.onMessage" doesn't work!
                                .child(Node.identifier("storage"))
                        )
                        .child(Node.identifier_regex("local|sync"))
                        # Note: When syncing is disabled, "storage.sync" behaves exactly like "storage.local"!
                        # Note: there are also the "manged" and "session" StorageAreas, however the "managed"
                        #       StorageArea is read-only for the entire extension, and the "session" StorageArea
                        #       is not exposed to content scripts by default;
                        #       therefore, both are inaccessible to the renderer attacker!
                        # => https://developer.chrome.com/docs/extensions/reference/api/storage
                )
                .child(Node.identifier("get"))
        )


STORAGE_GET_PATTERNS = [STORAGE_GET_PATTERN]


def get_all_storage_response_identifiers(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "result" (or arbitrarily named) identifiers coming from a
    ```
    chrome.storage.local.get(["key"]).then((result) => {});
    ```
    or
    ```
    chrome.storage.local.get(["key"]).then(function (result) {});
    ```
    or
    ```
    chrome.storage.local.get('key', (result) => {});
    ```
    or
    ```
    chrome.storage.local.get('key', function (result) {});
    ```
    call.
    All these identifiers contain data under control of the content script and therefore a renderer attacker;
    they shall not be put into other websites un-sanitized, this would create a UXSS vector!

    Note: instead of "storage.local", "storage.sync" may be used as well!
    """
    return get_all_response_identifiers(
        pdg=pdg,
        call_expr_patterns=STORAGE_GET_PATTERNS,
        callback_parameter_index=1,
        resolve_function_references=resolve_function_references
    )


def get_all_storage_get_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all "get" Identifiers from *.storage.local.get() or *.storage.sync.get() calls
    (e.g., "chrome.storage.local.get()").

    References:
        https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea
    """
    result = []
    for pattern in STORAGE_GET_PATTERNS:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,  # necessary!
                                              allow_different_child_order=False):
            assert pattern_match.name == "CallExpression"
            function_identifier = pattern_match.get_child("MemberExpression").rhs()  # "get"
            result.append(function_identifier)
    return result


def get_all_fetch_response_identifiers(pdg: Node, all_fetch_identifiers=None) -> List[Node]:
    """
    Returns all "response1", "response2", "response3", etc. (or arbitrarily named) identifiers coming from a
    ```
    fetch('https://example.com/')
        .then((response1) => response1.json())
        .then((response2, response3) => console.log(response2, response3));
    ```
    call.

    Note that while, in the example above, there are data flows from "response1", "response2" and "response3",
    there is no outgoing data flow from "fetch"; cf. get_all_fetch_identifiers() for cases where that might be of
    interest!

    Note that because of "then"-chaining, the returned identifiers may be of any arbitrary data type!

    Note that, as each then() call returns another Promise, the example above might also be the RHS of an
    AssignmentExpression!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker
        all_fetch_identifiers: optional, the result of `get_all_fetch_identifiers(pdg=pdg)`
                               (to avoid duplicate code calling)

    Returns:
        a list of Identifier Nodes, the concatenated (lambda/function) arguments of each then() call
    """
    if all_fetch_identifiers is None:
        all_fetch_identifiers = get_all_fetch_identifiers(pdg=pdg)

    result = []

    for fetch_identifier in all_fetch_identifiers:
        call_expression = fetch_identifier.get_parent(["CallExpression"])
        all_then_calls = call_expression.promise_returning_function_call_get_all_then_calls(
                                                                                    resolve_function_references=True)
        for then_call in all_then_calls:  # (Arrow)FunctionExpression or FunctionDeclaration (unless some error):
            result.extend(then_call.then_call_get_param_identifiers())

    return result


def get_all_fetch_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all "fetch" identifiers coming from the 0th child of a CallExpression, such as
    ```
    response1 = await fetch(url);
    ```
    or
    ```
    response1 = fetch(url);
    ```
    or
    ```
    response1 = yield fetch(url, options);
    ```
    call.

    Note that in all of these cases there is a --data--> flow edge from the "fetch" identifier to the "response1"
    identifier, meaning you can directly follow any data flow from the returned "fetch" identifiers!

    Note that `fetch()` has an optional second argument:
    ```
    fetch(resource)
    fetch(resource, options)
    ```
    => see: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
    => resource: a string, any other object with a stringifier (e.g., a `URL` object), a `Request` object
    => options (optional): a RequestInit object containing any custom settings that you want to apply to the request.
    => Return value: A Promise that resolves to a Response object.

    Note that inside a service worker, there is no "window" and hence no "window.fetch"!

    Parameters:
        pdg: the entire PDG of a service worker

    Returns:
        a list of Identifier Nodes whose name is "fetch"
    """
    pattern1 =\
        Node("CallExpression")\
            .child(
                Node.identifier("fetch")  # ToDo: handle aliasing of "fetch", e.g., "foobar = fetch; foobar(...);"
            )

    patterns = [pattern1]

    if os.environ.get('PRINT_PDGS') == "yes":
        for i in range(len(patterns)):
            pattern = patterns[i]
            print(f"Fetch Identifier Pattern #{i + 1}:\n{pattern}")

    result = []
    for pattern in patterns:
        for pattern_match in pdg.find_pattern(pattern,
                                              match_identifier_names=True,
                                              match_literals=False,  # irrelevant in this case
                                              match_operators=False,  # irrelevant in this case
                                              allow_additional_children=True,
                                              allow_different_child_order=False):
            if (len(pattern_match.children) in [2, 3]  # either "fetch(resource)" or "fetch(resource, options)"
                and pattern_match.children[0].name == "Identifier"
                    and pattern_match.children[0].attributes['name'] == "fetch"):  # ensure it's not, for example, "foo(fetch)"
                result.append(pattern_match.children[0])  # "fetch"
    return result


def get_all_chrome_runtime_onMessage_addListener_args(pdg: Node, arg_index: int,
                                                      resolve_function_references=True) -> List[Node]:
    """
    Extracts common code logic from get_all_sendResponse_sinks() and get_all_msg_sources().
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    # e.g., "chrome", "browser", "this.browser",
                                    #       "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                                    # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                    # calling "runtime.onMessage" doesn't work!
                                    .child(Node.identifier("runtime"))
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )
            #.child(
            #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
            #)

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"chrome.runtime.onMessage.addListener() Pattern #1:\n{pattern}")

    result = []

    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        assert pattern_match.name == "CallExpression"
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onMessage.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        callback_arg: Node = args[0]
        try:
            # listener arguments are:
            #   0. message
            #   1. sender
            #   2. sendResponse
            # (programmer might add redundant additional arguments, but they don't matter)
            result.append(callback_arg.functional_arg_get_arg(arg_index, resolve_arg_to_identifier=True))
        except IndexError:
            # There is no argument at index `arg_index` => there is nothing to return.
            # The programmer may easily leave out trailing parameters: either (message, sender) or just (message).
            # An example for this would be: chrome.runtime.onMessage.addListener((message) => { /* ... */ });
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onMessage.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify {arg_index}-th argument of chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onMessage.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return result


def get_all_sendResponse_sinks(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "sendResponse" (or arbitrarily named) identifiers coming from a
    ```
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { /* ... */ });
    ```
    or
    ```
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { /* ... */ });
    ```
    call.
    All these identifiers describe content-script-accessible sinks!
    """
    # listener arguments are:
    #   0. message
    #   1. sender
    #   2. sendResponse <-----
    # (programmer might add redundant additional arguments, but they don't matter)
    return get_all_chrome_runtime_onMessage_addListener_args(pdg=pdg,
                                                             arg_index=2,
                                                             resolve_function_references=resolve_function_references)


def get_all_msg_sources(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all "message" (or arbitrarily named) identifiers coming from a
    ```
    chrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { /* ... */ });
    ```
    or
    ```
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => { /* ... */ });
    ```
    call.
    All these identifiers describe content-script-controlled sources!
    """
    # listener arguments are:
    #   0. message      <-----
    #   1. sender
    #   2. sendResponse
    # (programmer might add redundant additional arguments, but they don't matter)
    return get_all_chrome_runtime_onMessage_addListener_args(pdg=pdg,
                                                             arg_index=0,
                                                             resolve_function_references=resolve_function_references)


def get_all_port_postMessage_sinks(pdg: Node) -> List[Node]:
    """
    Returns all "port.postMessage" sinks, referring to the "postMessage" method of a port given by
    chrome.runtime.onConnect.addListener(); an example:

    ```
    chrome.runtime.onConnect.addListener(port => {
        port.postMessage("pong");
    });
    ```
    => cf. /oocalimimngaihdkbihfgmpkcpnmlaoa-3.4.0-Crx4Chrome.com/background.js ("Netflix Party is now Teleparty")

    Returns:
        a list of MemberExpressions (LHS = identifier with data flow from "port"; RHS = "postMessage" Identifier)
        whose parents are CallExpressions
    """
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=de#event-onConnect:
    # chrome.runtime.onConnect.addListener(
    #   callback: function,                    // (port: Port) => void
    # )
    #
    # From https://developer.chrome.com/docs/extensions/reference/api/runtime?hl=en#type-Port:
    # * Port.name:                             string                  => irrelevant
    # * Port.onDisconnect(callback: function): Event<functionvoidvoid> => irrelevant, no data flow
    # * Port.onMessage(callback: function):    Event<functionvoidvoid> => will be relevant for INFILTRATION/UXSS dangers
    # * Port.sender:                           MessageSender           => relevant for auth check: origin, tab, url
    # * Port.disconnect():                     void                    => irrelevant, no data flow
    # * Port.postMessage(message: any):        void                    => relevant here, for EXFILTRATION dangers!!!
    pattern = \
        Node("CallExpression") \
            .child(
            Node("MemberExpression")
            .child(
                Node("MemberExpression")
                .child(
                    Node("MemberExpression")
                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onConnect
                    # e.g., "chrome", "browser", "this.browser", "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                    .child(Node.identifier("runtime"))
                )
                .child(Node.identifier("onConnect"))
            )
            .child(
                Node.identifier("addListener")
            )
        )
    # .child(
    #    Node("FunctionExpression") or Node("ArrowFunctionExpression") or Node("Identifier")
    # )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"onConnect Pattern #1:\n{pattern}")

    postMessage_sinks = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        # pattern_match = "chrome.runtime.onConnect.addListener(port => { port.postMessage("pong"); });"
        assert pattern_match.name == "CallExpression"
        # args = ["port => { port.postMessage("pong"); }"]
        args = pattern_match.call_expression_get_all_arguments()
        if len(args) == 0:
            print(f"[Warning] chrome.runtime.onConnect.addListener() call in line {pattern_match.get_line()}, "
                  f"file {pattern_match.get_file()}, has no argument!")
            continue
        # callback_arg = "port => { port.postMessage("pong"); }"
        callback_arg: Node = args[0]
        try:
            # port_argument = "port"
            port_argument: Node = callback_arg.functional_arg_get_arg(0, resolve_arg_to_identifier=True)
            port_data_flows: List[DataFlow] = DataFlow.all_continued_beginning_at(port_argument)
            for port_data_flow in port_data_flows:
                for identifier_node in port_data_flow.nodes:
                    # "port.postMessage(x);" becomes:
                    # [1] [CallExpression] (2 children)
                    # 	[2] [MemberExpression:"False"] (2 children)      <----- return value
                    # 		[3] [Identifier:"port"] (0 children)         <----- identifier_node
                    # 		[4] [Identifier:"postMessage"] (0 children)
                    # 	[5] [Identifier:"x"] (0 children)
                    if (identifier_node.parent.name == "MemberExpression" # ToDo: handle the 2 different cases of MemberExpressions, i.e. also handle port['postMessage']
                            and identifier_node.grandparent().name == "CallExpression"
                            and identifier_node.parent.lhs() == identifier_node
                            and identifier_node.parent.rhs().name == "Identifier"
                            and identifier_node.parent.rhs().attributes['name'] == "postMessage"):
                        # found "port.postMessage(...);" call, return the "port.postMessage" MemberExpression:
                        postMessage_sinks.append(identifier_node.parent)
        except IndexError:
            # There is no argument at index no. 0 => there is no "port" argument to use further.
            continue
        except KeyError:
            # Identifier couldn't be resolved to a FunctionDeclaration.
            print(f"[Warning] couldn't resolve function reference "
                  f"'{callback_arg.attributes['name'] if 'name' in callback_arg.attributes else '?'}' "
                  f"in line {callback_arg.get_line()}, file {callback_arg.get_file()}, in "
                  f"chrome.runtime.onConnect.addListener() call!")
            continue
        except TypeError:
            # callback_arg is neither a FunctionExpression nor an ArrowFunctionExpression nor an Identifier.
            print(f"[Warning] couldn't identify port sink for chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}: "
                  f"argument is neither function expression, nor arrow function expression nor identifier")
            continue
        except AttributeError:
            # resolving the complex argument to an Identifier failed
            print(f"[Warning] couldn't turn argument into identifier in chrome.runtime.onConnect.addListener() call "
                  f"in line {pattern_match.get_line()}, file {pattern_match.get_file()}")
            continue

    return postMessage_sinks


def get_all_document_identifiers(pdg: Node) -> List[Node]:
    """
    Returns all Identifiers named "document" within the given PDG.
    """
    return [identifier for identifier in pdg.get_all_as_iter("Identifier")
            if identifier.attributes['name'] == "document"]


def get_all_chrome_tabs_executeScript_sinks(pdg: Node) -> List[Node]:
    """
    Returns all "chrome.tabs.executeScript" MemberExpression sinks that

    Note that the chrome.tabs.executeScript() API is a deprecated MV2 API!

    Example:
    ```
    chrome.tabs.executeScript(
        tab_id,
        {code: my_code}
    );
    ```

    Returns:
        a list of all "chrome.tabs.executeScript" MemberExpressions that are part of a CallExpression which also
        contains an ObjectExpression parameter with a Property named "code".
    """

    # https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript:
    #
    # chrome.tabs.executeScript(
    #   tabId?: number,
    #   details: InjectDetails,   // <=== the sink that we care about!!!
    #   callback?: function,      // (result?: any[]) => void
    # )
    #
    # Returns: Promise<any[] | undefined>
    #          Promises are supported in Manifest V3 and later, but callbacks are provided for backward compatibility.
    #          You cannot use both on the same function call.
    #          The promise resolves with the same type that is passed to the callback.
    #
    # where:
    #   tabId: The ID of the tab in which to run the script; defaults to the active tab of the current window.
    #   details: Details of the script to run.
    #            Either the code or the file property must be set, but both may not be set at the same time.
    #   callback: The callback parameter looks like: (result?: any[]) => void
    #             where: result: The result of the script in every injected frame.
    #
    # https://developer.chrome.com/docs/extensions/reference/api/extensionTypes#type-InjectDetails:
    #
    # InjectDetails:
    #   Details of the script or CSS to inject.
    #   Either the code or the file property must be set, but both may not be set at the same time.
    #   Properties:
    #     allFrames: boolean optional
    #     code: string optional              // <=== Chrome docs even explicitly warn about the XSS danger here!!!
    #     cssOrigin: CSSOrigin optional
    #     file: string optional
    #     frameId: number optional
    #     matchAboutBlank: boolean optional
    #     runAt: RunAt optional

    # Example PDG (taken from the "ClassLink OneClick Extension" code):
    # [522] [CallExpression] (3 children)
    #        [523] [MemberExpression:"False"] (2 children)
    #            [524] [MemberExpression:"False"] (2 children)
    #                [525] [Identifier:"chrome"] (0 children)
    #                [526] [Identifier:"tabs"] (0 children)
    #            [527] [Identifier:"executeScript"] (0 children)
    #        [528] [Identifier:"n"] (0 children)
    #        [529] [ObjectExpression] (1 child)
    #            [530] [Property] (2 children)
    #                [531] [Identifier:"code"] (0 children)
    #                [532] [Identifier:"f"] (0 children)      // <----- has incoming data flows

    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node.identifier_regex("browser|chrome")
                            )
                            .child(
                                Node.identifier("tabs")
                            )
                    )
                    .child(
                        Node.identifier("executeScript")
                    )
            )\
            .child(
                Node("ObjectExpression")
                    .child(
                        Node("Property")
                            .child(
                                Node.identifier("code")
                            )
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"chrome.tabs.executeScript() code Pattern #1:\n{pattern}")

    code_sinks: List[Node] = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,  # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,  # IMPORTANT!
                                          allow_different_child_order=False):
        assert pattern_match.name == "CallExpression"
        assert pattern_match.children[0].name == "MemberExpression" # ToDo: what if it's foo(chrome.tabs.executeScript) ?!
        code_sinks.append(pattern_match.children[0])

    return code_sinks


def get_all_message_listeners(pdg: Node, resolve_function_references=True) -> List[Node]:
    """
    Returns all message listeners in the given PDG.
    More precisely:
    Returns for all `x` for all `chrome.runtime.onMessage.addListener(x)` calls.
    Those xs returned should usually be one of the following:
    * a FunctionExpression
    * an ArrowFunctionExpression
    * a FunctionDeclaration (if resolve_function_references=True, which is the default)
    * an Identifier (if resolve_function_references=False, or when resolving a function reference failed!)
    """
    pattern =\
        Node("CallExpression")\
            .child(
                Node("MemberExpression")
                    .child(
                        Node("MemberExpression")
                            .child(
                                Node("MemberExpression")
                                    .child(Node.wildcard())  # ToDo: handle programmer aliasing chrome.runtime.onMessage
                                    # e.g., "chrome", "browser", "this.browser",
                                    #       "extensionizer__WEBPACK_IMPORTED_MODULE_0___default.a"
                                    # Note that (assuming no aliasing) the "chrome" is necessary, simply
                                    # calling "runtime.onMessage" doesn't work!
                                    .child(Node.identifier("runtime"))
                            )
                            .child(Node.identifier("onMessage"))
                    )
                    .child(
                        Node.identifier("addListener")
                    )
            )

    if os.environ.get('PRINT_PDGS') == "yes":
        print(f"Get All Message Listeners Pattern #1:\n{pattern}")

    result = []
    for pattern_match in pdg.find_pattern(pattern,
                                          match_identifier_names=True,
                                          match_literals=False,   # irrelevant in this case
                                          match_operators=False,  # irrelevant in this case
                                          allow_additional_children=True,
                                          allow_different_child_order=False):

        if len(pattern_match.children) >= 2:
            x = pattern_match.children[1]  # the `x` in `chrome.runtime.onMessage.addListener(x)`

            # Resolve function references if parameter resolve_function_references=True:
            if x.name == "Identifier" and resolve_function_references:
                function_declaration = x.function_Identifier_get_FunctionDeclaration(True)
                if function_declaration is None:
                    result.append(x)
                else:
                    assert function_declaration.name == "FunctionDeclaration"
                    result.append(function_declaration)

                # function foo(x,y,z) {}
                # chrome.runtime.onMessage.addListener(foo);
                #
                # [1] [Program] (2 children)
                # 	[2] [FunctionDeclaration] (5 children) --e--> [7]             <-----
                # 		[3] [Identifier:"foo"] (0 children) --data--> [17]        <-----
                # 		[4] [Identifier:"x"] (0 children)
                # 		[5] [Identifier:"y"] (0 children)
                # 		[6] [Identifier:"z"] (0 children)
                # 		[7] [BlockStatement] (0 children)
                # 	[8] [ExpressionStatement] (1 child)
                # 		[9] [CallExpression] (2 children)
                # 			[10] [MemberExpression] (2 children)
                # 				[11] [MemberExpression] (2 children)
                # 					[12] [MemberExpression] (2 children)
                # 						[13] [Identifier:"chrome"] (0 children)
                # 						[14] [Identifier:"runtime"] (0 children)
                # 					[15] [Identifier:"onMessage"] (0 children)
                # 				[16] [Identifier:"addListener"] (0 children)
                # 			[17] [Identifier:"foo"] (0 children)                  <-----

            else:
                result.append(x)

        # If len(pattern_match.children) < 2, we have a "chrome.runtime.onMessage.addListener()" call, i.e., the
        #   argument is missing!

    return result


def expression_correctly_verifies_sender_object(test_expression: Node, sender_object_node: Node) -> bool:  # ToDo
    """
    Helper function for expression_correctly_verifies_sender().
    Unlike for the `sender_node` of expression_correctly_verifies_sender(), we already know here that the
    `sender_object_node` is *directly* the "sender" object (with .url, .tab.url, .origin, etc. attributes), and not,
    for example, already some attribute/member of it (like sender.url).

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender?!
        sender_object_node: the part of the `test_expression` representing the sender
                            (has .url, .tab.url and .origin attributes, among others)

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender, False otherwise.
    """
    return False


def is_safe_url_prefix(url_prefix: str) -> bool:
    """
    E.g., "https://admin.com/" is a safe URL prefix but "https://admin.com" (w/o the trailing slash) isn't!
    "https://" on its own is also an unsafe prefix!
    Note that the prefix doesn't have to end with a slash though, "https://admin.com/foo" is also a safe URL prefix.
    """
    if os.environ.get('CONSIDER_HTTP_AS_SAFE') == "yes":
        return re.fullmatch("^https?://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    else:
        return re.fullmatch("^https://.+/.*$", url_prefix) is not None  # => implicitly checks equality of the origin!
    # Checking that the URL has an http:// prefix is still considered an insecure verification of the sender as the
    #   authenticity of such a sender still cannot be guaranteed. A renderer attacker + network attacker would still be
    #   able to exploit the vulnerability in the extension!
    # This default behavior is only deactivated when the user supplies the --consider-http-as-safe argument.


def is_safe_origin_suffix(origin_suffix: str) -> bool:
    """
    E.g., ".admin.com" and ".admin.co.uk" are safe origin suffixes but "admin.com" and ".co.uk" aren't!
    "/admin.com", "//admin.com", "://admin.com" and "https://admin.com" can also be considered safe suffixes
    (but not "http://admin.com", see below).

    Note that by using Mozilla's Public Suffix List (PSL) (https://publicsuffix.org/), we can identify a danger even
    when the code checks for a suffix like ".blogspot.com" for example!

    Note that even a triple-suffix like ".sth.ac.at" can be available for public registration and hence unsafe!
    """
    if "http://" in origin_suffix:
        # The origin is essentially checked to be equal to a http:// domain, this means that the entire origin check
        #   is essentially pointless though, since all HTTP communication can be manipulated anyways.
        return False
    elif "/" in origin_suffix:
        # As the sender.origin will never contain a slash except for the one from "https://",
        #   if there's a "/" in the origin suffix check, this always means there's essentially a check on the entire
        #   origin!
        return True
    elif "." not in origin_suffix:
        return False  # e.g. simply suffix check for "com" => not even REMOTELY sufficient!
    else:  # e.g. ".admin.co.uk" or ".admin.com" or "foo.admin.com" (all good) or "admin.co.uk" or "admin.com" (all bad)
        actually_verified_suffix = origin_suffix[origin_suffix.index(".")+1:]  # only everything after the first "." is actually verified
        extract = tldextract.TLDExtract()
        return extract(actually_verified_suffix, include_psl_private_domains=True).domain != ''


def expression_correctly_verifies_sender_url(test_expression: Node, sender_url_node: Node) -> bool:
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender URL verifications:
    * url == "https://admin.com/"
    * url === "https://admin.com/"
    * url.startsWith("https://admin.com/")
    * ["option1", "option2"].includes(url)
    * url == "option1" | url == "option2"
    * url === "option1" || url === "option2"

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (url == "https://admin.com/" & something_else())
    * (url == "https://admin.com/" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (URL)?!
        sender_url_node: the part of the `test_expression` representing the sender URL

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender URL, False otherwise.
    """
    if not sender_url_node.lies_within(test_expression)\
            and not any(identifier.is_data_flow_equivalent_identifier(sender_url_node)
                        for identifier in test_expression.get_all_identifiers()):
        # `test_expression` cannot verify `sender_url_node` if `test_expression` does not *contain* `sender_url_node`
        #     (or at least a "data-flow-equivalent" node, take "url == 'foo' || url == 'foo'" for example where both
        #     "url" identifiers are deemed "data-flow-equivalent")
        return False

    elif test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] in ["==", "==="]:
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        if left_operand.equivalent(right_operand):
            return False  # "url == url" or "url === url" is trivially True and therefore *not* a sufficient check!
        elif sender_url_node.lies_within(left_operand) and sender_url_node.lies_within(right_operand):
            # Something like, maybe, "url == url.toLowerCase()", or "url == url.substring(0,30)",
            # or "url.length == url.substring(20,22)"
            # => all unsafe checks
            # Something like, maybe, "url == 'foo' + url" would always be False and therefore *THEORETICALLY* be a
            # good enough "protection" for a block of code. However, (a) it seems unlikely that someone would write
            # such an always-False "check" and (b) even *if*, we simply return it as a vulnerability, leaving some
            # manual verification effort for the human (as always).
            return False
        elif os.environ.get('CONSIDER_HTTP_AS_SAFE') != "yes" and\
                (left_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*") or
                 right_operand.any_string_literal_inside_matches_full_regex(r"http:\/\/.*")):
            return False  # return False for "url == 'http://...'" as HTTP is unsafe!!! (renderer + network attacker)
        else:
            return True  # We assume "url == ...", "... == url", "url === ..." or "... === url" to be valid checks!

    # "url == "https://admin.com/" && something_else()"  (ONE side of the "&&" needs to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "&&"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "&":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url =\
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url or right_operand_correctly_verifies_sender_url

    # "url == "option1" || url == "option2"" (BOTH sides of the "||" need to verify the URL!):
    elif test_expression.name == "LogicalExpression" and test_expression.attributes['operator'] == "||"\
            or test_expression.name == "BinaryExpression" and test_expression.attributes['operator'] == "|":
        left_operand = test_expression.children[0]
        right_operand = test_expression.children[1]
        left_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=left_operand, sender_url_node=sender_url_node)
        right_operand_correctly_verifies_sender_url = \
            expression_correctly_verifies_sender_url(test_expression=right_operand, sender_url_node=sender_url_node)
        return left_operand_correctly_verifies_sender_url and right_operand_correctly_verifies_sender_url

    # "url.startsWith("https://admin.com/")" (URL needs to end with a '/' that's *not* the slash from 'https://'!):
    #     [1] [CallExpression] (2 children)
    #         [2] [MemberExpression] (2 children)
    #             [3] [Identifier:"url"] (0 children)            == sender_url_node
    #             [4] [Identifier:"startsWith"] (0 children)
    #         [5] [Literal:""https://admin.com/""] (0 children)
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0] == sender_url_node\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "startsWith"\
            and test_expression.children[1].name == "Literal"\
            and is_safe_url_prefix(test_expression.children[1].string_literal_without_quotation_marks()):
        return True

    # "["option1", "option2"].includes(url)":
    # [1] [CallExpression] (2 children)
    #     [2] [MemberExpression] (2 children)
    #         [3] [ArrayExpression] (2 children)
    #             [4] [Literal:""option1""] (0 children)
    #             [5] [Literal:""option2""] (0 children)
    #         [6] [Identifier:"includes"] (0 children)
    #     [7] [Identifier:"url"] (0 children)             == sender_url_node
    elif test_expression.name == "CallExpression"\
            and len(test_expression.children) == 2\
            and test_expression.children[0].name == "MemberExpression"\
            and len(test_expression.children[0].children) == 2\
            and test_expression.children[0].children[0].name == "ArrayExpression"\
            and test_expression.children[0].children[1].name == "Identifier"\
            and test_expression.children[0].children[1].attributes['name'] == "includes"\
            and test_expression.children[1] == sender_url_node:
        return True

    else:
        return False

    # ToDo: handle UnaryExpression with '!' operator!!!


def expression_correctly_verifies_sender_origin(test_expression: Node, sender_origin_node: Node) -> bool: # ToDo
    """
    Helper function for expression_correctly_verifies_sender().

    Examples of correct sender origin verifications:
    * origin == "https://admin.com"
    * origin === "https://admin.com"
    * origin.endsWith(".admin.com")
    * origin.endsWith(".admin.co.uk")
    * origin.endsWith("/admin.com")
    * ["option1", "option2"].includes(origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (origin == "https://admin.com" & something_else())
    * (origin == "https://admin.com" && something_else())

    Parameters:
        test_expression: the condition of some if statement; question: Does it correctly *verify* the sender (origin)?!
        sender_origin_node:

    Returns:
        a boolean, True if the `text_expression` correctly verifies the sender origin, False otherwise.
    """
    return False


def expression_correctly_verifies_sender(test_expression: Node, sender_node: Node, data_flow: DataFlow) -> bool:
    """
    Helper function for verifies_sender_is_safe().
    Note that it is assumed that `sender_node.lies_within(test_expression)`!
    It is also assumed that `sender_node in data_flow.nodes`!

    Note that the sender_node may be:
    (1) simply the `sender` variable from `(msg, sender, sendResponse)`
    (2) a renamed alias of it, e.g.: `let from = sender;`
    (3) a variable storing a property of the sender, e.g.: `let url = sender.url;`
    (4)                                       ...but also: `let len = sender.url.length;`
                                                       or: `let active = sender.tab.active;` (which is simply a boolean)
    (5) some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`

    Parameters:
        test_expression: the expression to check: Does it correctly *verify* the sender?!
        sender_node: the PDG node having a data flow from `sender` into it *and* lying within `test_expression`
        data_flow: the complete data from `sender` that `sender_node` is a part of

    Returns:
        a boolean indicating whether `test_expression` correctly verifies the sender
    """
    assert sender_node.lies_within(test_expression)
    assert sender_node in data_flow.nodes

    data_flow = data_flow.get_sub_flow(last_node=sender_node)
    accessed_members = data_flow.get_accessed_members(include_method_calls=False)
    if accessed_members == []:  # case (1) or (2): sender_node is still simply the sender object
        return expression_correctly_verifies_sender_object(test_expression=test_expression, sender_object_node=sender_node)
    elif accessed_members == ["url"] or accessed_members == ["tab", "url"]:  # case (3): sender_node === sender.url or sender.tab.url
        return expression_correctly_verifies_sender_url(test_expression=test_expression, sender_url_node=sender_node)
    elif accessed_members == ["origin"]:  # case (3): sender_node === sender.origin
        return expression_correctly_verifies_sender_origin(test_expression=test_expression, sender_origin_node=sender_node)
    else:
        # case (4): some other property of sender that is not useful as a safety check is used in the test_expression
        # case (5): some more advanced computation on one of the sender's attributes, e.g.: `sender.url.replace(...)`
        # Note that while this *might* still be a correct sender verification, we are in doubt and still return the
        #   vulnerability, leaving it to the human to verify the vulnerability!
        return False


def verifies_sender_is_safe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool:
    """
    Returns True if the `test_expression` Expression Node *correctly* verifies the safety of the sender stored in
    `sender_identifier_or_pattern`.

    Examples of correct sender verifications:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    All of the above may be contained in a more complicated conjunction using "&" or "&&":
    * (sender.url == "https://admin.com/" & something_else())
    * (sender.url == "https://admin.com/" && something_else())

    Also, the sender URL/origin might have been written into another intermediary variable first:
    ```
    let url = sender.url;
    if (url == "https://admin.com/") {
        /* ... */
    }
    ```

    Also note that "sender.tab.url" may be used instead of "sender.url" as well!

    (!!!) The `test_expression` evaluating to TRUE must IMPLY that the sender is safe. (!!!)

    (!!!) The if-branch of the if-statement is safe. (!!!)
    """
    sender_identifier_data_flows = DataFlow.all_continued_beginning_at(sender_identifier_or_pattern)
    # For each data flow sender -> ... -> ... -> ...:
    for sender_identifier_data_flow in sender_identifier_data_flows:
        if os.environ.get('PRINT_PDGS') == "yes":                      #
            print(f"Sender data flow: {sender_identifier_data_flow}")  #

        # For each node in such a data flow: sender -> ... -> ... -> ...:
        #                                    |____|    |_|    |_|    |_|
        for sender_node in sender_identifier_data_flow.nodes:

            # If this node lies within the test expression of which we want to check whether it verifies sender safety:
            if sender_node.lies_within(test_expression):
                if os.environ.get('PRINT_PDGS') == "yes":                                                 #
                    print(f"\t=> [{sender_node.id}] lies within test expression [{test_expression.id}]")  #

                # Check if the `test_expression` *correctly* verifies the safety of the sender represented by `sender_node`:
                if expression_correctly_verifies_sender(test_expression, sender_node, sender_identifier_data_flow):
                    print(f"Found correct sender verification in {test_expression.get_file()}, "
                          f"line {test_expression.get_line()}: {test_expression.get_whole_line_of_code_as_string()}")
                    return True
                # Note that the sender may occur more than once inside the `test_expression`, e.g.:
                #     if (sender && sender.url == "https://admin.com/") { /* ... */ }
                #     if (sender.url.length > 18 && sender.url.startsWith("https://admin.com/")) {/ *...* /}
                # => Therefore, we cannot simply return False when expression_correctly_verifies_sender() returns False!

    # Either no flow from `sender_identifier_or_pattern` into the `test_expression` could be found,
    # or the `test_expression` did not correctly verify the `sender_identifier_or_pattern`:
    return False


def verifies_sender_is_unsafe(pdg: Node, test_expression: Node, sender_identifier_or_pattern: Node) -> bool: # ToDo
    """
    Note that this function does *not* simply return the opposite of the verifies_sender_is_safe() function!
    A test expression may neither verify safety *nor* non-safety of the sender, e.g., when it doesn't perform a check on
    the sender at all, doing something completely unrelated, or, when it performs in incorrect/incomplete check of the
    sender!

    Also note that a sender un-safety check may be combined with other checks in a DISJUNCTION ("|" or "||" operator)
    but NOT in a CONJUNCTION ("&" or "&&" operator), i.e., the exact opposite of the verifies_sender_is_safe() function!
    Think of it as swapping the "if" and "else" branches / negating the condition. Example:
    * (sender.url != "https://admin.com/" | something_else())
    * (sender.url != "https://admin.com/" || something_else())

    (!!!) The sender being unsafe must IMPLY that the `test_expression` evaluates to TRUE. (!!!)

    (!!!) The else-branch of the if-statement is safe. (!!!)
    """
    pass


def get_protected_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Returns all blocks of code inside the given `pdg_subtree` where the sender identifier (given as the second argument)
    is *correctly* verified.

    There are 3 different ways of sender URL/origin verification that we consider to be "correct":
    (1) checking the URL (either sender.url or sender.tab.url) or origin (sender.origin) for equality using "==" or
        "===" or using an Array.includes() call (except when checking for trivial equality to itself of course)
    (2) checking a URL prefix, prefix must contain a slash "/" other than the two slashes from "://", this ensures that
        there's an (implicit) equality check for the origin
    (3) checking the suffix of origin, such that there's an (implicit) equality check of the domain name,
        e.g., ".admin.com" or ".admin.co.uk" but not "admin.com" or ".co.uk" (!!!)

    Some examples of correct sender verifications are:
    * sender.url == "https://admin.com/"
    * sender.url === "https://admin.com/"
    * sender.origin == "https://admin.com"
    * sender.origin === "https://admin.com"
    * sender.url.startsWith("https://admin.com/")
    * sender.origin.endsWith(".admin.com")
    * ["option1", "option2"].includes(sender.url)
    * ["option1", "option2"].includes(sender.origin)

    Some examples of *incorrect* sender verifications are:
    * sender.url == sender.url
    * sender.url === sender.url
    * sender.origin == sender.origin
    * sender.origin === sender.origin
    * sender.url != "https://bad.com/"
    * sender.url !== "https://bad.com/"
    * sender.url.startsWith("https://admin.com")    sender.origin.startsWith("https://admin.com")
    * sender.url.includes("admin.com")              sender.origin.includes("admin.com")
    * sender.url.endsWith("admin.html")             sender.origin.endsWith("admin.com")
    * sender.url.endsWith(".admin.com/")            sender.origin.endsWith(".co.uk")
    * ["option1", "option2", sender.url].includes(sender.url)
    * ["option1", "option2", sender.origin].includes(sender.origin)

    Note that, instead of sender.url, sender.tab.url may be also used (extension requires the "tabs" permission though).

    Also note that sender.url, sender.tab.url or sender.origin might also flow into another variable before being
    checked!
    """
    protected_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None
        # The else_block could be another IfStatement, in that case it will *also* be enumerated by
        #     get_all_if_statements_inside().

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            protected_blocks_of_code.append(if_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and\
                else_block is not None:
            protected_blocks_of_code.append(else_block)

        # Note how this even catches the following case:
        #
        # if (sender.url != "safe.com") {
        #     /* ... */
        # } else if (something_completely_unrelated()) {
        #     /* PROTECTED BLOCK OF CODE */
        #     sendResponse(cookies);
        # }

    return protected_blocks_of_code


def get_explicitly_unsafe_blocks_of_code(pdg: Node, pdg_subtree: Node, sender_identifier_or_pattern: Node) -> List[Node]:
    """
    Cf. get_protected_blocks_of_code() but returns all blocks of code where it has been explicitly verified that the
    sender is *not* safe!
    """
    explicitly_unsafe_blocks_of_code = []

    all_if_statements_inside_pdg_subtree = pdg_subtree.get_all_if_statements_inside()
    for if_statement in all_if_statements_inside_pdg_subtree:
        if_condition = if_statement.children[0]
        if_block = if_statement.children[1]
        else_block = if_statement.children[2] if len(if_statement.children) > 2 else None

        if verifies_sender_is_safe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg) and \
                else_block is not None:
            explicitly_unsafe_blocks_of_code.append(else_block)
        if verifies_sender_is_unsafe(test_expression=if_condition, sender_identifier_or_pattern=sender_identifier_or_pattern, pdg=pdg):
            explicitly_unsafe_blocks_of_code.append(if_block)

    return explicitly_unsafe_blocks_of_code


def identifier_get_all_member_identifiers(identifier: Node, member_name: str, allow_method_calls=False) -> List[Node]:
    """
    Input:  (A) Identifier Node, e.g., "port"
            (B) Member name, e.g., "sender"
    Output: list of all Identifier Nodes with a data flow from "port.sender" into them
    """
    assert identifier.name == "Identifier"
    result = set()
    for data_flow_parent in identifier.get_data_flow_parents():
        for data_flow in DataFlow.all_continued_beginning_at(data_flow_parent):
            for node in data_flow.nodes:
                partial_data_flow = data_flow.get_sub_flow(first_node=None, last_node=node)
                # partial_data_flow: self --data--> ... --data--> node
                if allow_method_calls:
                    if partial_data_flow.get_accessed_members(include_method_calls=False) == [member_name]:
                        result.add(node)
                else:
                    if partial_data_flow.get_accessed_members(include_method_calls=True) == [member_name]:
                        result.add(node)
    assert all(node.name == "Identifier" for node in result)
    return list(result)
    # ToDo: make this a member function of Node?!


def detect_41_31_vuln_in_bp_no_uxss(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Look for type 4.1 vulnerabilities in the given background page/service worker (or rather its PDG), type 4.1
    vulnerabilities refer to the ability to `Execute Privileged Browser APIs` w/o (sufficiently) verifying `sender.url`,
    which is a security violation of type 3.1: `Extension Message Authentication`
    (refer to Kim and Lee paper for more info)

    Example vulnerability (with no authentication of `sender.url` or `sender.tab.url` or `sender.origin` whatsoever):
    ```
    chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
        chrome.cookies.getAll({},
            function(cookies) {
                sendResponse(cookies);
            }
        );
        return true;
    });
    ```

    This function only looks for *exfiltration* dangers, refer to detect_41_31_vuln_in_bp_uxss() for the detection of
    UXSS/*infiltration* dangers!
    """
    start = timeit.default_timer()

    # ##### ##### Sources: ##### #####
    cookie_sources: List[Node] = get_all_cookie_function_identifiers(pdg_bp)
    # => e.g., returns the "getAll" in "cookies1 = await chrome.cookies.getAll({});"
    #    => data flow may continue from there, first into "cookies1" and then beyond...
    cookie_response_sources: List[Node] = get_all_cookie_response_identifiers(pdg_bp)  # (optional ToDo: optimization: reuse cookie_sources result)
    # => e.g., returns the "cookies" in "chrome.cookies.getAll({}, (cookies) => { /* ... */ });",
    #               or the "cookie"  in "chrome.cookies.get({}, function(cookie) { /* ... */ });"
    #               or the "cookies" in "chrome.cookies.getAll({}).then((cookies) => { /* ... */ });"
    #    => data flow may continue from there, inside the (anonymous) function...
    fetch_sources: List[Node] = get_all_fetch_identifiers(pdg_bp)
    # => e.g., returns the "fetch" in "response1 = await fetch(url);"
    #    => data flow may continue from there, first into "response1" and then beyond...
    fetch_response_sources: List[Node] = get_all_fetch_response_identifiers(pdg=pdg_bp,
                                                                            all_fetch_identifiers=fetch_sources)
    # => e.g., returns the "response1" in "fetch(url).then((response1) => console.log(response1))"
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = cookie_sources + cookie_response_sources + fetch_sources + fetch_response_sources

    # ##### ##### Sinks (plus their respective sender identifiers/patterns): ##### #####
    sendResponse_sinks: List[Node] = get_all_sendResponse_sinks(pdg_bp)  # "sendResponse" Identifiers
    port_postMessage_sinks: List[Node] = get_all_port_postMessage_sinks(pdg_bp)  # "port.postMessage" MemberExpressions
    assert all(port_postMessage_sink.parent.name == "CallExpression" for port_postMessage_sink in port_postMessage_sinks)
    sinks: List[Node] =\
        sendResponse_sinks +\
        port_postMessage_sinks
    sink_senders: List[List[Node]] =\
        [[sendResponse_sink.get_sibling_relative(-1)] for sendResponse_sink in sendResponse_sinks] +\
        [identifier_get_all_member_identifiers(port_postMessage_sink.lhs(), "sender")
                                                      for port_postMessage_sink in port_postMessage_sinks]
    # Note: the "sender" is the left sibling (relative -1) of "sendResponse": (message, sender, sendResponse)

    print(f"[3.1+4.1] No. of sources: {len(sources)}")
    print(f"\t=> No. of cookie sources: {len(cookie_sources) + len(cookie_response_sources)}")
    print(f"\t=> No. of fetch sources: {len(fetch_sources) + len(fetch_response_sources)}")

    print(f"[3.1+4.1] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of sendResponse sinks: {len(sendResponse_sinks)}")
    print(f"\t=> No. of port.postMessage sinks: {len(port_postMessage_sinks)}")

    detect_vuln_in_bp(
        pdg_bp=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=sink_senders,
        rendezvous_nodes=["CallExpression"],
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.1/3.1 non-UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.1/3.1 non-UXSS vulnerabilities"] = time_diff


def detect_41_31_vuln_in_bp_uxss(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    start = timeit.default_timer()

    # ##### ##### Sources (plus their respective sender identifiers/patterns): ##### #####
    msg_sources: List[Node] = get_all_msg_sources(pdg_bp)
    # => e.g., returns the "message" in "chrome.runtime.onMessage.addListener((message, sender, sendResponse) => ...);"
    sources: List[Node] =\
        msg_sources
    src_senders: List[List[Node]] =\
        [[s for s in [msg_src.get_sibling_relative_or_none(+1)] if s is not None] for msg_src in msg_sources]
    # Note: The "sender" is the right sibling (relative +1) of "message": (message, sender, sendResponse)
    #       It might not be present however when the programmer has left out parameters: (message) (!!!)
    # Note: The expression above turns `None` into `[]` and `s` into `[s]`.

    # ##### ##### Sinks: ##### #####
    document_sinks: List[Node] = get_all_document_identifiers(pdg_bp)  # "document" Identifiers
    chrome_tabs_executeScript_sinks: List[Node] =\
        get_all_chrome_tabs_executeScript_sinks(pdg_bp)  # "chrome.tabs.executeScript" MemberExpressions
    sinks: List[Node] = document_sinks + chrome_tabs_executeScript_sinks

    # Note that although "chrome.tabs.executeScript" is a deprecated <=MV2 API, "chrome.scripting.executeScript" dangers
    #   (MV3) are nonetheless detected via `document_sinks = get_all_document_identifiers(pdg_bp)` (see above)
    #   and `add_missing_data_flow_edges_chrome_apis()`, which has been previously executed!
    # = https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript

    print(f"[3.1+4.1/UXSS] No. of sources: {len(sources)}")
    print(f"\t=> No. of message sources: {len(msg_sources)}")

    print(f"[3.1+4.1/UXSS] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of document sinks: {len(document_sinks)}")
    print(f"\t=> No. of chrome.tabs.executeScript sinks (deprecated <=MV2 API): {len(chrome_tabs_executeScript_sinks)}")

    detect_vuln_in_bp(
        pdg_bp=pdg_bp,
        sources=sources, src_senders=src_senders,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression", "AssignmentExpression"],
        results=results,
        debug_prints=debug_prints
    )

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.1/3.1 UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.1/3.1 UXSS vulnerabilities"] = time_diff


def detect_vuln_in_bp(pdg_bp: Node,
                      sources: List[Node], src_senders: Optional[List[List[Node]]],
                      sinks: List[Node], sink_senders: Optional[List[List[Node]]],
                      rendezvous_nodes: List[str],
                      results: list,
                      debug_prints: bool):
    """
    Extraction of common logic from detect_41_31_vuln_in_bp_no_uxss(), detect_41_31_vuln_in_bp_uxss()
    and detect_42_32_vuln_in_bp().
    The main difference between the three however is whether there *is* a sender that might be verified and whether
        that sender is associated with the source (as with 4.1/3.1/UXSS) or with the sink (4.1/3.1/non-UXSS):
    * for 4.1/3.1/non-UXSS vulnerabilities, each sender corresponds to exactly one sink (sendResponse),
    * for 4.1/3.1/UXSS vulnerabilities, each sender corresponds to exactly one source (msg),
    * for 4.2/3.2/UXSS vulnerabilities, there is no sender (as the dangerous source is the extension storage!).
    Therefore, at most one of `src_senders` or `sink_senders` may be not `None`!

    This function has no return value.
    Instead, it appends to the given `results` list.

    Parameters:
        pdg_bp:       the root Node of the service worker's PDG
        sources:      the list of all Nodes where data flows may start
        src_senders:  has to be None if sink_senders is not None; has to have the same length as sources if not None
        sinks:        the list of all Nodes where data flows may end
        sink_senders: has to be None if src_senders is not None; has to have the same length as sinks if not None
        rendezvous_nodes: the list of allowed rendezvous Node names as strings,
                          cf. corresponding DoubleDataFlow.data_flows_into_function() parameter;
                          e.g.: ["CallExpression", "AssignmentExpression"]
        results:      the list to store the results in
        debug_prints: boolean, whether to print debug prints
    """
    assert not (src_senders is not None and sink_senders is not None)
    if sink_senders is not None:
        assert len(sinks) == len(sink_senders)
    if src_senders is not None:
        assert len(sources) == len(src_senders)

    try:
        for src_idx in range(len(sources)):
            for sink_idx in range(len(sinks)):
                if sink_senders is not None:
                    # Non-UXSS vulnerabilities/exfiltration dangers:
                    #   A: (msg, sender, sendResponse) where sendResponse=sink and therefore there's one sender per *sink*
                    #   B: port.postMessage=sink and sender=port.sender and therefore there's one sender per *sink*
                    sender_identifiers_or_patterns = sink_senders[sink_idx]
                elif src_senders is not None:
                    # UXSS vulnerabilities/infiltration dangers:
                    #   A: (msg, sender, sendResponse) where msg=source and therefore there's one sender per *source*
                    #   B: port.onMessage.addListener(msg => ...) where msg=source and sender=port.sender
                    #        and therefore there's one sender per *source*
                    sender_identifiers_or_patterns = src_senders[src_idx]
                else:
                    sender_identifiers_or_patterns = None  # no sender checks.

                source = sources[src_idx]
                sink = sinks[sink_idx]

                data_flows: List[DoubleDataFlow] = DoubleDataFlow.data_flows_into_function(
                    pdg=pdg_bp,
                    from_node=source,
                    to_node=sink,
                    rendezvous_nodes=rendezvous_nodes,
                    return_multiple=(os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') == "yes" or
                                     os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') != "yes")
                )
                # We need all data flows when there are multiple ones if...:
                # (a) the user specified --return-multiple-flow-variants
                # and/or
                # (b) the check for sender verification is on, i.e., RETURN_SAFE_FLOWS_VERIFIED is OFF(!)
                #
                # In other words:
                # We can *only* refrain from searching for multiple data flow if...:
                # (a) the user did *not* specify --return-multiple-flow-variants
                # *and*
                # (b) the check for sender verification is off, i.e., RETURN_SAFE_FLOWS_VERIFIED is ON
                #     (otherwise we could potentially miss an unsafe flow if we only look for 1 flow and that one just
                #      happens to be a safe one!)

                for data_flow in data_flows:
                    if debug_prints:
                        print(f"[Debug] Data flow: {data_flow}")

                    # the final dangerous rendezvous Node (CallExpr/AssignmentExpr):
                    sink_call: Node = data_flow.from_flow.last_node().get_ancestor(data_flow.rendezvous_nodes)

                    # Logic:

                    # if any node in data_flow lies_within any protected_block_of_code:
                    #    safe
                    # elif is there a return statement before the sink call and that return statement lies_within an
                    #      explicitly_dangerous_part_of_code and the if statement it's in is on the same depth as the sink call?:
                    #    safe
                    # else:
                    #    unsafe

                    # If *any* data flow node ("to" or "from" flow) lies within *any* protected block of code,
                    #     this data flow is safe:
                    if sender_identifiers_or_patterns is not None and\
                       any(any(node.lies_within(protected_block_of_code)
                               for sender_identifier_or_pattern in sender_identifiers_or_patterns
                               for protected_block_of_code in get_protected_blocks_of_code(pdg=pdg_bp,
                                                                                           pdg_subtree=pdg_bp,
                                                                                           # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                           sender_identifier_or_pattern=sender_identifier_or_pattern))
                           for node in data_flow.from_flow.nodes + data_flow.to_flow.nodes):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                    # If *any* return statement lies within *any* explicitly unsafe block of code that occurs before
                    #     the sink call, where if statement and sink call are on the same "indentation level", this
                    #     data flow is safe:
                    elif sender_identifiers_or_patterns is not None and\
                         any(any(return_statement.lies_within(explicitly_unsafe_block_of_code)
                                 and return_statement.occurs_in_code_before(sink_call)
                                 and return_statement.get_innermost_surrounding_if_statement().is_sibling_of(sink_call)
                                 for sender_identifier_or_pattern in sender_identifiers_or_patterns
                                 for explicitly_unsafe_block_of_code in get_explicitly_unsafe_blocks_of_code(pdg=pdg_bp,
                                                                                                             pdg_subtree=pdg_bp,
                                                                                                             # ToDo: smarter, more efficient, choice of pdg_subtree possible?!
                                                                                                             sender_identifier_or_pattern=sender_identifier_or_pattern))
                             for return_statement in pdg_bp.get_all_return_statements_inside()):
                        # safe; return only if --return-safe-flows-verified has been set:
                        if os.environ.get('RETURN_SAFE_FLOWS_VERIFIED') == "yes":
                            print(f"[4.1/3.1] Safe data flow found:\n{str(data_flow)}\n")
                            results.append(data_flow.as_pretty_dict())
                            if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                                raise StopIteration

                        # Catches:
                        #
                        # if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #     return; // return_statement // explicitly_unsafe_block_of_code
                        # }                               // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # But not:
                        #
                        # if (sender.url != "safe.com") {      // explicitly_unsafe_block_of_code
                        #     if (1==2) {                      // explicitly_unsafe_block_of_code
                        #          return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                                // explicitly_unsafe_block_of_code
                        # }                                    // explicitly_unsafe_block_of_code
                        # sendResponse(cookies); // sink_call
                        #
                        # And also not:
                        #
                        # if (1==1) {
                        #     /* ... */
                        # } else {
                        #     if (sender.url != "safe.com") { // explicitly_unsafe_block_of_code
                        #         return; // return_statement // explicitly_unsafe_block_of_code
                        #     }                               // explicitly_unsafe_block_of_code
                        # }
                        # sendResponse(cookies); // sink_call

                    else:
                        # unsafe
                        print(f"[4.1/3.1] Data flow found:\n{str(data_flow)}\n")
                        results.append(data_flow.as_pretty_dict())
                        if os.environ.get('RETURN_MULTIPLE_FLOW_VARIANTS') != "yes":
                            raise StopIteration

    except StopIteration:
        pass


def detect_31_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict):  # ToDo: include instances of chrome.runtime.onConnect as well!!!
    """
    Detects all violations of Kim and Lee's Security Requirement 3.1 (Extension Message Authentication),
    for which there is **NO** type 4.1 vulnerability (Execution of Privileged Browser APIs).

    An example of this would be the "Cisco Webex Extension" that violates Sec. Req. 3.1 by not authenticating
    incoming extension messages, however only resulting in the "Start Cisco Webex Meetings application", i.e.,
    something relatively harmless, no sensitive data exfiltration, no UXSS vector (cf. detect_41_31_vuln_in_bp()):

    ```
    chrome.runtime.onMessage.addListener(function(e, n) {
        if (console.log("[Background] onMessage:", e.ext_message_type), a.doiReady) {
            var o = {
                category: "browser-extension",
                event: "launch-meeting",
                extVal: e
            };
            doi.send("Event", o, !0)
        }
    })
    ```
    (code from the Cisco WebEx Extension, version 1.17.0)

    This function shall only be executed when the user supplies the
        --include-31-violations-without-privileged-api-access
    command line argument.
    """
    start = timeit.default_timer()

    all_msg_listeners: List[Node] = get_all_message_listeners(pdg_bp, resolve_function_references=True)
    print(f"[3.1, no 4.1] {len(all_msg_listeners)} message listeners found in total (in BP).")
    for msg_listener in all_msg_listeners:
        print(f"[3.1, no 4.1] Looking at message listener in line {msg_listener.get_line()} in file "
              f"'{msg_listener.get_file()}'...")
        if msg_listener.name == "FunctionExpression":
            # [1] [FunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- optional name for FunctionExpressions!!!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "ArrowFunctionExpression":
            # [1] [ArrowFunctionExpression] (4 children)
            #     [?] [Identifier:"foo"] (0 children)           <----- hypothetical, not actually possible for ArrowFE!
            #     [2] [Identifier:"msg"] (0 children)
            #     [3] [Identifier:"sender"] (0 children)        <----- sender_identifier_or_pattern
            #     [4] [Identifier:"sendResponse"] (0 children)
            #     [5] [BlockStatement] (0 children)             <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.arrow_function_expression_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "FunctionDeclaration":
            # [1] [FunctionDeclaration] (5 children) --e--> [6]
            # 		[2] [Identifier:"foo"] (0 children) --data--> [...]
            # 		[3] [Identifier:"msg"] (0 children)
            # 		[4] [Identifier:"sender"] (0 children)               <----- sender_identifier_or_pattern
            # 		[5] [Identifier:"sendResponse"] (0 children)
            # 		[6] [BlockStatement] (0 children)                    <----- block_of_code
            block_of_code = msg_listener.get_child("BlockStatement")
            parameters = msg_listener.function_declaration_get_params()
            sender_identifier_or_pattern = None if len(parameters) < 2 else parameters[1]
        elif msg_listener.name == "Identifier":
            print(f"[3.1, no 4.1] [Warning] message listener function reference '{msg_listener.attributes['name']}' "
                  f"in line {msg_listener.get_line()}, file '{msg_listener.get_file()}', could not be resolved, "
                  f"likely missing something...")
            continue
        else:
            print(f"[3.1, no 4.1] [Warning] Unexpected Node type of message listener: {msg_listener.name}, "
                  f"likely missing something...")
            continue

        # print(f"[3.1, no 4.1] block_of_code = {block_of_code}")
        # print(f"[3.1, no 4.1] sender_identifier_or_pattern = {sender_identifier_or_pattern}")

        # For each block of code inside a message listener, add it to the result set, if:
        #     (a) the block contains no sensitive API access whatsoever
        #     (b) the block contains no (correct) sender verification whatsoever

        sensitive_apis = block_of_code.get_sensitive_apis_accessed()
        print(f"[3.1, no 4.1] {len(sensitive_apis)} sensitive APIs found.")

        protected_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_protected_blocks_of_code(pdg=pdg_bp,
                                                                         pdg_subtree=block_of_code,
                                                                         sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(protected_blocks_of_code)} protected blocks of code found.")

        explicitly_unsafe_blocks_of_code = [] if sender_identifier_or_pattern is None else\
                                            get_explicitly_unsafe_blocks_of_code(pdg=pdg_bp,
                                                                                 pdg_subtree=block_of_code,
                                                                                 sender_identifier_or_pattern=sender_identifier_or_pattern)
        print(f"[3.1, no 4.1] {len(explicitly_unsafe_blocks_of_code)} explicitly unsafe blocks of code found.")

        # --include-31-violations-without-privileged-api-access help text:
        #     Include violations of Security Requirement 3.1 (Extension Message Authentication),
        #         even when no privileged API (like chrome.cookies, chrome.scripting or indexedDB)
        #         is accessed (4.1).
        if (len(sensitive_apis) == 0  # no 4.1 vulnerability...
                and len(protected_blocks_of_code) == 0  # ...but still a 3.1 security requirement violation.
                and len(explicitly_unsafe_blocks_of_code) == 0):
            results.append({
                "msg_listener": {
                    "location": msg_listener.get_location(),
                    "filename": msg_listener.get_file(),
                    "line_of_code": msg_listener.get_whole_line_of_code_as_string()
                },
                "block_of_code": {
                    "location": block_of_code.get_location(),
                    "filename": block_of_code.get_file(),
                    "line_of_code": block_of_code.get_whole_line_of_code_as_string()
                }
            })

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 3.1 violations w/o privileged API access in {time_diff}s')
    benchmarks[f"bp: 3.1 violations w/o privileged API access"] = time_diff


def detect_42_32_vuln_in_bp(pdg_bp: Node, results: list, benchmarks: dict, debug_prints=False):
    """
    Look for type 4.2 vulnerabilities in the given background page/service worker (or rather its PDG), type 4.2
    vulnerabilities refer to the ability to `Write Sensitive Extension Data`,
    which is a security violation of type 3.2: `Non-sensitive Data in Extension Storage`
    (refer to Kim and Lee paper for more info)

    We shall restrict ourselves to *infiltration* dangers, leading to UXSS, cf. detect_41_31_vuln_in_bp_uxss(),
    where the dangerous source is an extension message instead of the extension storage, which it is here.

    Example vulnerability:
    ```
    chrome.storage.local.get(["user_name"]).then((result) => {
        chrome.tabs.query({},
            (tabs) => {
                tabs.forEach((tab) => {
                    chrome.scripting.executeScript({
                        target: { tabId: tab.id },
                        func: (uname) => {
                            const body = document.getElementsByTagName('body')[0];
                            const new_span = document.createElement('span');
                            new_span.innerHTML = 'Hello ' + uname + '!';
                            body.append(new_span);

                        },
                        args: ["" + result["user_name"]]
                    });
                });
            }
        );
    });
    ```

    Note that, as opposed to 4.1/3.1 vulnerabilities, there is no way to *verify* a sender, as there is no sender
    (the infiltrated data stems from the extension storage and not from an extension message); therefore we do not
    have to check for sender verification and the code logic is simpler.
    """
    start = timeit.default_timer()

    # ##### ##### Sources (cf. detect_41_31_vuln_in_bp_no_uxss()): ##### #####
    # Sources might be:
    #     - the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #     - the "result" in: chrome.storage.local.get('key', function (result) {});
    #     - the "result" in: const result = await chrome.storage.local.get("key");
    #     ...where "storage.local" may be replaced with "storage.sync"
    #        and "chrome" may be replaced with "browser" or any other arbitrary MemberExpression!
    storage_get_sources: List[Node] = get_all_storage_get_identifiers(pdg_bp)
    # => e.g., returns the "get" in "const result = await chrome.storage.local.get('key')"
    #    => data flow may continue from there, first into "result" and then beyond...
    storage_response_sources: List[Node] = get_all_storage_response_identifiers(pdg_bp)  # (optional ToDo: optimization: reuse storage_get_sources result)
    # => e.g., returns the "result" in: chrome.storage.local.get(["key"]).then((result) => {});
    #               or the "result" in: chrome.storage.local.get('key', function (result) {});
    #    => data flow may continue from there, inside the (anonymous) function...
    sources: List[Node] = storage_get_sources + storage_response_sources

    # ##### ##### Sinks (cf. detect_41_31_vuln_in_bp_uxss()): ##### #####
    document_sinks: List[Node] = get_all_document_identifiers(pdg_bp)  # "document" Identifiers
    chrome_tabs_executeScript_sinks: List[Node] = \
        get_all_chrome_tabs_executeScript_sinks(pdg_bp)  # "chrome.tabs.executeScript" MemberExpressions
    sinks: List[Node] = document_sinks + chrome_tabs_executeScript_sinks

    # Note that although "chrome.tabs.executeScript" is a deprecated <=MV2 API, "chrome.scripting.executeScript" dangers
    #   (MV3) are nonetheless detected via `document_sinks = get_all_document_identifiers(pdg_bp)` (see above)
    #   and `add_missing_data_flow_edges_chrome_apis()`, which has been previously executed!
    # = https://developer.chrome.com/docs/extensions/reference/api/tabs#method-executeScript

    detect_vuln_in_bp(
        pdg_bp=pdg_bp,
        sources=sources, src_senders=None,
        sinks=sinks, sink_senders=None,
        rendezvous_nodes=["CallExpression", "AssignmentExpression"],
        results=results,
        debug_prints=debug_prints
    )

    print(f"[3.2+4.2/UXSS] No. of sources: {len(sources)}")
    print(f"\t=> No. of StorageArea.get() sources: {len(storage_get_sources) + len(storage_response_sources)}")

    print(f"[3.2+4.2/UXSS] No. of sinks: {len(sinks)}")
    print(f"\t=> No. of document sinks: {len(document_sinks)}")
    print(f"\t=> No. of chrome.tabs.executeScript sinks (deprecated <=MV2 API): {len(chrome_tabs_executeScript_sinks)}")

    time_diff = timeit.default_timer() - start
    print(f'Successfully analyzed BP for 4.2/3.2 UXSS vulnerabilities in {time_diff}s')
    benchmarks[f"bp: 4.2/3.2 UXSS vulnerabilities"] = time_diff
